; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mma8451.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mma8451.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\mma8451.crf Source\MMA8451.c]
                          THUMB

                          AREA ||i.approx_atan2f||, CODE, READONLY, ALIGN=2

                  approx_atan2f PROC
;;;86     
;;;87      float approx_atan2f(float y, float x)
000000  b5f8              PUSH     {r3-r7,lr}
;;;88     {
;;;89     	//http://pubs.opengroup.org/onlinepubs/009695399/functions/atan2.html
;;;90     	//Volkan SALMA
;;;91     
;;;92     	const float ONEQTR_PI = M_PI / 4.0;
;;;93     	const float THRQTR_PI = 3.0 * M_PI / 4.0;
;;;94     	float r, angle;
;;;95     	float abs_y = fabs(y) + 1e-10f;      // kludge to prevent 0/0 condition
000002  0046              LSLS     r6,r0,#1
000004  460c              MOV      r4,r1                 ;88
000006  4607              MOV      r7,r0                 ;88
000008  0876              LSRS     r6,r6,#1
00000a  491c              LDR      r1,|L1.124|
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       __aeabi_fadd
;;;96     	if ( x < 0.0f )
000012  2501              MOVS     r5,#1
000014  9000              STR      r0,[sp,#0]
000016  07ed              LSLS     r5,r5,#31
000018  4630              MOV      r0,r6
00001a  4918              LDR      r1,|L1.124|
00001c  f7fffffe          BL       __aeabi_fadd
000020  4601              MOV      r1,r0                 ;95
000022  4620              MOV      r0,r4                 ;88
;;;97     	{
;;;98     		r = (x + abs_y) / (abs_y - x);
000024  f7fffffe          BL       __aeabi_fadd
000028  4606              MOV      r6,r0
00002a  42ac              CMP      r4,r5                 ;96
00002c  d90a              BLS      |L1.68|
00002e  4621              MOV      r1,r4
000030  9800              LDR      r0,[sp,#0]
000032  f7fffffe          BL       __aeabi_fsub
000036  4601              MOV      r1,r0
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       __aeabi_fdiv
00003e  4606              MOV      r6,r0
;;;99     		angle = THRQTR_PI;
000040  4c0f              LDR      r4,|L1.128|
000042  e008              B        |L1.86|
                  |L1.68|
;;;100    	}
;;;101    	else
;;;102    	{
;;;103    		r = (x - abs_y) / (x + abs_y);
000044  4620              MOV      r0,r4
000046  9900              LDR      r1,[sp,#0]
000048  f7fffffe          BL       __aeabi_fsub
00004c  4631              MOV      r1,r6
00004e  f7fffffe          BL       __aeabi_fdiv
;;;104    		angle = ONEQTR_PI;
000052  4c0c              LDR      r4,|L1.132|
000054  4606              MOV      r6,r0                 ;103
                  |L1.86|
;;;105    	}
;;;106    	angle += (0.1963f * r * r - 0.9817f) * r;
000056  490c              LDR      r1,|L1.136|
000058  f7fffffe          BL       __aeabi_fmul
00005c  4631              MOV      r1,r6
00005e  f7fffffe          BL       __aeabi_fmul
000062  490a              LDR      r1,|L1.140|
000064  f7fffffe          BL       __aeabi_fsub
000068  4631              MOV      r1,r6
00006a  f7fffffe          BL       __aeabi_fmul
00006e  4621              MOV      r1,r4
000070  f7fffffe          BL       __aeabi_fadd
;;;107    	if ( y < 0.0f )
000074  42af              CMP      r7,r5
000076  d900              BLS      |L1.122|
;;;108    		return( -angle );     // negate if in quad III or IV
000078  4068              EORS     r0,r0,r5
                  |L1.122|
;;;109    	else
;;;110    		return( angle );
;;;111    }
00007a  bdf8              POP      {r3-r7,pc}
;;;112    
                          ENDP

                  |L1.124|
                          DCD      0x2edbe6ff
                  |L1.128|
                          DCD      0x4016cbe4
                  |L1.132|
                          DCD      0x3f490fdb
                  |L1.136|
                          DCD      0x3e4902de
                  |L1.140|
                          DCD      0x3f7b50b1

                          AREA ||i.approx_sqrt||, CODE, READONLY, ALIGN=1

                  approx_sqrt PROC
;;;75     
;;;76     float approx_sqrt(float x)
000000  217f              MOVS     r1,#0x7f
;;;77      {
;;;78     	 // http://bits.stephan-brumme.com/squareRoot.html
;;;79        unsigned int i = *(unsigned int*) &x; 
;;;80        // adjust bias
;;;81        i  += 127 << 23;
000002  05c9              LSLS     r1,r1,#23
000004  1840              ADDS     r0,r0,r1
;;;82        // approximation of square root
;;;83        i >>= 1; 
000006  0840              LSRS     r0,r0,#1
;;;84        return *(float*) &i;
;;;85      }   
000008  4770              BX       lr
;;;86     
                          ENDP


                          AREA ||i.convert_xyz_to_roll_pitch||, CODE, READONLY, ALIGN=2

                  convert_xyz_to_roll_pitch PROC
;;;112    
;;;113    void convert_xyz_to_roll_pitch(void) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;114    	float ax = acc_X/COUNTS_PER_G,
000002  4c24              LDR      r4,|L3.148|
000004  2000              MOVS     r0,#0
000006  5e20              LDRSH    r0,[r4,r0]  ; acc_X
000008  f7fffffe          BL       __aeabi_i2f
00000c  250d              MOVS     r5,#0xd
00000e  43ed              MVNS     r5,r5
000010  4629              MOV      r1,r5
000012  f7fffffe          BL       __ARM_scalbnf
000016  4607              MOV      r7,r0
;;;115    				ay = acc_Y/COUNTS_PER_G,
000018  2002              MOVS     r0,#2
00001a  5e20              LDRSH    r0,[r4,r0]  ; acc_Y
00001c  f7fffffe          BL       __aeabi_i2f
000020  4629              MOV      r1,r5
000022  f7fffffe          BL       __ARM_scalbnf
000026  4606              MOV      r6,r0
;;;116    				az = acc_Z/COUNTS_PER_G;
000028  2004              MOVS     r0,#4
00002a  5e20              LDRSH    r0,[r4,r0]  ; acc_Z
00002c  f7fffffe          BL       __aeabi_i2f
000030  4629              MOV      r1,r5
000032  f7fffffe          BL       __ARM_scalbnf
000036  4605              MOV      r5,r0
;;;117    #if VALIDATE
;;;118    	float roll_ref, pitch_ref;
;;;119    #endif
;;;120    	
;;;121    	roll = atan2(ay, az)*180/M_PI;
000038  4601              MOV      r1,r0
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       atan2f
000040  4915              LDR      r1,|L3.152|
000042  f7fffffe          BL       __aeabi_fmul
000046  4915              LDR      r1,|L3.156|
000048  f7fffffe          BL       __aeabi_fmul
;;;122    	pitch = atan2(ax, sqrt(ay*ay + az*az))*180/M_PI;
00004c  4629              MOV      r1,r5
00004e  60a0              STR      r0,[r4,#8]  ; roll
000050  4608              MOV      r0,r1
000052  f7fffffe          BL       __aeabi_fmul
000056  4605              MOV      r5,r0
000058  4631              MOV      r1,r6
00005a  4608              MOV      r0,r1
00005c  f7fffffe          BL       __aeabi_fmul
000060  4629              MOV      r1,r5
000062  f7fffffe          BL       __aeabi_fadd
000066  f7fffffe          BL       __aeabi_f2d
00006a  f7fffffe          BL       sqrt
00006e  4605              MOV      r5,r0
000070  460e              MOV      r6,r1
000072  4638              MOV      r0,r7
000074  f7fffffe          BL       __aeabi_f2d
000078  462a              MOV      r2,r5
00007a  4633              MOV      r3,r6
00007c  f7fffffe          BL       atan2
000080  f7fffffe          BL       __aeabi_d2f
000084  4904              LDR      r1,|L3.152|
000086  f7fffffe          BL       __aeabi_fmul
00008a  4904              LDR      r1,|L3.156|
00008c  f7fffffe          BL       __aeabi_fmul
000090  60e0              STR      r0,[r4,#0xc]  ; pitch
;;;123    
;;;124    #if VALIDATE
;;;125    	if (!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) { 
;;;126    		roll_ref = atan2f(ay, az)*(180/M_PI);
;;;127    		pitch_ref = atan2f(ax, sqrt(ay*ay + az*az))*(180/M_PI);
;;;128    		if (fabs(roll-roll_ref) > MAX_ERROR) {
;;;129    			printf("Roll Error: %f, should be %f.\n\r ay=%f, az=%f\n\r", roll, roll_ref, ay, az);
;;;130    		}
;;;131    		if (fabs(pitch-pitch_ref) > MAX_ERROR) {
;;;132    			printf("Pitch Error: %f, should be %f.\n\r ax=%f, ay=%f, az=%f\n\r", pitch, pitch_ref, ax, ay, az);
;;;133    		}
;;;134    	}
;;;135    #endif
;;;136    	
;;;137    #if SHOW_DATA
;;;138    	printf("Roll: %f \tPitch: %f\n\r", roll, pitch);
;;;139    #endif
;;;140    }
000092  bdf8              POP      {r3-r7,pc}
                          ENDP

                  |L3.148|
                          DCD      ||.data||
                  |L3.152|
                          DCD      0x43340000
                  |L3.156|
                          DCD      0x3ea2f983

                          AREA ||i.init_mma||, CODE, READONLY, ALIGN=1

                  init_mma PROC
;;;22      */
;;;23     int init_mma()
000000  b510              PUSH     {r4,lr}
;;;24     {
;;;25     	  //check for device
;;;26     		if(i2c_read_byte(MMA_ADDR, REG_WHOAMI) == WHOAMI)	{	
000002  210d              MOVS     r1,#0xd
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       i2c_read_byte
00000a  281a              CMP      r0,#0x1a
00000c  d001              BEQ      |L4.18|
;;;27     		  Delay(100);
;;;28     		  //turn on data ready irq; defaults to int2 (PTA15)
;;;29     		  i2c_write_byte(MMA_ADDR, REG_CTRL4, 0x01);
;;;30     		  Delay(100);
;;;31     		  //set active, 14bit mode, low noise and 100Hz (0x1D)
;;;32     		  i2c_write_byte(MMA_ADDR, REG_CTRL1, 0x1D);
;;;33     				
;;;34     		  //enable the irq in the NVIC
;;;35     		  //NVIC_EnableIRQ(PORTA_IRQn);
;;;36     		  return 1;
;;;37     		}
;;;38     		
;;;39     		//else error
;;;40     		return 0;
00000e  2000              MOVS     r0,#0
;;;41     }
000010  bd10              POP      {r4,pc}
                  |L4.18|
000012  2064              MOVS     r0,#0x64              ;27
000014  f7fffffe          BL       Delay
000018  2201              MOVS     r2,#1                 ;29
00001a  212d              MOVS     r1,#0x2d              ;29
00001c  203a              MOVS     r0,#0x3a              ;29
00001e  f7fffffe          BL       i2c_write_byte
000022  2064              MOVS     r0,#0x64              ;30
000024  f7fffffe          BL       Delay
000028  221d              MOVS     r2,#0x1d              ;32
00002a  212a              MOVS     r1,#0x2a              ;32
00002c  203a              MOVS     r0,#0x3a              ;32
00002e  f7fffffe          BL       i2c_write_byte
000032  2001              MOVS     r0,#1                 ;36
000034  bd10              POP      {r4,pc}
;;;42     
                          ENDP


                          AREA ||i.read_full_xyz||, CODE, READONLY, ALIGN=2

                  read_full_xyz PROC
;;;45     */
;;;46     void read_full_xyz()
000000  b57c              PUSH     {r2-r6,lr}
;;;47     {
;;;48     	
;;;49     	int i;
;;;50     	uint8_t data[6];
;;;51     	
;;;52     	i2c_start();
000002  f7fffffe          BL       i2c_start
;;;53     	i2c_read_setup(MMA_ADDR , REG_XHI);
000006  2101              MOVS     r1,#1
000008  203a              MOVS     r0,#0x3a
00000a  f7fffffe          BL       i2c_read_setup
;;;54     	
;;;55     	for( i=0;i<6;i++)	{
00000e  2400              MOVS     r4,#0
000010  466d              MOV      r5,sp                 ;50
000012  e001              B        |L5.24|
                  |L5.20|
;;;56     		if(i==5)
000014  2c05              CMP      r4,#5
000016  d014              BEQ      |L5.66|
                  |L5.24|
;;;57     			data[i] = i2c_repeated_read(1);
;;;58     		else
;;;59     			data[i] = i2c_repeated_read(0);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       i2c_repeated_read
00001e  5528              STRB     r0,[r5,r4]
000020  1c64              ADDS     r4,r4,#1
000022  2c06              CMP      r4,#6                 ;55
000024  dbf6              BLT      |L5.20|
                  |L5.38|
;;;60     	}
;;;61     	
;;;62     	acc_X = (((int16_t) data[0])<<8) | data[1];
000026  4669              MOV      r1,sp
000028  8808              LDRH     r0,[r1,#0]
00002a  ba41              REV16    r1,r0
00002c  4808              LDR      r0,|L5.80|
00002e  8001              STRH     r1,[r0,#0]
;;;63     	acc_Y = (((int16_t) data[2])<<8) | data[3];
000030  4669              MOV      r1,sp
000032  8849              LDRH     r1,[r1,#2]
000034  ba49              REV16    r1,r1
000036  8041              STRH     r1,[r0,#2]
;;;64     	acc_Z = (((int16_t) data[4])<<8) | data[5];
000038  4669              MOV      r1,sp
00003a  8889              LDRH     r1,[r1,#4]
00003c  ba49              REV16    r1,r1
00003e  8081              STRH     r1,[r0,#4]
;;;65     }
000040  bd7c              POP      {r2-r6,pc}
                  |L5.66|
000042  2001              MOVS     r0,#1                 ;57
000044  f7fffffe          BL       i2c_repeated_read
000048  4669              MOV      r1,sp                 ;57
00004a  7148              STRB     r0,[r1,#5]            ;57
00004c  e7eb              B        |L5.38|
;;;66     
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      ||.data||

                          AREA ||i.read_xyz||, CODE, READONLY, ALIGN=2

                  read_xyz PROC
;;;66     
;;;67     void read_xyz(void)
000000  b510              PUSH     {r4,lr}
;;;68     {
;;;69     	// sign extend byte to 16 bits - need to cast to signed since function
;;;70     	// returns uint8_t which is unsigned
;;;71     	acc_X = ((int16_t) ((int8_t) i2c_read_byte(MMA_ADDR, REG_XHI))) << 8;
000002  2101              MOVS     r1,#1
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       i2c_read_byte
00000a  4c08              LDR      r4,|L6.44|
00000c  0200              LSLS     r0,r0,#8
00000e  8020              STRH     r0,[r4,#0]
;;;72     	acc_Y = ((int16_t) ((int8_t) i2c_read_byte(MMA_ADDR, REG_YHI))) << 8;
000010  2103              MOVS     r1,#3
000012  203a              MOVS     r0,#0x3a
000014  f7fffffe          BL       i2c_read_byte
000018  0200              LSLS     r0,r0,#8
00001a  8060              STRH     r0,[r4,#2]
;;;73     	acc_Z = ((int16_t) ((int8_t) i2c_read_byte(MMA_ADDR, REG_ZHI))) << 8;
00001c  2105              MOVS     r1,#5
00001e  203a              MOVS     r0,#0x3a
000020  f7fffffe          BL       i2c_read_byte
000024  0200              LSLS     r0,r0,#8
000026  80a0              STRH     r0,[r4,#4]
;;;74     }
000028  bd10              POP      {r4,pc}
;;;75     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  acc_X
000000  0000              DCW      0x0000
                  acc_Y
000002  0000              DCW      0x0000
                  acc_Z
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  roll
000008  00000000          DCFS     0x00000000 ; 0
                  pitch
00000c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "Source\\MMA8451.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_MMA8451_c_acc_X____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_MMA8451_c_acc_X____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_MMA8451_c_acc_X____REVSH|
#line 462
|__asm___9_MMA8451_c_acc_X____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
