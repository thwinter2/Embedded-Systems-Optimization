; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\pff.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\pff.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\pff.crf Source\FS\pff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;783    
;;;784    static BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
000000  b570              PUSH     {r4-r6,lr}
;;;785    	BYTE *buf,	/* Working buffer */
;;;786    	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;787    )
;;;788    {
;;;789    	if (disk_readp(buf, sect, 510, 2)) {	/* Read the boot record */
000002  22ff              MOVS     r2,#0xff
000004  460d              MOV      r5,r1                 ;788
000006  4604              MOV      r4,r0                 ;788
000008  2302              MOVS     r3,#2
00000a  32ff              ADDS     r2,r2,#0xff
00000c  f7fffffe          BL       disk_readp
000010  2800              CMP      r0,#0
000012  d001              BEQ      |L1.24|
;;;790    		return 3;
000014  2003              MOVS     r0,#3
;;;791    	}
;;;792    	if (ld_word(buf) != 0xAA55) {			/* Check record signature */
;;;793    		return 2;
;;;794    	}
;;;795    
;;;796    	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && ld_word(buf) == 0x4146) {	/* Check FAT12/16 */
;;;797    		return 0;
;;;798    	}
;;;799    	if (PF_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && ld_word(buf) == 0x4146) {	/* Check FAT32 */
;;;800    		return 0;
;;;801    	}
;;;802    	return 1;
;;;803    }
000016  bd70              POP      {r4-r6,pc}
                  |L1.24|
000018  4620              MOV      r0,r4                 ;792
00001a  f7fffffe          BL       ld_word
00001e  490b              LDR      r1,|L1.76|
000020  4288              CMP      r0,r1                 ;792
000022  d001              BEQ      |L1.40|
000024  2002              MOVS     r0,#2                 ;793
000026  bd70              POP      {r4-r6,pc}
                  |L1.40|
000028  2302              MOVS     r3,#2                 ;799
00002a  2252              MOVS     r2,#0x52              ;799
00002c  4629              MOV      r1,r5                 ;799
00002e  4620              MOV      r0,r4                 ;799
000030  f7fffffe          BL       disk_readp
000034  2800              CMP      r0,#0                 ;799
000036  d107              BNE      |L1.72|
000038  4620              MOV      r0,r4                 ;799
00003a  f7fffffe          BL       ld_word
00003e  4904              LDR      r1,|L1.80|
000040  4288              CMP      r0,r1                 ;799
000042  d101              BNE      |L1.72|
000044  2000              MOVS     r0,#0                 ;800
000046  bd70              POP      {r4-r6,pc}
                  |L1.72|
000048  2001              MOVS     r0,#1                 ;802
00004a  bd70              POP      {r4-r6,pc}
;;;804    
                          ENDP

                  |L1.76|
                          DCD      0x0000aa55
                  |L1.80|
                          DCD      0x00004146

                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=2

                  clust2sect PROC
;;;479    
;;;480    static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
000000  4906              LDR      r1,|L2.28|
;;;481    	CLUST clst		/* Cluster# to be converted */
;;;482    )
;;;483    {
;;;484    	FATFS *fs = FatFs;
;;;485    
;;;486    
;;;487    	clst -= 2;
;;;488    	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
000002  1e80              SUBS     r0,r0,#2
000004  6809              LDR      r1,[r1,#0]            ;484  ; FatFs
000006  688a              LDR      r2,[r1,#8]
000008  1e92              SUBS     r2,r2,#2
00000a  4282              CMP      r2,r0
00000c  d801              BHI      |L2.18|
00000e  2000              MOVS     r0,#0
;;;489    	return (DWORD)clst * fs->csize + fs->database;
;;;490    }
000010  4770              BX       lr
                  |L2.18|
000012  788a              LDRB     r2,[r1,#2]            ;489
000014  4342              MULS     r2,r0,r2              ;489
000016  6948              LDR      r0,[r1,#0x14]         ;489
000018  1810              ADDS     r0,r2,r0              ;489
00001a  4770              BX       lr
;;;491    
                          ENDP

                  |L2.28|
                          DCD      ||.data||

                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;651    
;;;652    static FRESULT create_name (
000000  b5f0              PUSH     {r4-r7,lr}
;;;653    	DIR *dj,			/* Pointer to the directory object */
;;;654    	const char **path	/* Pointer to pointer to the segment in the path string */
;;;655    )
;;;656    {
;;;657    	BYTE c, d, ni, si, i, *sfn;
;;;658    	const char *p;
;;;659    #if PF_USE_LCC && defined(_EXCVT)
;;;660    	static const BYTE cvt[] = _EXCVT;
;;;661    #endif
;;;662    
;;;663    	/* Create file name in directory form */
;;;664    	sfn = dj->fn;
;;;665    	mem_set(sfn, ' ', 11);
000002  6844              LDR      r4,[r0,#4]
000004  2020              MOVS     r0,#0x20
000006  220b              MOVS     r2,#0xb
000008  4623              MOV      r3,r4
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  7018              STRB     r0,[r3,#0]            ;656
00000e  1c5b              ADDS     r3,r3,#1              ;656
                  |L3.16|
000010  1e52              SUBS     r2,r2,#1              ;656
000012  d2fb              BCS      |L3.12|
;;;666    	si = i = 0; ni = 8;
000014  2200              MOVS     r2,#0
;;;667    	p = *path;
000016  680e              LDR      r6,[r1,#0]
000018  4613              MOV      r3,r2                 ;666
00001a  2508              MOVS     r5,#8                 ;666
                  |L3.28|
;;;668    	for (;;) {
;;;669    		c = p[si++];
00001c  5cf0              LDRB     r0,[r6,r3]
00001e  1c5b              ADDS     r3,r3,#1
000020  b2db              UXTB     r3,r3
;;;670    		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
000022  2820              CMP      r0,#0x20
000024  d909              BLS      |L3.58|
000026  282f              CMP      r0,#0x2f
000028  d007              BEQ      |L3.58|
;;;671    		if (c == '.' || i >= ni) {
00002a  282e              CMP      r0,#0x2e
00002c  d001              BEQ      |L3.50|
00002e  42aa              CMP      r2,r5
000030  d30c              BCC      |L3.76|
                  |L3.50|
;;;672    			if (ni != 8 || c != '.') break;
000032  2d08              CMP      r5,#8
000034  d101              BNE      |L3.58|
000036  282e              CMP      r0,#0x2e
000038  d005              BEQ      |L3.70|
                  |L3.58|
;;;673    			i = 8; ni = 11;
;;;674    			continue;
;;;675    		}
;;;676    #if PF_USE_LCC && defined(_EXCVT)
;;;677    		if (c >= 0x80) c = cvt[c - 0x80];	/* To upper extended char (SBCS) */
;;;678    #endif
;;;679    		if (IsDBCS1(c) && i < ni - 1) {	/* DBC 1st byte? */
;;;680    			d = p[si++];				/* Get 2nd byte */
;;;681    			sfn[i++] = c;
;;;682    			sfn[i++] = d;
;;;683    		} else {						/* Single byte code */
;;;684    			if (PF_USE_LCC && IsLower(c)) c -= 0x20;	/* toupper */
;;;685    			sfn[i++] = c;
;;;686    		}
;;;687    	}
;;;688    	*path = &p[si];						/* Rerurn pointer to the next segment */
00003a  18f2              ADDS     r2,r6,r3
;;;689    
;;;690    	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
00003c  600a              STR      r2,[r1,#0]
00003e  2820              CMP      r0,#0x20
000040  d814              BHI      |L3.108|
000042  2001              MOVS     r0,#1
000044  e013              B        |L3.110|
                  |L3.70|
000046  2208              MOVS     r2,#8                 ;673
000048  250b              MOVS     r5,#0xb               ;673
00004a  e7e7              B        |L3.28|
                  |L3.76|
00004c  2880              CMP      r0,#0x80              ;677
00004e  d303              BCC      |L3.88|
000050  4f08              LDR      r7,|L3.116|
000052  1838              ADDS     r0,r7,r0              ;677
000054  3880              SUBS     r0,r0,#0x80           ;677
000056  7800              LDRB     r0,[r0,#0]            ;677
                  |L3.88|
000058  4607              MOV      r7,r0                 ;684
00005a  3f61              SUBS     r7,r7,#0x61           ;684
00005c  2f19              CMP      r7,#0x19              ;684
00005e  d801              BHI      |L3.100|
000060  3820              SUBS     r0,r0,#0x20           ;684
000062  b2c0              UXTB     r0,r0                 ;684
                  |L3.100|
000064  54a0              STRB     r0,[r4,r2]            ;685
000066  1c52              ADDS     r2,r2,#1              ;685
000068  b2d2              UXTB     r2,r2                 ;685
00006a  e7d7              B        |L3.28|
                  |L3.108|
00006c  2000              MOVS     r0,#0
                  |L3.110|
00006e  72e0              STRB     r0,[r4,#0xb]
;;;691    
;;;692    	return FR_OK;
000070  2000              MOVS     r0,#0
;;;693    }
000072  bdf0              POP      {r4-r7,pc}
;;;694    
                          ENDP

                  |L3.116|
                          DCD      ||.constdata||

                          AREA ||i.dir_find||, CODE, READONLY, ALIGN=1

                  dir_find PROC
;;;584    
;;;585    static FRESULT dir_find (
000000  b5f8              PUSH     {r3-r7,lr}
;;;586    	DIR *dj,		/* Pointer to the directory object linked to the file name */
;;;587    	BYTE *dir		/* 32-byte working buffer */
;;;588    )
;;;589    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;590    	FRESULT res;
;;;591    	BYTE c;
;;;592    
;;;593    
;;;594    	res = dir_rewind(dj);			/* Rewind directory object */
000006  f7fffffe          BL       dir_rewind
;;;595    	if (res != FR_OK) return res;
00000a  2800              CMP      r0,#0
00000c  d10a              BNE      |L4.36|
                  |L4.14|
;;;596    
;;;597    	do {
;;;598    		res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32)	/* Read an entry */
00000e  7830              LDRB     r0,[r6,#0]
000010  2320              MOVS     r3,#0x20
000012  0700              LSLS     r0,r0,#28
000014  0dc2              LSRS     r2,r0,#23
000016  4628              MOV      r0,r5
000018  6931              LDR      r1,[r6,#0x10]
00001a  f7fffffe          BL       disk_readp
00001e  2800              CMP      r0,#0
000020  d001              BEQ      |L4.38|
;;;599    			? FR_DISK_ERR : FR_OK;
000022  2001              MOVS     r0,#1
                  |L4.36|
;;;600    		if (res != FR_OK) break;
;;;601    		c = dir[DIR_Name];	/* First character */
;;;602    		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
;;;603    		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) break;	/* Is it a valid entry? */
;;;604    		res = dir_next(dj);					/* Next entry */
;;;605    	} while (res == FR_OK);
;;;606    
;;;607    	return res;
;;;608    }
000024  bdf8              POP      {r3-r7,pc}
                  |L4.38|
000026  7829              LDRB     r1,[r5,#0]            ;601
000028  2000              MOVS     r0,#0                 ;599
00002a  2900              CMP      r1,#0                 ;602
00002c  d006              BEQ      |L4.60|
00002e  7ae9              LDRB     r1,[r5,#0xb]          ;603
000030  0709              LSLS     r1,r1,#28             ;603
000032  d410              BMI      |L4.86|
000034  462c              MOV      r4,r5                 ;603
000036  210a              MOVS     r1,#0xa               ;589
000038  6872              LDR      r2,[r6,#4]            ;589
00003a  e003              B        |L4.68|
                  |L4.60|
00003c  2003              MOVS     r0,#3                 ;602
                  |L4.62|
00003e  bdf8              POP      {r3-r7,pc}
                  |L4.64|
000040  1e49              SUBS     r1,r1,#1
000042  d306              BCC      |L4.82|
                  |L4.68|
000044  7823              LDRB     r3,[r4,#0]
000046  7817              LDRB     r7,[r2,#0]
000048  1c52              ADDS     r2,r2,#1
00004a  1c64              ADDS     r4,r4,#1
00004c  1bdb              SUBS     r3,r3,r7
00004e  d0f7              BEQ      |L4.64|
000050  e001              B        |L4.86|
                  |L4.82|
000052  2b00              CMP      r3,#0                 ;603
000054  d0f3              BEQ      |L4.62|
                  |L4.86|
000056  4630              MOV      r0,r6                 ;604
000058  f7fffffe          BL       dir_next
00005c  2800              CMP      r0,#0                 ;605
00005e  d0d6              BEQ      |L4.14|
000060  bdf8              POP      {r3-r7,pc}
;;;609    
                          ENDP


                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=2

                  dir_next PROC
;;;543    
;;;544    static FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table */
000000  b570              PUSH     {r4-r6,lr}
;;;545    	DIR *dj			/* Pointer to directory object */
;;;546    )
;;;547    {
000002  4604              MOV      r4,r0
;;;548    	CLUST clst;
;;;549    	WORD i;
;;;550    	FATFS *fs = FatFs;
000004  4815              LDR      r0,|L5.92|
;;;551    
;;;552    
;;;553    	i = dj->index + 1;
000006  6806              LDR      r6,[r0,#0]  ; FatFs
000008  8820              LDRH     r0,[r4,#0]
00000a  1c40              ADDS     r0,r0,#1
00000c  0405              LSLS     r5,r0,#16
00000e  0c2d              LSRS     r5,r5,#16
000010  d01b              BEQ      |L5.74|
;;;554    	if (!i || !dj->sect) return FR_NO_FILE;	/* Report EOT when index has reached 65535 */
000012  6920              LDR      r0,[r4,#0x10]
000014  2800              CMP      r0,#0
000016  d018              BEQ      |L5.74|
;;;555    
;;;556    	if (!(i % 16)) {		/* Sector changed? */
000018  0729              LSLS     r1,r5,#28
00001a  d11c              BNE      |L5.86|
00001c  1c40              ADDS     r0,r0,#1
;;;557    		dj->sect++;			/* Next sector */
;;;558    
;;;559    		if (dj->clust == 0) {	/* Static table */
00001e  6120              STR      r0,[r4,#0x10]
000020  68e0              LDR      r0,[r4,#0xc]
000022  2800              CMP      r0,#0
000024  d00a              BEQ      |L5.60|
;;;560    			if (i >= fs->n_rootdir) return FR_NO_FILE;	/* Report EOT when end of table */
;;;561    		}
;;;562    		else {					/* Dynamic table */
;;;563    			if (((i / 16) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
000026  78b2              LDRB     r2,[r6,#2]
000028  0929              LSRS     r1,r5,#4
00002a  1e52              SUBS     r2,r2,#1
00002c  4211              TST      r1,r2
00002e  d112              BNE      |L5.86|
;;;564    				clst = get_fat(dj->clust);		/* Get next cluster */
000030  f7fffffe          BL       get_fat
;;;565    				if (clst <= 1) return FR_DISK_ERR;
000034  2801              CMP      r0,#1
000036  d805              BHI      |L5.68|
000038  2001              MOVS     r0,#1
;;;566    				if (clst >= fs->n_fatent) return FR_NO_FILE;	/* Report EOT when it reached end of dynamic table */
;;;567    				dj->clust = clst;				/* Initialize data for new cluster */
;;;568    				dj->sect = clust2sect(clst);
;;;569    			}
;;;570    		}
;;;571    	}
;;;572    
;;;573    	dj->index = i;
;;;574    
;;;575    	return FR_OK;
;;;576    }
00003a  bd70              POP      {r4-r6,pc}
                  |L5.60|
00003c  88b0              LDRH     r0,[r6,#4]            ;560
00003e  42a8              CMP      r0,r5                 ;560
000040  d903              BLS      |L5.74|
000042  e008              B        |L5.86|
                  |L5.68|
000044  68b1              LDR      r1,[r6,#8]            ;566
000046  4281              CMP      r1,r0                 ;566
000048  d801              BHI      |L5.78|
                  |L5.74|
00004a  2003              MOVS     r0,#3                 ;566
00004c  bd70              POP      {r4-r6,pc}
                  |L5.78|
00004e  60e0              STR      r0,[r4,#0xc]          ;568
000050  f7fffffe          BL       clust2sect
000054  6120              STR      r0,[r4,#0x10]         ;568
                  |L5.86|
000056  8025              STRH     r5,[r4,#0]            ;573
000058  2000              MOVS     r0,#0                 ;575
00005a  bd70              POP      {r4-r6,pc}
;;;577    
                          ENDP

                  |L5.92|
                          DCD      ||.data||

                          AREA ||i.dir_rewind||, CODE, READONLY, ALIGN=2

                  dir_rewind PROC
;;;514    
;;;515    static FRESULT dir_rewind (
000000  b510              PUSH     {r4,lr}
;;;516    	DIR *dj			/* Pointer to directory object */
;;;517    )
;;;518    {
000002  4604              MOV      r4,r0
;;;519    	CLUST clst;
;;;520    	FATFS *fs = FatFs;
000004  480a              LDR      r0,|L6.48|
;;;521    
;;;522    
;;;523    	dj->index = 0;
000006  6801              LDR      r1,[r0,#0]  ; FatFs
000008  2000              MOVS     r0,#0
00000a  8020              STRH     r0,[r4,#0]
;;;524    	clst = dj->sclust;
;;;525    	if (clst == 1 || clst >= fs->n_fatent) {	/* Check start cluster range */
00000c  68a0              LDR      r0,[r4,#8]
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L6.24|
000012  688a              LDR      r2,[r1,#8]
000014  4282              CMP      r2,r0
000016  d801              BHI      |L6.28|
                  |L6.24|
;;;526    		return FR_DISK_ERR;
000018  2001              MOVS     r0,#1
;;;527    	}
;;;528    	if (PF_FS_FAT32 && !clst && (_FS_32ONLY || fs->fs_type == FS_FAT32)) {	/* Replace cluster# 0 with root cluster# if in FAT32 */
;;;529    		clst = (CLUST)fs->dirbase;
;;;530    	}
;;;531    	dj->clust = clst;						/* Current cluster */
;;;532    	dj->sect = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase;	/* Current sector */
;;;533    
;;;534    	return FR_OK;	/* Seek succeeded */
;;;535    }
00001a  bd10              POP      {r4,pc}
                  |L6.28|
00001c  2800              CMP      r0,#0                 ;528
00001e  d100              BNE      |L6.34|
000020  6908              LDR      r0,[r1,#0x10]         ;529
                  |L6.34|
000022  60e0              STR      r0,[r4,#0xc]          ;532
000024  f7fffffe          BL       clust2sect
000028  6120              STR      r0,[r4,#0x10]         ;534
00002a  2000              MOVS     r0,#0                 ;534
00002c  bd10              POP      {r4,pc}
;;;536    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      ||.data||

                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;742    
;;;743    static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;744    	DIR *dj,			/* Directory object to return last directory and found object */
;;;745    	BYTE *dir,			/* 32-byte working buffer */
;;;746    	const char *path	/* Full-path string to find a file or directory */
;;;747    )
;;;748    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  9802              LDR      r0,[sp,#8]
000008  e001              B        |L7.14|
                  |L7.10|
00000a  1c40              ADDS     r0,r0,#1
;;;749    	FRESULT res;
;;;750    
;;;751    
;;;752    	while (*path == ' ') path++;		/* Strip leading spaces */
00000c  9002              STR      r0,[sp,#8]
                  |L7.14|
00000e  7801              LDRB     r1,[r0,#0]
000010  2920              CMP      r1,#0x20
000012  d0fa              BEQ      |L7.10|
;;;753    	if (*path == '/') path++;			/* Strip heading separator if exist */
000014  7801              LDRB     r1,[r0,#0]
000016  292f              CMP      r1,#0x2f
000018  d101              BNE      |L7.30|
00001a  1c40              ADDS     r0,r0,#1
00001c  9002              STR      r0,[sp,#8]
                  |L7.30|
;;;754    	dj->sclust = 0;						/* Set start directory (always root dir) */
00001e  2600              MOVS     r6,#0
;;;755    
;;;756    	if ((BYTE)*path < ' ') {			/* Null path means the root directory */
000020  60a6              STR      r6,[r4,#8]
000022  9802              LDR      r0,[sp,#8]
000024  7800              LDRB     r0,[r0,#0]
000026  2820              CMP      r0,#0x20
000028  d204              BCS      |L7.52|
;;;757    		res = dir_rewind(dj);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       dir_rewind
;;;758    		dir[0] = 0;
000030  702e              STRB     r6,[r5,#0]
                  |L7.50|
;;;759    
;;;760    	} else {							/* Follow path */
;;;761    		for (;;) {
;;;762    			res = create_name(dj, &path);	/* Get a segment */
;;;763    			if (res != FR_OK) break;
;;;764    			res = dir_find(dj, dir);		/* Find it */
;;;765    			if (res != FR_OK) break;		/* Could not find the object */
;;;766    			if (dj->fn[11]) break;			/* Last segment match. Function completed. */
;;;767    			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
;;;768    				res = FR_NO_FILE; break;
;;;769    			}
;;;770    			dj->sclust = get_clust(dir);	/* Follow next */
;;;771    		}
;;;772    	}
;;;773    
;;;774    	return res;
;;;775    }
000032  bdfe              POP      {r1-r7,pc}
                  |L7.52|
000034  a902              ADD      r1,sp,#8              ;762
000036  4620              MOV      r0,r4                 ;762
000038  f7fffffe          BL       create_name
00003c  2800              CMP      r0,#0                 ;763
00003e  d1f8              BNE      |L7.50|
000040  4629              MOV      r1,r5                 ;764
000042  4620              MOV      r0,r4                 ;764
000044  f7fffffe          BL       dir_find
000048  2800              CMP      r0,#0                 ;765
00004a  d1f2              BNE      |L7.50|
00004c  6861              LDR      r1,[r4,#4]            ;766
00004e  7ac9              LDRB     r1,[r1,#0xb]          ;766
000050  2900              CMP      r1,#0                 ;766
000052  d1ee              BNE      |L7.50|
000054  7ae8              LDRB     r0,[r5,#0xb]          ;767
000056  06c0              LSLS     r0,r0,#27             ;767
000058  d401              BMI      |L7.94|
00005a  2003              MOVS     r0,#3                 ;768
00005c  bdfe              POP      {r1-r7,pc}
                  |L7.94|
00005e  4628              MOV      r0,r5                 ;770
000060  f7fffffe          BL       get_clust
000064  60a0              STR      r0,[r4,#8]            ;770
000066  e7e5              B        |L7.52|
;;;776    
                          ENDP


                          AREA ||i.get_clust||, CODE, READONLY, ALIGN=1

                  get_clust PROC
;;;492    
;;;493    static CLUST get_clust (
000000  b570              PUSH     {r4-r6,lr}
;;;494    	BYTE* dir		/* Pointer to directory entry */
;;;495    )
;;;496    {
000002  4604              MOV      r4,r0
;;;497    	FATFS *fs = FatFs;
;;;498    	CLUST clst = 0;
;;;499    
;;;500    
;;;501    	if (_FS_32ONLY || (PF_FS_FAT32 && fs->fs_type == FS_FAT32)) {
;;;502    		clst = ld_word(dir+DIR_FstClusHI);
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       ld_word
;;;503    		clst <<= 16;
00000a  0405              LSLS     r5,r0,#16
;;;504    	}
;;;505    	clst |= ld_word(dir+DIR_FstClusLO);
00000c  4620              MOV      r0,r4
00000e  301a              ADDS     r0,r0,#0x1a
000010  f7fffffe          BL       ld_word
000014  4328              ORRS     r0,r0,r5
;;;506    
;;;507    	return clst;
;;;508    }
000016  bd70              POP      {r4-r6,pc}
;;;509    
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=2

                  get_fat PROC
;;;430    
;;;431    static CLUST get_fat (	/* 1:IO error, Else:Cluster status */
000000  b508              PUSH     {r3,lr}
;;;432    	CLUST clst	/* Cluster# to get the link information */
;;;433    )
;;;434    {
;;;435    	BYTE buf[4];
;;;436    	FATFS *fs = FatFs;
000002  490e              LDR      r1,|L9.60|
;;;437    #if PF_FS_FAT12
;;;438    	UINT wc, bc, ofs;
;;;439    #endif
;;;440    
;;;441    	if (clst < 2 || clst >= fs->n_fatent) return 1;	/* Range check */
000004  2802              CMP      r0,#2
000006  6809              LDR      r1,[r1,#0]            ;436  ; FatFs
000008  d310              BCC      |L9.44|
00000a  688a              LDR      r2,[r1,#8]
00000c  4282              CMP      r2,r0
00000e  d90d              BLS      |L9.44|
;;;442    
;;;443    	switch (fs->fs_type) {
000010  780a              LDRB     r2,[r1,#0]
000012  2a03              CMP      r2,#3
000014  d10a              BNE      |L9.44|
;;;444    #if PF_FS_FAT12
;;;445    	case FS_FAT12 : {
;;;446    		bc = (UINT)clst; bc += bc / 2;
;;;447    		ofs = bc % 512; bc /= 512;
;;;448    		if (ofs != 511) {
;;;449    			if (disk_readp(buf, fs->fatbase + bc, ofs, 2)) break;
;;;450    		} else {
;;;451    			if (disk_readp(buf, fs->fatbase + bc, 511, 1)) break;
;;;452    			if (disk_readp(buf+1, fs->fatbase + bc + 1, 0, 1)) break;
;;;453    		}
;;;454    		wc = ld_word(buf);
;;;455    		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
;;;456    	}
;;;457    #endif
;;;458    #if PF_FS_FAT16
;;;459    	case FS_FAT16 :
;;;460    		if (disk_readp(buf, fs->fatbase + clst / 256, ((UINT)clst % 256) * 2, 2)) break;
;;;461    		return ld_word(buf);
;;;462    #endif
;;;463    #if PF_FS_FAT32
;;;464    	case FS_FAT32 :
;;;465    		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4)) break;
000016  68c9              LDR      r1,[r1,#0xc]
000018  09c2              LSRS     r2,r0,#7
00001a  1889              ADDS     r1,r1,r2
00001c  0640              LSLS     r0,r0,#25
00001e  0dc2              LSRS     r2,r0,#23
000020  2304              MOVS     r3,#4
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       disk_readp
000028  2800              CMP      r0,#0
00002a  d001              BEQ      |L9.48|
                  |L9.44|
;;;466    		return ld_dword(buf) & 0x0FFFFFFF;
;;;467    #endif
;;;468    	}
;;;469    
;;;470    	return 1;	/* An error occured at the disk I/O layer */
00002c  2001              MOVS     r0,#1
;;;471    }
00002e  bd08              POP      {r3,pc}
                  |L9.48|
000030  4668              MOV      r0,sp                 ;466
000032  f7fffffe          BL       ld_dword
000036  0100              LSLS     r0,r0,#4              ;466
000038  0900              LSRS     r0,r0,#4              ;466
00003a  bd08              POP      {r3,pc}
;;;472    
                          ENDP

                  |L9.60|
                          DCD      ||.data||

                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;701    #if PF_USE_DIR
;;;702    static void get_fileinfo (		/* No return code */
000000  b570              PUSH     {r4-r6,lr}
;;;703    	DIR *dj,			/* Pointer to the directory object */
;;;704    	BYTE *dir,			/* 32-byte working buffer */
;;;705    	FILINFO *fno	 	/* Pointer to store the file information */
;;;706    )
;;;707    {
;;;708    	BYTE i, c;
;;;709    	char *p;
;;;710    
;;;711    
;;;712    	p = fno->fname;
000002  4614              MOV      r4,r2
;;;713    	if (dj->sect) {
000004  6900              LDR      r0,[r0,#0x10]
000006  3409              ADDS     r4,r4,#9              ;712
000008  4616              MOV      r6,r2                 ;707
00000a  460d              MOV      r5,r1                 ;707
00000c  2800              CMP      r0,#0
00000e  d02d              BEQ      |L10.108|
;;;714    		for (i = 0; i < 8; i++) {	/* Copy file name body */
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;715    			c = dir[i];
000012  5c29              LDRB     r1,[r5,r0]
;;;716    			if (c == ' ') break;
000014  2920              CMP      r1,#0x20
000016  d008              BEQ      |L10.42|
;;;717    			if (c == 0x05) c = 0xE5;
000018  2905              CMP      r1,#5
00001a  d100              BNE      |L10.30|
00001c  21e5              MOVS     r1,#0xe5
                  |L10.30|
;;;718    			*p++ = c;
00001e  7021              STRB     r1,[r4,#0]
000020  1c40              ADDS     r0,r0,#1
000022  b2c0              UXTB     r0,r0                 ;714
000024  1c64              ADDS     r4,r4,#1              ;714
000026  2808              CMP      r0,#8                 ;714
000028  d3f3              BCC      |L10.18|
                  |L10.42|
;;;719    		}
;;;720    		if (dir[8] != ' ') {		/* Copy file name extension */
00002a  7a28              LDRB     r0,[r5,#8]
00002c  2820              CMP      r0,#0x20
00002e  d00c              BEQ      |L10.74|
;;;721    			*p++ = '.';
000030  202e              MOVS     r0,#0x2e
000032  7020              STRB     r0,[r4,#0]
;;;722    			for (i = 8; i < 11; i++) {
000034  2008              MOVS     r0,#8
000036  1c64              ADDS     r4,r4,#1
                  |L10.56|
;;;723    				c = dir[i];
000038  5c29              LDRB     r1,[r5,r0]
;;;724    				if (c == ' ') break;
00003a  2920              CMP      r1,#0x20
00003c  d005              BEQ      |L10.74|
;;;725    				*p++ = c;
00003e  7021              STRB     r1,[r4,#0]
000040  1c40              ADDS     r0,r0,#1
000042  b2c0              UXTB     r0,r0                 ;722
000044  1c64              ADDS     r4,r4,#1              ;722
000046  280b              CMP      r0,#0xb               ;722
000048  d3f6              BCC      |L10.56|
                  |L10.74|
;;;726    			}
;;;727    		}
;;;728    		fno->fattrib = dir[DIR_Attr];				/* Attribute */
00004a  7ae8              LDRB     r0,[r5,#0xb]
00004c  7230              STRB     r0,[r6,#8]
;;;729    		fno->fsize = ld_dword(dir+DIR_FileSize);	/* Size */
00004e  4628              MOV      r0,r5
000050  301c              ADDS     r0,r0,#0x1c
000052  f7fffffe          BL       ld_dword
;;;730    		fno->fdate = ld_word(dir+DIR_WrtDate);		/* Date */
000056  6030              STR      r0,[r6,#0]
000058  4628              MOV      r0,r5
00005a  3018              ADDS     r0,r0,#0x18
00005c  f7fffffe          BL       ld_word
000060  80b0              STRH     r0,[r6,#4]
;;;731    		fno->ftime = ld_word(dir+DIR_WrtTime);		/* Time */
000062  4628              MOV      r0,r5
000064  3016              ADDS     r0,r0,#0x16
000066  f7fffffe          BL       ld_word
00006a  80f0              STRH     r0,[r6,#6]
                  |L10.108|
;;;732    	}
;;;733    	*p = 0;
00006c  2000              MOVS     r0,#0
00006e  7020              STRB     r0,[r4,#0]
;;;734    }
000070  bd70              POP      {r4-r6,pc}
;;;735    #endif /* PF_USE_DIR */
                          ENDP


                          AREA ||i.ld_dword||, CODE, READONLY, ALIGN=1

                  ld_dword PROC
;;;393    
;;;394    static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
000000  78c1              LDRB     r1,[r0,#3]
;;;395    {
;;;396    	DWORD rv;
;;;397    
;;;398    	rv = ptr[3];
;;;399    	rv = rv << 8 | ptr[2];
000002  7882              LDRB     r2,[r0,#2]
000004  0209              LSLS     r1,r1,#8
000006  4311              ORRS     r1,r1,r2
;;;400    	rv = rv << 8 | ptr[1];
000008  7842              LDRB     r2,[r0,#1]
00000a  0209              LSLS     r1,r1,#8
00000c  4311              ORRS     r1,r1,r2
;;;401    	rv = rv << 8 | ptr[0];
00000e  7800              LDRB     r0,[r0,#0]
000010  0209              LSLS     r1,r1,#8
000012  4308              ORRS     r0,r0,r1
;;;402    	return rv;
;;;403    }
000014  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.ld_word||, CODE, READONLY, ALIGN=1

                  ld_word PROC
;;;384    
;;;385    static WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
000000  4601              MOV      r1,r0
;;;386    {
;;;387    	WORD rv;
;;;388    
;;;389    	rv = ptr[1];
000002  7840              LDRB     r0,[r0,#1]
;;;390    	rv = rv << 8 | ptr[0];
000004  7809              LDRB     r1,[r1,#0]
000006  0200              LSLS     r0,r0,#8
000008  4308              ORRS     r0,r0,r1
;;;391    	return rv;
;;;392    }
00000a  4770              BX       lr
;;;393    
                          ENDP


                          AREA ||i.pf_lseek||, CODE, READONLY, ALIGN=2

                  pf_lseek PROC
;;;1055   
;;;1056   FRESULT pf_lseek (
000000  b5f8              PUSH     {r3-r7,lr}
;;;1057   	DWORD ofs		/* File pointer from top of file */
;;;1058   )
;;;1059   {
000002  4605              MOV      r5,r0
;;;1060   	CLUST clst;
;;;1061   	DWORD bcs, sect, ifptr;
;;;1062   	FATFS *fs = FatFs;
000004  4829              LDR      r0,|L13.172|
;;;1063   
;;;1064   
;;;1065   	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
000006  6804              LDR      r4,[r0,#0]  ; FatFs
000008  2c00              CMP      r4,#0
00000a  d025              BEQ      |L13.88|
;;;1066   	if (!(fs->flag & FA_OPENED)) return FR_NOT_OPENED;	/* Check if opened */
00000c  7860              LDRB     r0,[r4,#1]
00000e  07c0              LSLS     r0,r0,#31
000010  d024              BEQ      |L13.92|
;;;1067   
;;;1068   	if (ofs > fs->fsize) ofs = fs->fsize;	/* Clip offset with the file size */
000012  69e0              LDR      r0,[r4,#0x1c]
000014  42a8              CMP      r0,r5
000016  d200              BCS      |L13.26|
000018  4605              MOV      r5,r0
                  |L13.26|
;;;1069   	ifptr = fs->fptr;
00001a  69a0              LDR      r0,[r4,#0x18]
;;;1070   	fs->fptr = 0;
00001c  9000              STR      r0,[sp,#0]
00001e  2000              MOVS     r0,#0
;;;1071   	if (ofs > 0) {
000020  61a0              STR      r0,[r4,#0x18]
000022  2d00              CMP      r5,#0
000024  d03b              BEQ      |L13.158|
;;;1072   		bcs = (DWORD)fs->csize * 512;		/* Cluster size (byte) */
000026  78a0              LDRB     r0,[r4,#2]
000028  0246              LSLS     r6,r0,#9
;;;1073   		if (ifptr > 0 &&
00002a  9800              LDR      r0,[sp,#0]
00002c  2800              CMP      r0,#0
00002e  d017              BEQ      |L13.96|
;;;1074   			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
000030  4631              MOV      r1,r6
000032  1e68              SUBS     r0,r5,#1
000034  f7fffffe          BL       __aeabi_uidivmod
000038  4607              MOV      r7,r0
00003a  9800              LDR      r0,[sp,#0]
00003c  4631              MOV      r1,r6
00003e  1e40              SUBS     r0,r0,#1
000040  f7fffffe          BL       __aeabi_uidivmod
000044  4287              CMP      r7,r0
000046  d30b              BCC      |L13.96|
;;;1075   			fs->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
000048  9800              LDR      r0,[sp,#0]
00004a  1e71              SUBS     r1,r6,#1
00004c  1e40              SUBS     r0,r0,#1
00004e  4388              BICS     r0,r0,r1
;;;1076   			ofs -= fs->fptr;
000050  1a2d              SUBS     r5,r5,r0
;;;1077   			clst = fs->curr_clust;
000052  61a0              STR      r0,[r4,#0x18]
000054  6a60              LDR      r0,[r4,#0x24]
000056  e012              B        |L13.126|
                  |L13.88|
000058  2005              MOVS     r0,#5                 ;1065
;;;1078   		} else {							/* When seek to back cluster, */
;;;1079   			clst = fs->org_clust;			/* start from the first cluster */
;;;1080   			fs->curr_clust = clst;
;;;1081   		}
;;;1082   		while (ofs > bcs) {				/* Cluster following loop */
;;;1083   			clst = get_fat(clst);		/* Follow cluster chain */
;;;1084   			if (clst <= 1 || clst >= fs->n_fatent) ABORT(FR_DISK_ERR);
;;;1085   			fs->curr_clust = clst;
;;;1086   			fs->fptr += bcs;
;;;1087   			ofs -= bcs;
;;;1088   		}
;;;1089   		fs->fptr += ofs;
;;;1090   		sect = clust2sect(clst);		/* Current sector */
;;;1091   		if (!sect) ABORT(FR_DISK_ERR);
;;;1092   		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
;;;1093   	}
;;;1094   
;;;1095   	return FR_OK;
;;;1096   }
00005a  bdf8              POP      {r3-r7,pc}
                  |L13.92|
00005c  2004              MOVS     r0,#4                 ;1066
00005e  bdf8              POP      {r3-r7,pc}
                  |L13.96|
000060  6a20              LDR      r0,[r4,#0x20]         ;1080
000062  6260              STR      r0,[r4,#0x24]         ;1080
000064  e00b              B        |L13.126|
                  |L13.102|
000066  f7fffffe          BL       get_fat
00006a  2801              CMP      r0,#1                 ;1084
00006c  d919              BLS      |L13.162|
00006e  68a1              LDR      r1,[r4,#8]            ;1084
000070  4281              CMP      r1,r0                 ;1084
000072  d916              BLS      |L13.162|
000074  6260              STR      r0,[r4,#0x24]         ;1086
000076  69a1              LDR      r1,[r4,#0x18]         ;1086
000078  1989              ADDS     r1,r1,r6              ;1086
00007a  1bad              SUBS     r5,r5,r6              ;1087
00007c  61a1              STR      r1,[r4,#0x18]         ;1087
                  |L13.126|
00007e  42b5              CMP      r5,r6                 ;1082
000080  d8f1              BHI      |L13.102|
000082  69a1              LDR      r1,[r4,#0x18]         ;1089
000084  1949              ADDS     r1,r1,r5              ;1089
000086  61a1              STR      r1,[r4,#0x18]         ;1090
000088  f7fffffe          BL       clust2sect
00008c  2800              CMP      r0,#0                 ;1091
00008e  d008              BEQ      |L13.162|
000090  69a1              LDR      r1,[r4,#0x18]         ;1092
000092  78a2              LDRB     r2,[r4,#2]            ;1092
000094  0a49              LSRS     r1,r1,#9              ;1092
000096  1e52              SUBS     r2,r2,#1              ;1092
000098  4011              ANDS     r1,r1,r2              ;1092
00009a  1808              ADDS     r0,r1,r0              ;1092
00009c  62a0              STR      r0,[r4,#0x28]         ;1092
                  |L13.158|
00009e  2000              MOVS     r0,#0                 ;1095
0000a0  bdf8              POP      {r3-r7,pc}
                  |L13.162|
0000a2  2000              MOVS     r0,#0                 ;1091
0000a4  7060              STRB     r0,[r4,#1]            ;1091
0000a6  2001              MOVS     r0,#1                 ;1091
0000a8  bdf8              POP      {r3-r7,pc}
;;;1097   #endif
                          ENDP

0000aa  0000              DCW      0x0000
                  |L13.172|
                          DCD      ||.data||

                          AREA ||i.pf_mount||, CODE, READONLY, ALIGN=2

                  pf_mount PROC
;;;818    /*-----------------------------------------------------------------------*/
;;;819    FRESULT pf_mount (
000000  b5f0              PUSH     {r4-r7,lr}
;;;820    	FATFS *fs		/* Pointer to new file system object */
;;;821    )
;;;822    {
000002  4604              MOV      r4,r0
;;;823    	BYTE fmt, buf[36];
;;;824    	DWORD bsect, fsize, tsect, mclst;
;;;825    
;;;826    	FatFs = 0;
000004  493e              LDR      r1,|L14.256|
000006  b089              SUB      sp,sp,#0x24           ;822
000008  2000              MOVS     r0,#0
;;;827    	if (disk_initialize() & STA_NOINIT) {	/* Check if the drive is ready or not */
00000a  6008              STR      r0,[r1,#0]  ; FatFs
00000c  f7fffffe          BL       disk_initialize
000010  07c0              LSLS     r0,r0,#31
000012  d002              BEQ      |L14.26|
;;;828    		return FR_NOT_READY;
000014  2002              MOVS     r0,#2
                  |L14.22|
;;;829    	}
;;;830    	
;;;831    	/* Search FAT partition on the drive */
;;;832    	bsect = 0;
;;;833    	fmt = check_fs(buf, bsect);			/* Check sector 0 as an SFD format */
;;;834    	
;;;835    	if (fmt == 1) {						/* Not an FAT boot record, it may be FDISK format */
;;;836    		/* Check a partition listed in top of the partition table */
;;;837    		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
;;;838    			fmt = 3;
;;;839    		} else {
;;;840    			if (buf[4]) {					/* Is the partition existing? */
;;;841    				bsect = ld_dword(&buf[8]);	/* Partition offset in LBA */
;;;842    				fmt = check_fs(buf, bsect);	/* Check the partition */
;;;843    			}
;;;844    		}
;;;845    	}
;;;846    	if (fmt == 3) return FR_DISK_ERR;
;;;847    	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
;;;848    
;;;849    	/* Initialize the file system object */
;;;850    	if (disk_readp(buf, bsect, 13, sizeof (buf))) return FR_DISK_ERR;
;;;851    
;;;852    	fsize = ld_word(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
;;;853    	if (!fsize) fsize = ld_dword(buf+BPB_FATSz32-13);
;;;854    
;;;855    	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
;;;856    	fs->fatbase = bsect + ld_word(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
;;;857    	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
;;;858    	fs->n_rootdir = ld_word(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
;;;859    	tsect = ld_word(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
;;;860    	if (!tsect) tsect = ld_dword(buf+BPB_TotSec32-13);
;;;861    	mclst = (tsect						/* Last cluster# + 1 */
;;;862    		- ld_word(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
;;;863    		) / fs->csize + 2;
;;;864    	fs->n_fatent = (CLUST)mclst;
;;;865    
;;;866    	fmt = 0;							/* Determine the FAT sub type */
;;;867    	if (PF_FS_FAT12 && mclst < 0xFF7) fmt = FS_FAT12;
;;;868    	if (PF_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7) fmt = FS_FAT16;
;;;869    	if (PF_FS_FAT32 && mclst >= 0xFFF7) fmt = FS_FAT32;
;;;870    	if (!fmt) return FR_NO_FILESYSTEM;
;;;871    	fs->fs_type = fmt;
;;;872    
;;;873    	if (_FS_32ONLY || (PF_FS_FAT32 && fmt == FS_FAT32)) {
;;;874    		fs->dirbase = ld_dword(buf+(BPB_RootClus-13));	/* Root directory start cluster */
;;;875    	} else {
;;;876    		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
;;;877    	}
;;;878    	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
;;;879    
;;;880    	fs->flag = 0;
;;;881    	FatFs = fs;
;;;882    
;;;883    	return FR_OK;
;;;884    }
000016  b009              ADD      sp,sp,#0x24
000018  bdf0              POP      {r4-r7,pc}
                  |L14.26|
00001a  2600              MOVS     r6,#0                 ;832
00001c  4631              MOV      r1,r6                 ;833
00001e  4668              MOV      r0,sp                 ;833
000020  f7fffffe          BL       check_fs
000024  2801              CMP      r0,#1                 ;835
000026  d114              BNE      |L14.82|
000028  22ff              MOVS     r2,#0xff              ;837
00002a  2310              MOVS     r3,#0x10              ;837
00002c  32bf              ADDS     r2,r2,#0xbf           ;837
00002e  4631              MOV      r1,r6                 ;837
000030  4668              MOV      r0,sp                 ;837
000032  f7fffffe          BL       disk_readp
000036  2800              CMP      r0,#0                 ;837
000038  d117              BNE      |L14.106|
00003a  4668              MOV      r0,sp                 ;840
00003c  7900              LDRB     r0,[r0,#4]            ;840
00003e  2800              CMP      r0,#0                 ;840
000040  d05c              BEQ      |L14.252|
000042  a802              ADD      r0,sp,#8              ;840
000044  f7fffffe          BL       ld_dword
000048  4606              MOV      r6,r0                 ;841
00004a  4601              MOV      r1,r0                 ;842
00004c  4668              MOV      r0,sp                 ;842
00004e  f7fffffe          BL       check_fs
                  |L14.82|
000052  2803              CMP      r0,#3                 ;846
000054  d009              BEQ      |L14.106|
000056  2800              CMP      r0,#0                 ;847
000058  d150              BNE      |L14.252|
00005a  2324              MOVS     r3,#0x24              ;850
00005c  220d              MOVS     r2,#0xd               ;850
00005e  4631              MOV      r1,r6                 ;850
000060  4668              MOV      r0,sp                 ;850
000062  f7fffffe          BL       disk_readp
000066  2800              CMP      r0,#0                 ;850
000068  d001              BEQ      |L14.110|
                  |L14.106|
00006a  2001              MOVS     r0,#1                 ;850
00006c  e7d3              B        |L14.22|
                  |L14.110|
00006e  a802              ADD      r0,sp,#8
000070  3001              ADDS     r0,#1
000072  f7fffffe          BL       ld_word
000076  2800              CMP      r0,#0                 ;853
000078  d103              BNE      |L14.130|
00007a  a805              ADD      r0,sp,#0x14           ;853
00007c  3003              ADDS     r0,#3                 ;853
00007e  f7fffffe          BL       ld_dword
                  |L14.130|
000082  4669              MOV      r1,sp                 ;855
000084  78cf              LDRB     r7,[r1,#3]            ;855
000086  460d              MOV      r5,r1                 ;856
000088  4347              MULS     r7,r0,r7              ;855
00008a  1c48              ADDS     r0,r1,#1              ;856
00008c  f7fffffe          BL       ld_word
000090  1980              ADDS     r0,r0,r6              ;856
000092  4669              MOV      r1,sp                 ;857
000094  60e0              STR      r0,[r4,#0xc]          ;857
000096  7808              LDRB     r0,[r1,#0]            ;857
000098  70a0              STRB     r0,[r4,#2]            ;857
00009a  1d28              ADDS     r0,r5,#4              ;858
00009c  f7fffffe          BL       ld_word
0000a0  80a0              STRH     r0,[r4,#4]            ;858
0000a2  1da8              ADDS     r0,r5,#6              ;859
0000a4  f7fffffe          BL       ld_word
0000a8  0006              MOVS     r6,r0                 ;859
0000aa  d104              BNE      |L14.182|
0000ac  a804              ADD      r0,sp,#0x10           ;860
0000ae  3003              ADDS     r0,#3                 ;860
0000b0  f7fffffe          BL       ld_dword
0000b4  4606              MOV      r6,r0                 ;860
                  |L14.182|
0000b6  1c68              ADDS     r0,r5,#1              ;861
0000b8  f7fffffe          BL       ld_word
0000bc  88a1              LDRH     r1,[r4,#4]            ;861
0000be  1a30              SUBS     r0,r6,r0              ;861
0000c0  1bc0              SUBS     r0,r0,r7              ;861
0000c2  0909              LSRS     r1,r1,#4              ;861
0000c4  1a40              SUBS     r0,r0,r1              ;861
0000c6  78a1              LDRB     r1,[r4,#2]            ;861
0000c8  f7fffffe          BL       __aeabi_uidivmod
0000cc  1c80              ADDS     r0,r0,#2              ;861
0000ce  490d              LDR      r1,|L14.260|
0000d0  60a0              STR      r0,[r4,#8]            ;869
0000d2  4288              CMP      r0,r1                 ;869
0000d4  d312              BCC      |L14.252|
0000d6  2003              MOVS     r0,#3                 ;869
0000d8  7020              STRB     r0,[r4,#0]            ;871
0000da  a807              ADD      r0,sp,#0x1c           ;871
0000dc  3003              ADDS     r0,#3                 ;871
0000de  f7fffffe          BL       ld_dword
0000e2  6120              STR      r0,[r4,#0x10]         ;878
0000e4  88a1              LDRH     r1,[r4,#4]            ;878
0000e6  68e0              LDR      r0,[r4,#0xc]          ;878
0000e8  0909              LSRS     r1,r1,#4              ;878
0000ea  19c9              ADDS     r1,r1,r7              ;878
0000ec  1840              ADDS     r0,r0,r1              ;878
0000ee  6160              STR      r0,[r4,#0x14]         ;880
0000f0  2000              MOVS     r0,#0                 ;880
0000f2  7060              STRB     r0,[r4,#1]            ;880
0000f4  4802              LDR      r0,|L14.256|
0000f6  6004              STR      r4,[r0,#0]            ;883  ; FatFs
0000f8  2000              MOVS     r0,#0                 ;883
0000fa  e78c              B        |L14.22|
                  |L14.252|
0000fc  2006              MOVS     r0,#6                 ;870
0000fe  e78a              B        |L14.22|
;;;885    
                          ENDP

                  |L14.256|
                          DCD      ||.data||
                  |L14.260|
                          DCD      0x0000fff7

                          AREA ||i.pf_open||, CODE, READONLY, ALIGN=2

                  pf_open PROC
;;;892    
;;;893    FRESULT pf_open (
000000  b530              PUSH     {r4,r5,lr}
;;;894    	const char *path	/* Pointer to the file name */
;;;895    )
;;;896    {
;;;897    	FRESULT res;
;;;898    	DIR dj;
;;;899    	BYTE sp[12], dir[32];
;;;900    	FATFS *fs = FatFs;
000002  4915              LDR      r1,|L15.88|
000004  b091              SUB      sp,sp,#0x44           ;896
;;;901    
;;;902    
;;;903    	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
000006  680c              LDR      r4,[r1,#0]  ; FatFs
000008  2c00              CMP      r4,#0
00000a  d015              BEQ      |L15.56|
;;;904    
;;;905    	fs->flag = 0;
00000c  2500              MOVS     r5,#0
00000e  7065              STRB     r5,[r4,#1]
;;;906    	dj.fn = sp;
000010  a90d              ADD      r1,sp,#0x34
;;;907    	res = follow_path(&dj, dir, path);	/* Follow the file path */
000012  4602              MOV      r2,r0
000014  9109              STR      r1,[sp,#0x24]
000016  4669              MOV      r1,sp
000018  a808              ADD      r0,sp,#0x20
00001a  f7fffffe          BL       follow_path
;;;908    	if (res != FR_OK) return res;		/* Follow failed */
00001e  2800              CMP      r0,#0
000020  d108              BNE      |L15.52|
;;;909    	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) return FR_NO_FILE;	/* It is a directory */
000022  4668              MOV      r0,sp
000024  7800              LDRB     r0,[r0,#0]
000026  2800              CMP      r0,#0
000028  d003              BEQ      |L15.50|
00002a  4668              MOV      r0,sp
00002c  7ac0              LDRB     r0,[r0,#0xb]
00002e  06c0              LSLS     r0,r0,#27
000030  d504              BPL      |L15.60|
                  |L15.50|
000032  2003              MOVS     r0,#3
                  |L15.52|
;;;910    
;;;911    	fs->org_clust = get_clust(dir);		/* File start cluster */
;;;912    	fs->fsize = ld_dword(dir+DIR_FileSize);	/* File size */
;;;913    	fs->fptr = 0;						/* File pointer */
;;;914    	fs->flag = FA_OPENED;
;;;915    
;;;916    	return FR_OK;
;;;917    }
000034  b011              ADD      sp,sp,#0x44
000036  bd30              POP      {r4,r5,pc}
                  |L15.56|
000038  2005              MOVS     r0,#5                 ;903
00003a  e7fb              B        |L15.52|
                  |L15.60|
00003c  4668              MOV      r0,sp                 ;911
00003e  f7fffffe          BL       get_clust
000042  6220              STR      r0,[r4,#0x20]         ;911
000044  a807              ADD      r0,sp,#0x1c           ;911
000046  f7fffffe          BL       ld_dword
00004a  61a5              STR      r5,[r4,#0x18]         ;914
00004c  61e0              STR      r0,[r4,#0x1c]         ;914
00004e  2001              MOVS     r0,#1                 ;914
000050  7060              STRB     r0,[r4,#1]            ;914
000052  2000              MOVS     r0,#0                 ;916
000054  e7ee              B        |L15.52|
;;;918    
                          ENDP

000056  0000              DCW      0x0000
                  |L15.88|
                          DCD      ||.data||

                          AREA ||i.pf_opendir||, CODE, READONLY, ALIGN=2

                  pf_opendir PROC
;;;1105   
;;;1106   FRESULT pf_opendir (
000000  b510              PUSH     {r4,lr}
;;;1107   	DIR *dj,			/* Pointer to directory object to create */
;;;1108   	const char *path	/* Pointer to the directory path */
;;;1109   )
;;;1110   {
000002  4604              MOV      r4,r0
;;;1111   	FRESULT res;
;;;1112   	BYTE sp[12], dir[32];
;;;1113   	FATFS *fs = FatFs;
000004  4811              LDR      r0,|L16.76|
000006  b08c              SUB      sp,sp,#0x30           ;1110
000008  6800              LDR      r0,[r0,#0]  ; FatFs
;;;1114   
;;;1115   
;;;1116   	if (!fs) {				/* Check file system */
00000a  2800              CMP      r0,#0
00000c  d019              BEQ      |L16.66|
;;;1117   		res = FR_NOT_ENABLED;
;;;1118   	} else {
;;;1119   		dj->fn = sp;
00000e  a808              ADD      r0,sp,#0x20
;;;1120   		res = follow_path(dj, dir, path);		/* Follow the path to the directory */
000010  460a              MOV      r2,r1
000012  6060              STR      r0,[r4,#4]
000014  4669              MOV      r1,sp
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       follow_path
;;;1121   		if (res == FR_OK) {						/* Follow completed */
00001c  2800              CMP      r0,#0
00001e  d10e              BNE      |L16.62|
;;;1122   			if (dir[0]) {						/* It is not the root dir */
000020  4668              MOV      r0,sp
000022  7800              LDRB     r0,[r0,#0]
000024  2800              CMP      r0,#0
000026  d007              BEQ      |L16.56|
;;;1123   				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
000028  4668              MOV      r0,sp
00002a  7ac0              LDRB     r0,[r0,#0xb]
00002c  06c0              LSLS     r0,r0,#27
00002e  d50a              BPL      |L16.70|
;;;1124   					dj->sclust = get_clust(dir);
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       get_clust
000036  60a0              STR      r0,[r4,#8]
                  |L16.56|
;;;1125   				} else {							/* The object is not a directory */
;;;1126   					res = FR_NO_FILE;
;;;1127   				}
;;;1128   			}
;;;1129   			if (res == FR_OK) {
;;;1130   				res = dir_rewind(dj);			/* Rewind dir */
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       dir_rewind
                  |L16.62|
;;;1131   			}
;;;1132   		}
;;;1133   	}
;;;1134   
;;;1135   	return res;
;;;1136   }
00003e  b00c              ADD      sp,sp,#0x30
000040  bd10              POP      {r4,pc}
                  |L16.66|
000042  2005              MOVS     r0,#5                 ;1117
000044  e7fb              B        |L16.62|
                  |L16.70|
000046  2003              MOVS     r0,#3                 ;1126
000048  e7f9              B        |L16.62|
;;;1137   
                          ENDP

00004a  0000              DCW      0x0000
                  |L16.76|
                          DCD      ||.data||

                          AREA ||i.pf_read||, CODE, READONLY, ALIGN=2

                  pf_read PROC
;;;926    
;;;927    FRESULT pf_read (
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;928    	void* buff,		/* Pointer to the read buffer (NULL:Forward data to the stream)*/
;;;929    	UINT btr,		/* Number of bytes to read */
;;;930    	UINT* br		/* Pointer to number of bytes read */
;;;931    )
;;;932    {
000002  b082              SUB      sp,sp,#8
;;;933    	DRESULT dr;
;;;934    	CLUST clst;
;;;935    	DWORD sect, remain;
;;;936    	UINT rcnt;
;;;937    	BYTE cs, *rbuff = buff;
;;;938    	FATFS *fs = FatFs;
000004  9000              STR      r0,[sp,#0]
000006  4830              LDR      r0,|L17.200|
000008  460d              MOV      r5,r1                 ;932
;;;939    
;;;940    	DEBUG_START(DBG_4);
00000a  6804              LDR      r4,[r0,#0]  ; FatFs
00000c  21ff              MOVS     r1,#0xff
00000e  482f              LDR      r0,|L17.204|
000010  3101              ADDS     r1,#1
000012  6041              STR      r1,[r0,#4]
;;;941    
;;;942    	*br = 0;
000014  2700              MOVS     r7,#0
000016  9804              LDR      r0,[sp,#0x10]
;;;943    	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
000018  2c00              CMP      r4,#0
00001a  8007              STRH     r7,[r0,#0]            ;942
00001c  d009              BEQ      |L17.50|
;;;944    	if (!(fs->flag & FA_OPENED)) return FR_NOT_OPENED;	/* Check if opened */
00001e  7860              LDRB     r0,[r4,#1]
000020  07c0              LSLS     r0,r0,#31
000022  d009              BEQ      |L17.56|
;;;945    
;;;946    	remain = fs->fsize - fs->fptr;
000024  69a1              LDR      r1,[r4,#0x18]
000026  69e0              LDR      r0,[r4,#0x1c]
000028  1a40              SUBS     r0,r0,r1
;;;947    	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
00002a  4285              CMP      r5,r0
00002c  d944              BLS      |L17.184|
00002e  b285              UXTH     r5,r0
000030  e042              B        |L17.184|
                  |L17.50|
000032  2005              MOVS     r0,#5                 ;943
                  |L17.52|
;;;948    
;;;949    	while (btr)	{									/* Repeat until all data transferred */
;;;950    		if ((fs->fptr % 512) == 0) {				/* On the sector boundary? */
;;;951    			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1));	/* Sector offset in the cluster */
;;;952    			if (!cs) {								/* On the cluster boundary? */
;;;953    				if (fs->fptr == 0) {				/* On the top of the file? */
;;;954    					clst = fs->org_clust;
;;;955    				} else {
;;;956    					clst = get_fat(fs->curr_clust);
;;;957    				}
;;;958    				if (clst <= 1) ABORT(FR_DISK_ERR);
;;;959    				fs->curr_clust = clst;				/* Update current cluster */
;;;960    			}
;;;961    			sect = clust2sect(fs->curr_clust);		/* Get current sector */
;;;962    			if (!sect) ABORT(FR_DISK_ERR);
;;;963    			fs->dsect = sect + cs;
;;;964    		}
;;;965    		rcnt = 512 - (UINT)fs->fptr % 512;			/* Get partial sector data from sector buffer */
;;;966    		if (rcnt > btr) rcnt = btr;
;;;967    		dr = disk_readp(rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
;;;968    		if (dr) ABORT(FR_DISK_ERR);
;;;969    		fs->fptr += rcnt;							/* Advances file read pointer */
;;;970    		btr -= rcnt; *br += rcnt;					/* Update read counter */
;;;971    		if (rbuff) rbuff += rcnt;					/* Advances the data pointer if destination is memory */
;;;972    	}
;;;973    
;;;974    	DEBUG_STOP(DBG_4);
;;;975    	return FR_OK;
;;;976    }
000034  b005              ADD      sp,sp,#0x14
000036  bdf0              POP      {r4-r7,pc}
                  |L17.56|
000038  2004              MOVS     r0,#4                 ;944
00003a  e7fb              B        |L17.52|
                  |L17.60|
00003c  69a0              LDR      r0,[r4,#0x18]         ;950
00003e  05c1              LSLS     r1,r0,#23             ;950
000040  d116              BNE      |L17.112|
000042  78a2              LDRB     r2,[r4,#2]            ;951
000044  0a41              LSRS     r1,r0,#9              ;951
000046  1e52              SUBS     r2,r2,#1              ;951
000048  4011              ANDS     r1,r1,r2              ;951
00004a  060e              LSLS     r6,r1,#24             ;951
00004c  0e36              LSRS     r6,r6,#24             ;951
00004e  d001              BEQ      |L17.84|
000050  6a60              LDR      r0,[r4,#0x24]         ;959
000052  e007              B        |L17.100|
                  |L17.84|
000054  2800              CMP      r0,#0                 ;953
000056  d01e              BEQ      |L17.150|
000058  6a60              LDR      r0,[r4,#0x24]         ;956
00005a  f7fffffe          BL       get_fat
                  |L17.94|
00005e  2801              CMP      r0,#1                 ;958
000060  d916              BLS      |L17.144|
000062  6260              STR      r0,[r4,#0x24]         ;959
                  |L17.100|
000064  f7fffffe          BL       clust2sect
000068  2800              CMP      r0,#0                 ;962
00006a  d011              BEQ      |L17.144|
00006c  1980              ADDS     r0,r0,r6              ;963
00006e  62a0              STR      r0,[r4,#0x28]         ;963
                  |L17.112|
000070  8b20              LDRH     r0,[r4,#0x18]         ;965
000072  05c2              LSLS     r2,r0,#23             ;965
000074  2001              MOVS     r0,#1                 ;965
000076  0dd2              LSRS     r2,r2,#23             ;965
000078  0240              LSLS     r0,r0,#9              ;965
00007a  1a86              SUBS     r6,r0,r2              ;965
00007c  42ae              CMP      r6,r5                 ;966
00007e  d900              BLS      |L17.130|
000080  462e              MOV      r6,r5                 ;966
                  |L17.130|
000082  4633              MOV      r3,r6                 ;967
000084  6aa1              LDR      r1,[r4,#0x28]         ;967
000086  9800              LDR      r0,[sp,#0]            ;967
000088  f7fffffe          BL       disk_readp
00008c  2800              CMP      r0,#0                 ;968
00008e  d004              BEQ      |L17.154|
                  |L17.144|
000090  7067              STRB     r7,[r4,#1]            ;968
000092  2001              MOVS     r0,#1                 ;968
000094  e7ce              B        |L17.52|
                  |L17.150|
000096  6a20              LDR      r0,[r4,#0x20]         ;954
000098  e7e1              B        |L17.94|
                  |L17.154|
00009a  69a0              LDR      r0,[r4,#0x18]         ;969
00009c  1980              ADDS     r0,r0,r6              ;969
00009e  61a0              STR      r0,[r4,#0x18]         ;970
0000a0  1ba8              SUBS     r0,r5,r6              ;970
0000a2  b285              UXTH     r5,r0                 ;970
0000a4  9804              LDR      r0,[sp,#0x10]         ;970
0000a6  8800              LDRH     r0,[r0,#0]            ;970
0000a8  1981              ADDS     r1,r0,r6              ;970
0000aa  9804              LDR      r0,[sp,#0x10]         ;970
0000ac  8001              STRH     r1,[r0,#0]            ;970
0000ae  9800              LDR      r0,[sp,#0]            ;971
0000b0  2800              CMP      r0,#0                 ;971
0000b2  d001              BEQ      |L17.184|
0000b4  1980              ADDS     r0,r0,r6              ;971
0000b6  9000              STR      r0,[sp,#0]            ;971
                  |L17.184|
0000b8  2d00              CMP      r5,#0                 ;949
0000ba  d1bf              BNE      |L17.60|
0000bc  21ff              MOVS     r1,#0xff              ;974
0000be  4803              LDR      r0,|L17.204|
0000c0  3101              ADDS     r1,#1                 ;974
0000c2  6081              STR      r1,[r0,#8]            ;974
0000c4  2000              MOVS     r0,#0                 ;975
0000c6  e7b5              B        |L17.52|
;;;977    #endif
                          ENDP

                  |L17.200|
                          DCD      ||.data||
                  |L17.204|
                          DCD      0xf80ff040

                          AREA ||i.pf_readdir||, CODE, READONLY, ALIGN=2

                  pf_readdir PROC
;;;1144   
;;;1145   FRESULT pf_readdir (
000000  b570              PUSH     {r4-r6,lr}
;;;1146   	DIR *dj,			/* Pointer to the open directory object */
;;;1147   	FILINFO *fno		/* Pointer to file information to return */
;;;1148   )
;;;1149   {
000002  4604              MOV      r4,r0
;;;1150   	FRESULT res;
;;;1151   	BYTE sp[12], dir[32];
;;;1152   	FATFS *fs = FatFs;
000004  4824              LDR      r0,|L18.152|
000006  b08c              SUB      sp,sp,#0x30           ;1149
000008  6800              LDR      r0,[r0,#0]  ; FatFs
00000a  460d              MOV      r5,r1                 ;1149
;;;1153   
;;;1154   
;;;1155   	if (!fs) {				/* Check file system */
00000c  2800              CMP      r0,#0
00000e  d006              BEQ      |L18.30|
;;;1156   		res = FR_NOT_ENABLED;
;;;1157   	} else {
;;;1158   		dj->fn = sp;
000010  a808              ADD      r0,sp,#0x20
;;;1159   		if (!fno) {
000012  6060              STR      r0,[r4,#4]
000014  2d00              CMP      r5,#0
000016  d005              BEQ      |L18.36|
;;;1160   			res = dir_rewind(dj);
;;;1161   		} else {
;;;1162   			res = dir_read(dj, dir);	/* Get current directory item */
000018  466e              MOV      r6,sp
00001a  2003              MOVS     r0,#3
00001c  e025              B        |L18.106|
                  |L18.30|
00001e  2005              MOVS     r0,#5                 ;1156
                  |L18.32|
;;;1163   			if (res == FR_NO_FILE) res = FR_OK;
;;;1164   			if (res == FR_OK) {				/* A valid entry is found */
;;;1165   				get_fileinfo(dj, dir, fno);	/* Get the object information */
;;;1166   				res = dir_next(dj);			/* Increment read index for next */
;;;1167   				if (res == FR_NO_FILE) res = FR_OK;
;;;1168   			}
;;;1169   		}
;;;1170   	}
;;;1171   
;;;1172   	return res;
;;;1173   }
000020  b00c              ADD      sp,sp,#0x30
000022  bd70              POP      {r4-r6,pc}
                  |L18.36|
000024  4620              MOV      r0,r4                 ;1160
000026  f7fffffe          BL       dir_rewind
00002a  e7f9              B        |L18.32|
                  |L18.44|
00002c  7820              LDRB     r0,[r4,#0]
00002e  2320              MOVS     r3,#0x20
000030  0700              LSLS     r0,r0,#28
000032  0dc2              LSRS     r2,r0,#23
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       disk_readp
00003a  2800              CMP      r0,#0
00003c  d001              BEQ      |L18.66|
00003e  2001              MOVS     r0,#1
000040  e018              B        |L18.116|
                  |L18.66|
000042  7830              LDRB     r0,[r6,#0]
000044  2800              CMP      r0,#0
000046  d00e              BEQ      |L18.102|
000048  7af1              LDRB     r1,[r6,#0xb]
00004a  0689              LSLS     r1,r1,#26
00004c  0e89              LSRS     r1,r1,#26
00004e  28e5              CMP      r0,#0xe5
000050  d003              BEQ      |L18.90|
000052  282e              CMP      r0,#0x2e
000054  d001              BEQ      |L18.90|
000056  0708              LSLS     r0,r1,#28
000058  d512              BPL      |L18.128|
                  |L18.90|
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       dir_next
000060  2800              CMP      r0,#0
000062  d002              BEQ      |L18.106|
000064  e006              B        |L18.116|
                  |L18.102|
000066  2003              MOVS     r0,#3
000068  e004              B        |L18.116|
                  |L18.106|
00006a  6921              LDR      r1,[r4,#0x10]
00006c  2900              CMP      r1,#0
00006e  d1dd              BNE      |L18.44|
000070  2800              CMP      r0,#0
000072  d005              BEQ      |L18.128|
                  |L18.116|
000074  2200              MOVS     r2,#0
000076  6122              STR      r2,[r4,#0x10]         ;1163
000078  2803              CMP      r0,#3                 ;1163
00007a  d001              BEQ      |L18.128|
00007c  2800              CMP      r0,#0                 ;1164
00007e  d1cf              BNE      |L18.32|
                  |L18.128|
000080  462a              MOV      r2,r5                 ;1165
000082  4669              MOV      r1,sp                 ;1165
000084  4620              MOV      r0,r4                 ;1165
000086  f7fffffe          BL       get_fileinfo
00008a  4620              MOV      r0,r4                 ;1166
00008c  f7fffffe          BL       dir_next
000090  2803              CMP      r0,#3                 ;1167
000092  d1c5              BNE      |L18.32|
000094  2000              MOVS     r0,#0                 ;1167
000096  e7c3              B        |L18.32|
;;;1174   
                          ENDP

                  |L18.152|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ||cvt||
000000  809a4541          DCB      0x80,0x9a,0x45,0x41
000004  8e418f80          DCB      0x8e,0x41,0x8f,0x80
000008  45454549          DCB      0x45,0x45,0x45,0x49
00000c  49498e8f          DCB      0x49,0x49,0x8e,0x8f
000010  9092924f          DCB      0x90,0x92,0x92,0x4f
000014  994f5555          DCB      0x99,0x4f,0x55,0x55
000018  59999a9b          DCB      0x59,0x99,0x9a,0x9b
00001c  9c9d9e9f          DCB      0x9c,0x9d,0x9e,0x9f
000020  41494f55          DCB      0x41,0x49,0x4f,0x55
000024  a5a5a6a7          DCB      0xa5,0xa5,0xa6,0xa7
000028  a8a9aaab          DCB      0xa8,0xa9,0xaa,0xab
00002c  acadaeaf          DCB      0xac,0xad,0xae,0xaf
000030  b0b1b2b3          DCB      0xb0,0xb1,0xb2,0xb3
000034  b4b5b6b7          DCB      0xb4,0xb5,0xb6,0xb7
000038  b8b9babb          DCB      0xb8,0xb9,0xba,0xbb
00003c  bcbdbebf          DCB      0xbc,0xbd,0xbe,0xbf
000040  c0c1c2c3          DCB      0xc0,0xc1,0xc2,0xc3
000044  c4c5c6c7          DCB      0xc4,0xc5,0xc6,0xc7
000048  c8c9cacb          DCB      0xc8,0xc9,0xca,0xcb
00004c  cccdcecf          DCB      0xcc,0xcd,0xce,0xcf
000050  d0d1d2d3          DCB      0xd0,0xd1,0xd2,0xd3
000054  d4d5d6d7          DCB      0xd4,0xd5,0xd6,0xd7
000058  d8d9dadb          DCB      0xd8,0xd9,0xda,0xdb
00005c  dcdddedf          DCB      0xdc,0xdd,0xde,0xdf
000060  e0e1e2e3          DCB      0xe0,0xe1,0xe2,0xe3
000064  e4e5e6e7          DCB      0xe4,0xe5,0xe6,0xe7
000068  e8e9eaeb          DCB      0xe8,0xe9,0xea,0xeb
00006c  ecedeeef          DCB      0xec,0xed,0xee,0xef
000070  f0f1f2f3          DCB      0xf0,0xf1,0xf2,0xf3
000074  f4f5f6f7          DCB      0xf4,0xf5,0xf6,0xf7
000078  f8f9fafb          DCB      0xf8,0xf9,0xfa,0xfb
00007c  fcfdfeff          DCB      0xfc,0xfd,0xfe,0xff

                          AREA ||.data||, DATA, ALIGN=2

                  FatFs
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Source\\FS\\pff.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pff_c_pf_mount____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_pff_c_pf_mount____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pff_c_pf_mount____REVSH|
#line 462
|__asm___5_pff_c_pf_mount____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
