; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\i2c.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\i2c.crf Source\I2C.c]
                          THUMB

                          AREA ||i.i2c_busy||, CODE, READONLY, ALIGN=2

                  i2c_busy PROC
;;;31     
;;;32     void i2c_busy(void){
000000  b5f0              PUSH     {r4-r7,lr}
;;;33     	// Start Signal
;;;34     	lock_detect=0;
000002  4e27              LDR      r6,|L1.160|
000004  2500              MOVS     r5,#0
;;;35     	I2C0->C1 &= ~I2C_C1_IICEN_MASK;
000006  4827              LDR      r0,|L1.164|
000008  6035              STR      r5,[r6,#0]  ; lock_detect
00000a  7881              LDRB     r1,[r0,#2]
00000c  0649              LSLS     r1,r1,#25
00000e  0e49              LSRS     r1,r1,#25
000010  7081              STRB     r1,[r0,#2]
;;;36     	I2C_TRAN;
000012  7881              LDRB     r1,[r0,#2]
000014  2310              MOVS     r3,#0x10
000016  4319              ORRS     r1,r1,r3
000018  7081              STRB     r1,[r0,#2]
;;;37     	I2C_M_START;
00001a  7882              LDRB     r2,[r0,#2]
00001c  2120              MOVS     r1,#0x20
00001e  430a              ORRS     r2,r2,r1
000020  7082              STRB     r2,[r0,#2]
;;;38     	I2C0->C1 |=  I2C_C1_IICEN_MASK;
000022  7884              LDRB     r4,[r0,#2]
000024  2280              MOVS     r2,#0x80
000026  4314              ORRS     r4,r4,r2
000028  7084              STRB     r4,[r0,#2]
;;;39     	// Write to clear line
;;;40     	I2C0->C1 |= I2C_C1_MST_MASK; /* set MASTER mode */  
00002a  7884              LDRB     r4,[r0,#2]
00002c  430c              ORRS     r4,r4,r1
00002e  7084              STRB     r4,[r0,#2]
;;;41     	I2C0->C1 |= I2C_C1_TX_MASK; /* Set transmit (TX) mode */  
000030  7884              LDRB     r4,[r0,#2]
000032  431c              ORRS     r4,r4,r3
000034  7084              STRB     r4,[r0,#2]
;;;42     	I2C0->D = 0xFF;
000036  24ff              MOVS     r4,#0xff
000038  7104              STRB     r4,[r0,#4]
                  |L1.58|
;;;43     	while ((I2C0->S & I2C_S_IICIF_MASK) == 0U) {
00003a  78c4              LDRB     r4,[r0,#3]
00003c  07a4              LSLS     r4,r4,#30
00003e  d5fc              BPL      |L1.58|
;;;44     	} /* wait for flag indicating IIC complete  */  
;;;45     	I2C0->S |= I2C_S_IICIF_MASK; /* clear interrupt bit */  
000040  78c7              LDRB     r7,[r0,#3]
000042  2402              MOVS     r4,#2
000044  4327              ORRS     r7,r7,r4
000046  70c7              STRB     r7,[r0,#3]
;;;46     		
;;;47     	/* Clear arbitration error flag*/  
;;;48     	I2C0->S |= I2C_S_ARBL_MASK;
000048  78c7              LDRB     r7,[r0,#3]
00004a  431f              ORRS     r7,r7,r3
00004c  70c7              STRB     r7,[r0,#3]
;;;49     		
;;;50     	/* Send start */  
;;;51     	I2C0->C1 &= ~I2C_C1_IICEN_MASK;
00004e  7887              LDRB     r7,[r0,#2]
000050  067f              LSLS     r7,r7,#25
000052  0e7f              LSRS     r7,r7,#25
000054  7087              STRB     r7,[r0,#2]
;;;52     	I2C0->C1 |= I2C_C1_TX_MASK; /* Set transmit (TX) mode */  
000056  7887              LDRB     r7,[r0,#2]
000058  431f              ORRS     r7,r7,r3
00005a  7087              STRB     r7,[r0,#2]
;;;53     	I2C0->C1 |= I2C_C1_MST_MASK; /* START signal generated */  
00005c  7887              LDRB     r7,[r0,#2]
00005e  430f              ORRS     r7,r7,r1
000060  7087              STRB     r7,[r0,#2]
;;;54     		
;;;55     	I2C0->C1 |= I2C_C1_IICEN_MASK;
000062  7887              LDRB     r7,[r0,#2]
000064  4317              ORRS     r7,r7,r2
000066  7087              STRB     r7,[r0,#2]
;;;56     	/*Wait until start is sent*/  
;;;57     
;;;58     	/* Send stop */  
;;;59     	I2C0->C1 &= ~I2C_C1_IICEN_MASK;
000068  7887              LDRB     r7,[r0,#2]
00006a  067f              LSLS     r7,r7,#25
00006c  0e7f              LSRS     r7,r7,#25
00006e  7087              STRB     r7,[r0,#2]
;;;60     	I2C0->C1 |= I2C_C1_MST_MASK;
000070  7887              LDRB     r7,[r0,#2]
000072  430f              ORRS     r7,r7,r1
000074  7087              STRB     r7,[r0,#2]
;;;61     	I2C0->C1 &= ~I2C_C1_MST_MASK; /* set SLAVE mode */  
000076  7881              LDRB     r1,[r0,#2]
000078  27df              MOVS     r7,#0xdf
00007a  4039              ANDS     r1,r1,r7
00007c  7081              STRB     r1,[r0,#2]
;;;62     	I2C0->C1 &= ~I2C_C1_TX_MASK; /* Set Rx */  
00007e  7881              LDRB     r1,[r0,#2]
000080  27ef              MOVS     r7,#0xef
000082  4039              ANDS     r1,r1,r7
000084  7081              STRB     r1,[r0,#2]
;;;63     	I2C0->C1 |= I2C_C1_IICEN_MASK;
000086  7881              LDRB     r1,[r0,#2]
000088  4311              ORRS     r1,r1,r2
00008a  7081              STRB     r1,[r0,#2]
;;;64     		
;;;65     	
;;;66     	/* wait */  
;;;67     	/* Clear arbitration error & interrupt flag*/  
;;;68     	I2C0->S |= I2C_S_IICIF_MASK;
00008c  78c1              LDRB     r1,[r0,#3]
00008e  4321              ORRS     r1,r1,r4
000090  70c1              STRB     r1,[r0,#3]
;;;69     	I2C0->S |= I2C_S_ARBL_MASK;
000092  78c1              LDRB     r1,[r0,#3]
000094  4319              ORRS     r1,r1,r3
000096  70c1              STRB     r1,[r0,#3]
;;;70     	lock_detect=0;
;;;71     	i2c_lock=1;
000098  2001              MOVS     r0,#1
00009a  6035              STR      r5,[r6,#0]  ; lock_detect
00009c  6070              STR      r0,[r6,#4]  ; i2c_lock
;;;72     }
00009e  bdf0              POP      {r4-r7,pc}
;;;73     
                          ENDP

                  |L1.160|
                          DCD      ||.data||
                  |L1.164|
                          DCD      0x40066000

                          AREA ||i.i2c_init||, CODE, READONLY, ALIGN=2

                  i2c_init PROC
;;;7      //init i2c0
;;;8      void i2c_init(void)
000000  480e              LDR      r0,|L2.60|
;;;9      {
;;;10     	//clock i2c peripheral and port E
;;;11     	SIM->SCGC4 |= SIM_SCGC4_I2C0_MASK;
000002  6b41              LDR      r1,[r0,#0x34]
000004  2240              MOVS     r2,#0x40
000006  4311              ORRS     r1,r1,r2
000008  6341              STR      r1,[r0,#0x34]
;;;12     	SIM->SCGC5 |= (SIM_SCGC5_PORTE_MASK);
00000a  6b81              LDR      r1,[r0,#0x38]
00000c  01d2              LSLS     r2,r2,#7
00000e  4311              ORRS     r1,r1,r2
000010  6381              STR      r1,[r0,#0x38]
;;;13     	
;;;14     	//set pins to I2C function
;;;15     	PORTE->PCR[24] |= PORT_PCR_MUX(5);
000012  480b              LDR      r0,|L2.64|
000014  6a02              LDR      r2,[r0,#0x20]
000016  2105              MOVS     r1,#5
000018  0209              LSLS     r1,r1,#8
00001a  430a              ORRS     r2,r2,r1
00001c  6202              STR      r2,[r0,#0x20]
;;;16     	PORTE->PCR[25] |= PORT_PCR_MUX(5);
00001e  6a42              LDR      r2,[r0,#0x24]
000020  430a              ORRS     r2,r2,r1
000022  6242              STR      r2,[r0,#0x24]
;;;17     		
;;;18     	//set baud rate
;;;19     	//baud = bus freq/(scl_div+mul)
;;;20      	//~400k = 24M/(64); icr=0x12 sets scl_div to 64
;;;21     
;;;22      	I2C0->F = (I2C_F_ICR(0x12) | I2C_F_MULT(0));
000024  4807              LDR      r0,|L2.68|
000026  2112              MOVS     r1,#0x12
000028  7041              STRB     r1,[r0,#1]
;;;23     		
;;;24     	//enable i2c and set to master mode
;;;25     	I2C0->C1 |= (I2C_C1_IICEN_MASK);
00002a  7881              LDRB     r1,[r0,#2]
00002c  2280              MOVS     r2,#0x80
00002e  4311              ORRS     r1,r1,r2
000030  7081              STRB     r1,[r0,#2]
;;;26     	
;;;27     	// Select high drive mode
;;;28     	I2C0->C2 |= (I2C_C2_HDRS_MASK);
000032  7941              LDRB     r1,[r0,#5]
000034  2220              MOVS     r2,#0x20
000036  4311              ORRS     r1,r1,r2
000038  7141              STRB     r1,[r0,#5]
;;;29     }
00003a  4770              BX       lr
;;;30     
                          ENDP

                  |L2.60|
                          DCD      0x40048000
                  |L2.64|
                          DCD      0x4004d040
                  |L2.68|
                          DCD      0x40066000

                          AREA ||i.i2c_read_byte||, CODE, READONLY, ALIGN=2

                  i2c_read_byte PROC
;;;141    // #pragma no_inline 
;;;142    uint8_t i2c_read_byte(uint8_t dev, uint8_t address)
000000  b570              PUSH     {r4-r6,lr}
;;;143    {
;;;144    	uint8_t data;
;;;145    	
;;;146    	I2C_TRAN;							/*set to transmit mode */
000002  4c15              LDR      r4,|L3.88|
000004  4605              MOV      r5,r0                 ;143
000006  78a0              LDRB     r0,[r4,#2]
000008  460e              MOV      r6,r1                 ;143
00000a  2110              MOVS     r1,#0x10
00000c  4308              ORRS     r0,r0,r1
00000e  70a0              STRB     r0,[r4,#2]
;;;147    	I2C_M_START;					/*send start	*/
000010  78a0              LDRB     r0,[r4,#2]
000012  2120              MOVS     r1,#0x20
000014  4308              ORRS     r0,r0,r1
000016  70a0              STRB     r0,[r4,#2]
;;;148    	I2C0->D = dev;			  /*send dev address	*/
000018  7125              STRB     r5,[r4,#4]
;;;149    	I2C_WAIT							/*wait for completion */
00001a  f7fffffe          BL       i2c_wait
;;;150    	
;;;151    	I2C0->D =  address;		/*send read address	*/
00001e  7126              STRB     r6,[r4,#4]
;;;152    	I2C_WAIT							/*wait for completion */
000020  f7fffffe          BL       i2c_wait
;;;153    		
;;;154    	I2C_M_RSTART;				   /*repeated start */
000024  78a0              LDRB     r0,[r4,#2]
000026  2104              MOVS     r1,#4
000028  4308              ORRS     r0,r0,r1
00002a  70a0              STRB     r0,[r4,#2]
;;;155    	I2C0->D = (dev|0x1);	 /*send dev address (read)	*/
00002c  2001              MOVS     r0,#1
00002e  4305              ORRS     r5,r5,r0
000030  7125              STRB     r5,[r4,#4]
;;;156    	I2C_WAIT							 /*wait for completion */
000032  f7fffffe          BL       i2c_wait
;;;157    	
;;;158    	I2C_REC;						   /*set to recieve mode */
000036  78a0              LDRB     r0,[r4,#2]
000038  21ef              MOVS     r1,#0xef
00003a  4008              ANDS     r0,r0,r1
00003c  70a0              STRB     r0,[r4,#2]
;;;159    	NACK;									 /*set NACK after read	*/
00003e  78a0              LDRB     r0,[r4,#2]
000040  2108              MOVS     r1,#8
000042  4308              ORRS     r0,r0,r1
000044  70a0              STRB     r0,[r4,#2]
;;;160    	
;;;161    	data = I2C0->D;					/*dummy read	*/
000046  7920              LDRB     r0,[r4,#4]
;;;162    	I2C_WAIT								/*wait for completion */
000048  f7fffffe          BL       i2c_wait
;;;163    	
;;;164    	I2C_M_STOP;							/*send stop	*/
00004c  78a0              LDRB     r0,[r4,#2]
00004e  21df              MOVS     r1,#0xdf
000050  4008              ANDS     r0,r0,r1
000052  70a0              STRB     r0,[r4,#2]
;;;165    	data = I2C0->D;					/*read data	*/
000054  7920              LDRB     r0,[r4,#4]
;;;166    
;;;167    	return data;
;;;168    }
000056  bd70              POP      {r4-r6,pc}
;;;169    
                          ENDP

                  |L3.88|
                          DCD      0x40066000

                          AREA ||i.i2c_read_setup||, CODE, READONLY, ALIGN=2

                  i2c_read_setup PROC
;;;95     #pragma no_inline 
;;;96     void i2c_read_setup(uint8_t dev, uint8_t address)
000000  b570              PUSH     {r4-r6,lr}
;;;97     {
;;;98     	I2C0->D = dev;			  /*send dev address	*/
000002  4c0b              LDR      r4,|L4.48|
000004  460e              MOV      r6,r1                 ;97
000006  4605              MOV      r5,r0                 ;97
000008  7120              STRB     r0,[r4,#4]
;;;99     	I2C_WAIT							/*wait for completion */
00000a  f7fffffe          BL       i2c_wait
;;;100    	
;;;101    	I2C0->D =  address;		/*send read address	*/
00000e  7126              STRB     r6,[r4,#4]
;;;102    	I2C_WAIT							/*wait for completion */
000010  f7fffffe          BL       i2c_wait
;;;103    		
;;;104    	I2C_M_RSTART;				   /*repeated start */
000014  78a0              LDRB     r0,[r4,#2]
000016  2104              MOVS     r1,#4
000018  4308              ORRS     r0,r0,r1
00001a  70a0              STRB     r0,[r4,#2]
;;;105    	I2C0->D = (dev|0x1);	 /*send dev address (read)	*/
00001c  2001              MOVS     r0,#1
00001e  4305              ORRS     r5,r5,r0
000020  7125              STRB     r5,[r4,#4]
;;;106    	I2C_WAIT							 /*wait for completion */
000022  f7fffffe          BL       i2c_wait
;;;107    	
;;;108    	I2C_REC;						   /*set to receive mode */
000026  78a0              LDRB     r0,[r4,#2]
000028  21ef              MOVS     r1,#0xef
00002a  4008              ANDS     r0,r0,r1
00002c  70a0              STRB     r0,[r4,#2]
;;;109    
;;;110    }
00002e  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP

                  |L4.48|
                          DCD      0x40066000

                          AREA ||i.i2c_repeated_read||, CODE, READONLY, ALIGN=2

                  i2c_repeated_read PROC
;;;113    // #pragma no_inline 
;;;114    uint8_t i2c_repeated_read(uint8_t isLastRead)
000000  b510              PUSH     {r4,lr}
;;;115    {
;;;116    	uint8_t data;
;;;117    	
;;;118    	lock_detect = 0;
000002  2100              MOVS     r1,#0
000004  4a0c              LDR      r2,|L5.56|
;;;119    	
;;;120    	if(isLastRead)	{
;;;121    		NACK;								/*set NACK after read	*/
000006  4c0d              LDR      r4,|L5.60|
000008  6011              STR      r1,[r2,#0]            ;120  ; lock_detect
00000a  2800              CMP      r0,#0                 ;120
;;;122    	} else	{
;;;123    		ACK;								/*ACK after read	*/
00000c  78a0              LDRB     r0,[r4,#2]
00000e  d00a              BEQ      |L5.38|
000010  2108              MOVS     r1,#8                 ;121
000012  4308              ORRS     r0,r0,r1              ;121
000014  70a0              STRB     r0,[r4,#2]            ;121
;;;124    	}
;;;125    	
;;;126    	data = I2C0->D;				/*dummy read	*/
000016  7920              LDRB     r0,[r4,#4]
;;;127    	I2C_WAIT							/*wait for completion */
000018  f7fffffe          BL       i2c_wait
;;;128    	
;;;129    	if(isLastRead)	{
;;;130    		I2C_M_STOP;					/*send stop	*/
00001c  78a0              LDRB     r0,[r4,#2]
00001e  21df              MOVS     r1,#0xdf
000020  4008              ANDS     r0,r0,r1
000022  70a0              STRB     r0,[r4,#2]
000024  e005              B        |L5.50|
                  |L5.38|
000026  21f7              MOVS     r1,#0xf7              ;123
000028  4008              ANDS     r0,r0,r1              ;123
00002a  70a0              STRB     r0,[r4,#2]            ;123
00002c  7920              LDRB     r0,[r4,#4]            ;126
00002e  f7fffffe          BL       i2c_wait
                  |L5.50|
;;;131    	}
;;;132    	data = I2C0->D;				/*read data	*/
000032  7920              LDRB     r0,[r4,#4]
;;;133    
;;;134    	return  data;					
;;;135    }
000034  bd10              POP      {r4,pc}
;;;136    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      ||.data||
                  |L5.60|
                          DCD      0x40066000

                          AREA ||i.i2c_start||, CODE, READONLY, ALIGN=2

                  i2c_start PROC
;;;87     //send start sequence
;;;88     void i2c_start()
000000  4804              LDR      r0,|L6.20|
;;;89     {
;;;90     	I2C_TRAN;							/*set to transmit mode */
000002  7881              LDRB     r1,[r0,#2]
000004  2210              MOVS     r2,#0x10
000006  4311              ORRS     r1,r1,r2
000008  7081              STRB     r1,[r0,#2]
;;;91     	I2C_M_START;					/*send start	*/
00000a  7881              LDRB     r1,[r0,#2]
00000c  2220              MOVS     r2,#0x20
00000e  4311              ORRS     r1,r1,r2
000010  7081              STRB     r1,[r0,#2]
;;;92     }
000012  4770              BX       lr
;;;93     
                          ENDP

                  |L6.20|
                          DCD      0x40066000

                          AREA ||i.i2c_wait||, CODE, READONLY, ALIGN=2

                  i2c_wait PROC
;;;75     #pragma no_inline 
;;;76     void i2c_wait(void) {
000000  b510              PUSH     {r4,lr}
;;;77     	lock_detect = 0;
000002  490a              LDR      r1,|L7.44|
000004  2000              MOVS     r0,#0
;;;78     	while(((I2C0->S & I2C_S_IICIF_MASK)==0) & (lock_detect < 200)) {
000006  4c0a              LDR      r4,|L7.48|
000008  6008              STR      r0,[r1,#0]            ;76  ; lock_detect
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  1c40              ADDS     r0,r0,#1              ;76
                  |L7.14|
00000e  78e2              LDRB     r2,[r4,#3]
000010  0792              LSLS     r2,r2,#30
000012  d401              BMI      |L7.24|
000014  28c8              CMP      r0,#0xc8
000016  dbf9              BLT      |L7.12|
                  |L7.24|
;;;79     		lock_detect++;
;;;80     	} 
;;;81     	if (lock_detect >= 200)
000018  6008              STR      r0,[r1,#0]  ; lock_detect
00001a  28c8              CMP      r0,#0xc8
00001c  db01              BLT      |L7.34|
;;;82     		i2c_busy();
00001e  f7fffffe          BL       i2c_busy
                  |L7.34|
;;;83     	
;;;84       I2C0->S |= I2C_S_IICIF_MASK;
000022  78e0              LDRB     r0,[r4,#3]
000024  2102              MOVS     r1,#2
000026  4308              ORRS     r0,r0,r1
000028  70e0              STRB     r0,[r4,#3]
;;;85     }
00002a  bd10              POP      {r4,pc}
;;;86     
                          ENDP

                  |L7.44|
                          DCD      ||.data||
                  |L7.48|
                          DCD      0x40066000

                          AREA ||i.i2c_write_byte||, CODE, READONLY, ALIGN=2

                  i2c_write_byte PROC
;;;173    #pragma no_inline 
;;;174    void i2c_write_byte(uint8_t dev, uint8_t address, uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
;;;176    	
;;;177    	I2C_TRAN;							/*set to transmit mode */
000002  4c0c              LDR      r4,|L8.52|
000004  460e              MOV      r6,r1                 ;175
000006  78a1              LDRB     r1,[r4,#2]
000008  4615              MOV      r5,r2                 ;175
00000a  2210              MOVS     r2,#0x10
00000c  4311              ORRS     r1,r1,r2
00000e  70a1              STRB     r1,[r4,#2]
;;;178    	I2C_M_START;					/*send start	*/
000010  78a1              LDRB     r1,[r4,#2]
000012  2220              MOVS     r2,#0x20
000014  4311              ORRS     r1,r1,r2
000016  70a1              STRB     r1,[r4,#2]
;;;179    	I2C0->D = dev;			  /*send dev address	*/
000018  7120              STRB     r0,[r4,#4]
;;;180    	I2C_WAIT						  /*wait for ack */
00001a  f7fffffe          BL       i2c_wait
;;;181    	
;;;182    	I2C0->D =  address;		/*send write address	*/
00001e  7126              STRB     r6,[r4,#4]
;;;183    	I2C_WAIT
000020  f7fffffe          BL       i2c_wait
;;;184    		
;;;185    	I2C0->D = data;				/*send data	*/
000024  7125              STRB     r5,[r4,#4]
;;;186    	I2C_WAIT
000026  f7fffffe          BL       i2c_wait
;;;187    	I2C_M_STOP;
00002a  78a0              LDRB     r0,[r4,#2]
00002c  21df              MOVS     r1,#0xdf
00002e  4008              ANDS     r0,r0,r1
000030  70a0              STRB     r0,[r4,#2]
;;;188    	
;;;189    }
000032  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L8.52|
                          DCD      0x40066000

                          AREA ||.data||, DATA, ALIGN=2

                  lock_detect
                          DCD      0x00000000
                  i2c_lock
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Source\\I2C.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_I2C_c_5d19740c____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_I2C_c_5d19740c____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_I2C_c_5d19740c____REVSH|
#line 462
|__asm___5_I2C_c_5d19740c____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
