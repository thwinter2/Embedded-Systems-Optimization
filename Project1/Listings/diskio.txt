; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\diskio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\diskio.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\diskio.crf Source\FS\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;14     
;;;15     DSTATUS disk_initialize(void) {
000000  b510              PUSH     {r4,lr}
;;;16     	DSTATUS stat;
;;;17     
;;;18     	if (SD_Init(&dev) != SD_OK) {
000002  4803              LDR      r0,|L1.16|
000004  f7fffffe          BL       SD_Init
000008  2800              CMP      r0,#0
00000a  d000              BEQ      |L1.14|
;;;19     		stat = RES_ERROR;
00000c  2001              MOVS     r0,#1
                  |L1.14|
;;;20     	} else {
;;;21     		stat = RES_OK;
;;;22     	}
;;;23     
;;;24     	return stat;
;;;25     }
00000e  bd10              POP      {r4,pc}
;;;26     
                          ENDP

                  |L1.16|
                          DCD      ||.bss||

                          AREA ||i.disk_readp||, CODE, READONLY, ALIGN=2

                  disk_readp PROC
;;;32     /*-----------------------------------------------------------------------*/
;;;33     DRESULT disk_readp(BYTE * buff,	/* Pointer to the destination object */
000000  b508              PUSH     {r3,lr}
;;;34     									 DWORD sector,	/* Sector number (LBA) */
;;;35     									 UINT offset,	/* Offset in the sector */
;;;36     									 UINT count		/* Byte count (bit15:destination) */
;;;37     		) {
;;;38     	DRESULT res;
;;;39     	// SD_Read reads entire block, but only stores count bytes starting at offset
;;;40     	if (SD_Read(&dev, buff, sector, offset, count) != SD_OK) {
000002  9300              STR      r3,[sp,#0]
000004  4613              MOV      r3,r2
000006  460a              MOV      r2,r1
000008  4601              MOV      r1,r0
00000a  4803              LDR      r0,|L2.24|
00000c  f7fffffe          BL       SD_Read
000010  2800              CMP      r0,#0
000012  d000              BEQ      |L2.22|
;;;41     		res = RES_ERROR;
000014  2001              MOVS     r0,#1
                  |L2.22|
;;;42     	} else {
;;;43     		res = RES_OK;
;;;44     	}
;;;45     	return res;
;;;46     }
000016  bd08              POP      {r3,pc}
;;;47     
                          ENDP

                  |L2.24|
                          DCD      ||.bss||

                          AREA ||i.disk_writep||, CODE, READONLY, ALIGN=1

                  disk_writep PROC
;;;51     
;;;52     DRESULT disk_writep(const BYTE * buff,	/* Pointer to the data to be written, NULL:Initiate/Finalize write operation */
000000  4770              BX       lr
;;;53     										DWORD sc		/* Sector number (LBA) or Number of bytes to send */
;;;54     		) {
;;;55     	DRESULT res;
;;;56     
;;;57     
;;;58     	// AD
;;;59     	// TODO: Need to port. SD_Write writes an entire sector, needs to be modified to just write specified number of bytes
;;;60     	// Look into PFFS ports to see how this is done
;;;61     	if (!buff) {
;;;62     		if (sc) {
;;;63     
;;;64     			// Initiate write process
;;;65     
;;;66     		} else {
;;;67     
;;;68     			// Finalize write process
;;;69     
;;;70     		}
;;;71     	} else {
;;;72     
;;;73     		// Send data to the disk
;;;74     
;;;75     	}
;;;76     
;;;77     	return res;
;;;78     }
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||dev||
                          %        12
