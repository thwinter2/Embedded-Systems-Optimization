; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\st7789.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\st7789.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\st7789.crf Source\LCD\ST7789.c]
                          THUMB

                          AREA ||i.LCD_24S_Write_Command||, CODE, READONLY, ALIGN=2

                  LCD_24S_Write_Command PROC
;;;167    /* Write one byte as a command to the TFT LCD controller. */
;;;168    static void LCD_24S_Write_Command(uint8_t command) {
000000  2201              MOVS     r2,#1
;;;169    	GPIO_ResetBit(LCD_D_NC_POS);	// Default is sending data, so instead assert command
000002  4906              LDR      r1,|L1.28|
000004  0312              LSLS     r2,r2,#12
000006  608a              STR      r2,[r1,#8]
;;;170    	GPIO_Write(command);
000008  23ff              MOVS     r3,#0xff
00000a  00db              LSLS     r3,r3,#3
00000c  608b              STR      r3,[r1,#8]
00000e  00c0              LSLS     r0,r0,#3
000010  6048              STR      r0,[r1,#4]
;;;171    	GPIO_ResetBit(LCD_NWR_POS);
000012  0050              LSLS     r0,r2,#1
000014  6088              STR      r0,[r1,#8]
;;;172    	GPIO_SetBit(LCD_NWR_POS);
000016  6048              STR      r0,[r1,#4]
;;;173    	GPIO_SetBit(LCD_D_NC_POS);		// Default to sending data, not command
000018  604a              STR      r2,[r1,#4]
;;;174    }
00001a  4770              BX       lr
;;;175    
                          ENDP

                  |L1.28|
                          DCD      0x400ff080

                          AREA ||i.LCD_24S_Write_Data||, CODE, READONLY, ALIGN=2

                  LCD_24S_Write_Data PROC
;;;176    /* Write one byte as data to the TFT LCD Controller. */
;;;177    static void LCD_24S_Write_Data(uint8_t data) {
000000  22ff              MOVS     r2,#0xff
;;;178    //  GPIO_SetBit(LCD_D_NC_POS); // By default data is sent, not command
;;;179    	GPIO_Write(data);
000002  4905              LDR      r1,|L2.24|
000004  00d2              LSLS     r2,r2,#3
000006  608a              STR      r2,[r1,#8]
000008  00c0              LSLS     r0,r0,#3
00000a  6048              STR      r0,[r1,#4]
;;;180    	GPIO_ResetBit(LCD_NWR_POS);
00000c  2001              MOVS     r0,#1
00000e  0340              LSLS     r0,r0,#13
000010  6088              STR      r0,[r1,#8]
;;;181    	GPIO_SetBit(LCD_NWR_POS);
000012  6048              STR      r0,[r1,#4]
;;;182    }
000014  4770              BX       lr
;;;183    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x400ff080

                          AREA ||i.LCD_Controller_Init||, CODE, READONLY, ALIGN=2

                  LCD_Controller_Init PROC
;;;183    
;;;184    void LCD_Controller_Init(const LCD_CTLR_INIT_SEQ_T init_seq[]) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4606              MOV      r6,r0
;;;185    	unsigned i = 0, done = 0;
000004  2500              MOVS     r5,#0
;;;186    
;;;187    	GPIO_SetBit(LCD_NRD_POS);
000006  2001              MOVS     r0,#1
000008  4c13              LDR      r4,|L3.88|
00000a  0400              LSLS     r0,r0,#16
00000c  6060              STR      r0,[r4,#4]
;;;188    	GPIO_ResetBit(LCD_NWR_POS);
00000e  10c0              ASRS     r0,r0,#3
000010  60a0              STR      r0,[r4,#8]
;;;189    	GPIO_ResetBit(LCD_NRST_POS);
000012  0107              LSLS     r7,r0,#4
000014  60a7              STR      r7,[r4,#8]
;;;190    	Delay(100);
000016  2064              MOVS     r0,#0x64
000018  f7fffffe          BL       Delay
;;;191    	GPIO_SetBit(LCD_NRST_POS);
00001c  6067              STR      r7,[r4,#4]
;;;192    	Delay(100);
00001e  2064              MOVS     r0,#0x64
000020  f7fffffe          BL       Delay
;;;193    	GPIO_SetBit(LCD_D_NC_POS);		// AD: by default select data, not command
000024  1178              ASRS     r0,r7,#5
000026  6060              STR      r0,[r4,#4]
                  |L3.40|
;;;194    
;;;195    	while (!done) {
;;;196    		switch (init_seq[i].Type) {
000028  0068              LSLS     r0,r5,#1
00002a  5c31              LDRB     r1,[r6,r0]
00002c  2900              CMP      r1,#0
00002e  d00f              BEQ      |L3.80|
000030  2901              CMP      r1,#1
000032  d002              BEQ      |L3.58|
000034  2902              CMP      r1,#2
000036  d109              BNE      |L3.76|
000038  e004              B        |L3.68|
                  |L3.58|
;;;197    		case LCD_CTRL_INIT_SEQ_CMD:
;;;198    			LCD_24S_Write_Command(init_seq[i].Value);
00003a  1980              ADDS     r0,r0,r6
00003c  7840              LDRB     r0,[r0,#1]
00003e  f7fffffe          BL       LCD_24S_Write_Command
;;;199    			break;
000042  e003              B        |L3.76|
                  |L3.68|
;;;200    		case LCD_CTRL_INIT_SEQ_DAT:
;;;201    			LCD_24S_Write_Data(init_seq[i].Value);
000044  1980              ADDS     r0,r0,r6
000046  7840              LDRB     r0,[r0,#1]
000048  f7fffffe          BL       LCD_24S_Write_Data
                  |L3.76|
00004c  1c6d              ADDS     r5,r5,#1
;;;202    			break;
;;;203    		case LCD_CTRL_INIT_SEQ_END:
;;;204    			done = 1;
;;;205    			break;
;;;206    		default:
;;;207    			break;
;;;208    		}
;;;209    		i++;
00004e  e7eb              B        |L3.40|
                  |L3.80|
;;;210    	}
;;;211    	Delay(10);
000050  200a              MOVS     r0,#0xa
000052  f7fffffe          BL       Delay
;;;212    }
000056  bdf8              POP      {r3-r7,pc}
;;;213    
                          ENDP

                  |L3.88|
                          DCD      0x400ff080

                          AREA ||i.LCD_Fill_Buffer||, CODE, READONLY, ALIGN=1

                  LCD_Fill_Buffer PROC
;;;268    /* Fill the entire display buffer with the given color. */
;;;269    void LCD_Fill_Buffer(COLOR_T * color) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
;;;270    	uint32_t x, y;
;;;271    	uint8_t b1, b2;
;;;272    
;;;273    	// Enable access to full screen, reset write pointer to origin
;;;274    	LCD_24S_Write_Command(0x002A);	//column address set
000004  202a              MOVS     r0,#0x2a
000006  f7fffffe          BL       LCD_24S_Write_Command
;;;275    	LCD_24S_Write_Data(0x0000);
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       LCD_24S_Write_Data
;;;276    	LCD_24S_Write_Data(0x0000);		//start 0x0000
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       LCD_24S_Write_Data
;;;277    	LCD_24S_Write_Data(0x0000);
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       LCD_24S_Write_Data
;;;278    	LCD_24S_Write_Data(0x00EF);		//end 0x00EF
00001c  20ef              MOVS     r0,#0xef
00001e  f7fffffe          BL       LCD_24S_Write_Data
;;;279    	LCD_24S_Write_Command(0x002B);	//page address set
000022  202b              MOVS     r0,#0x2b
000024  f7fffffe          BL       LCD_24S_Write_Command
;;;280    	LCD_24S_Write_Data(0x0000);
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       LCD_24S_Write_Data
;;;281    	LCD_24S_Write_Data(0x0000);		//start 0x0000
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       LCD_24S_Write_Data
;;;282    	LCD_24S_Write_Data(0x0001);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       LCD_24S_Write_Data
;;;283    	LCD_24S_Write_Data(0x003F);		//end 0x013F
00003a  203f              MOVS     r0,#0x3f
00003c  f7fffffe          BL       LCD_24S_Write_Data
;;;284    
;;;285    	// Memory Write 0x2c
;;;286    	// 16 bpp, 5-6-5. Assume color channel data is left-aligned
;;;287    	b1 = (color->R & 0xf8) | ((color->G & 0xe0) >> 5);
000040  7820              LDRB     r0,[r4,#0]
000042  08c1              LSRS     r1,r0,#3
000044  7860              LDRB     r0,[r4,#1]
000046  00c9              LSLS     r1,r1,#3
000048  0942              LSRS     r2,r0,#5
00004a  4311              ORRS     r1,r1,r2
;;;288    	b2 = ((color->G & 0x1c) << 3) | ((color->B & 0xf8) >> 3);
00004c  9100              STR      r1,[sp,#0]
00004e  211c              MOVS     r1,#0x1c
000050  4008              ANDS     r0,r0,r1
000052  00c6              LSLS     r6,r0,#3
000054  78a0              LDRB     r0,[r4,#2]
000056  08c0              LSRS     r0,r0,#3
000058  4306              ORRS     r6,r6,r0
;;;289    
;;;290    	LCD_24S_Write_Command(0x002c);
00005a  202c              MOVS     r0,#0x2c
00005c  f7fffffe          BL       LCD_24S_Write_Command
;;;291    	for (y = 0; y < 320; y++) {
000060  2500              MOVS     r5,#0
000062  27ff              MOVS     r7,#0xff
000064  3741              ADDS     r7,r7,#0x41
                  |L4.102|
;;;292    		for (x = 0; x < 240; x++) {
000066  2400              MOVS     r4,#0
                  |L4.104|
;;;293    			LCD_24S_Write_Data(b1);
000068  9800              LDR      r0,[sp,#0]
00006a  f7fffffe          BL       LCD_24S_Write_Data
;;;294    			LCD_24S_Write_Data(b2);
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       LCD_24S_Write_Data
000074  1c64              ADDS     r4,r4,#1
000076  2cf0              CMP      r4,#0xf0              ;292
000078  d3f6              BCC      |L4.104|
00007a  1c6d              ADDS     r5,r5,#1              ;292
00007c  42bd              CMP      r5,r7                 ;291
00007e  d3f2              BCC      |L4.102|
;;;295    #if ENABLE_PIXEL_HASH
;;;296    			// Update pixel_data_hash
;;;297    			pixel_data_hash ^= b1 ^ b2;
;;;298    			if (pixel_data_hash & 0x01) {
;;;299    				pixel_data_hash >>= 1;
;;;300    				pixel_data_hash |= 0x80000000;
;;;301    			} else {
;;;302    				pixel_data_hash >>= 1;
;;;303    			}
;;;304    #endif
;;;305    		}
;;;306    	}
;;;307    }
000080  bdf8              POP      {r3-r7,pc}
;;;308    
                          ENDP


                          AREA ||i.LCD_Fill_Rectangle||, CODE, READONLY, ALIGN=1

                  LCD_Fill_Rectangle PROC
;;;309    /* Draw a rectangle from p1 to p2 filled with specified color. */
;;;310    void LCD_Fill_Rectangle(PT_T * p1, PT_T * p2, COLOR_T * color) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;311    	uint32_t n;
;;;312    	uint8_t b1, b2;
;;;313    	uint16_t c_min, c_max, r_min, r_max;
;;;314    
;;;315    	c_min = MIN(p1->X, p2->X);
000002  6803              LDR      r3,[r0,#0]
000004  680a              LDR      r2,[r1,#0]
000006  b082              SUB      sp,sp,#8              ;310
000008  4293              CMP      r3,r2
00000a  d201              BCS      |L5.16|
00000c  461c              MOV      r4,r3
00000e  e000              B        |L5.18|
                  |L5.16|
000010  4614              MOV      r4,r2
                  |L5.18|
000012  b2a4              UXTH     r4,r4
;;;316    	c_max = MAX(p1->X, p2->X);
000014  9400              STR      r4,[sp,#0]
000016  4293              CMP      r3,r2
000018  d900              BLS      |L5.28|
00001a  461a              MOV      r2,r3
                  |L5.28|
00001c  b295              UXTH     r5,r2
;;;317    	c_max = MIN(c_max, LCD_WIDTH - 1);
00001e  2def              CMP      r5,#0xef
000020  d300              BCC      |L5.36|
000022  25ef              MOVS     r5,#0xef
                  |L5.36|
;;;318    
;;;319    	r_min = MIN(p1->Y, p2->Y);
000024  6840              LDR      r0,[r0,#4]
000026  6849              LDR      r1,[r1,#4]
000028  4288              CMP      r0,r1
00002a  d201              BCS      |L5.48|
00002c  4602              MOV      r2,r0
00002e  e000              B        |L5.50|
                  |L5.48|
000030  460a              MOV      r2,r1
                  |L5.50|
000032  b296              UXTH     r6,r2
;;;320    	r_max = MAX(p1->Y, p2->Y);
000034  4288              CMP      r0,r1
000036  d800              BHI      |L5.58|
000038  4608              MOV      r0,r1
                  |L5.58|
00003a  b284              UXTH     r4,r0
;;;321    	r_max = MIN(r_max, LCD_HEIGHT - 1);
00003c  20ff              MOVS     r0,#0xff
00003e  3040              ADDS     r0,r0,#0x40
000040  4284              CMP      r4,r0
000042  d300              BCC      |L5.70|
000044  4604              MOV      r4,r0
                  |L5.70|
;;;322    
;;;323    	n = (c_max - c_min + 1) * (r_max - r_min + 1);
000046  9800              LDR      r0,[sp,#0]
000048  1a2f              SUBS     r7,r5,r0
00004a  1ba0              SUBS     r0,r4,r6
00004c  1c40              ADDS     r0,r0,#1
00004e  1c7f              ADDS     r7,r7,#1
000050  4347              MULS     r7,r0,r7
;;;324    	if (n == 0)
000052  d03a              BEQ      |L5.202|
;;;325    		return;
;;;326    
;;;327    	// Enable access to full screen, reset write pointer to origin
;;;328    	LCD_24S_Write_Command(0x002A);	//column address set
000054  202a              MOVS     r0,#0x2a
000056  f7fffffe          BL       LCD_24S_Write_Command
;;;329    	LCD_24S_Write_Data(c_min >> 8);
00005a  9800              LDR      r0,[sp,#0]
00005c  0a00              LSRS     r0,r0,#8
00005e  f7fffffe          BL       LCD_24S_Write_Data
;;;330    	LCD_24S_Write_Data(c_min & 0xff);	//start 
000062  9800              LDR      r0,[sp,#0]
000064  b2c0              UXTB     r0,r0
000066  f7fffffe          BL       LCD_24S_Write_Data
;;;331    	LCD_24S_Write_Data(c_max >> 8);
00006a  0a28              LSRS     r0,r5,#8
00006c  f7fffffe          BL       LCD_24S_Write_Data
;;;332    	LCD_24S_Write_Data(c_max & 0xff);	//end 
000070  b2e8              UXTB     r0,r5
000072  f7fffffe          BL       LCD_24S_Write_Data
;;;333    	LCD_24S_Write_Command(0x002B);	//page address set
000076  202b              MOVS     r0,#0x2b
000078  f7fffffe          BL       LCD_24S_Write_Command
;;;334    	LCD_24S_Write_Data(r_min >> 8);
00007c  0a30              LSRS     r0,r6,#8
00007e  f7fffffe          BL       LCD_24S_Write_Data
;;;335    	LCD_24S_Write_Data(r_min & 0xff);	//start 
000082  b2f0              UXTB     r0,r6
000084  f7fffffe          BL       LCD_24S_Write_Data
;;;336    	LCD_24S_Write_Data(r_max >> 8);
000088  0a20              LSRS     r0,r4,#8
00008a  f7fffffe          BL       LCD_24S_Write_Data
;;;337    	LCD_24S_Write_Data(r_max & 0xff);	//end 
00008e  b2e0              UXTB     r0,r4
000090  f7fffffe          BL       LCD_24S_Write_Data
;;;338    
;;;339    	// Memory Write 0x2c
;;;340    	// 16 bpp, 5-6-5. Assume color channel data is left-aligned
;;;341    	b1 = (color->R & 0xf8) | ((color->G & 0xe0) >> 5);
000094  9804              LDR      r0,[sp,#0x10]
000096  7800              LDRB     r0,[r0,#0]
000098  08c5              LSRS     r5,r0,#3
00009a  9804              LDR      r0,[sp,#0x10]
00009c  00ed              LSLS     r5,r5,#3
00009e  7840              LDRB     r0,[r0,#1]
0000a0  0941              LSRS     r1,r0,#5
0000a2  430d              ORRS     r5,r5,r1
;;;342    	b2 = ((color->G & 0x1c) << 3) | ((color->B & 0xf8) >> 3);
0000a4  211c              MOVS     r1,#0x1c
0000a6  4008              ANDS     r0,r0,r1
0000a8  00c4              LSLS     r4,r0,#3
0000aa  9804              LDR      r0,[sp,#0x10]
0000ac  7880              LDRB     r0,[r0,#2]
0000ae  08c0              LSRS     r0,r0,#3
0000b0  4304              ORRS     r4,r4,r0
;;;343    
;;;344    	LCD_24S_Write_Command(0x002c);
0000b2  202c              MOVS     r0,#0x2c
0000b4  f7fffffe          BL       LCD_24S_Write_Command
;;;345    
;;;346    	while (n-- > 0) {
0000b8  e005              B        |L5.198|
                  |L5.186|
;;;347    		LCD_24S_Write_Data(b1);
0000ba  4628              MOV      r0,r5
0000bc  f7fffffe          BL       LCD_24S_Write_Data
;;;348    		LCD_24S_Write_Data(b2);
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       LCD_24S_Write_Data
                  |L5.198|
0000c6  1e7f              SUBS     r7,r7,#1
0000c8  d2f7              BCS      |L5.186|
                  |L5.202|
;;;349    #if ENABLE_PIXEL_HASH
;;;350    		// Update pixel_data_hash
;;;351    		pixel_data_hash ^= b1 ^ b2;
;;;352    		if (pixel_data_hash & 0x01) {
;;;353    			pixel_data_hash >>= 1;
;;;354    			pixel_data_hash |= 0x80000000;
;;;355    		} else {
;;;356    			pixel_data_hash >>= 1;
;;;357    		}
;;;358    #endif		
;;;359    	}
;;;360    }
0000ca  b005              ADD      sp,sp,#0x14
0000cc  bdf0              POP      {r4-r7,pc}
;;;361    
                          ENDP


                          AREA ||i.LCD_GPIO_Init||, CODE, READONLY, ALIGN=2

                  LCD_GPIO_Init PROC
;;;106    /* Initialize GPIO ports for communicating with TFT LCD controller. */
;;;107    void LCD_GPIO_Init(void) {
000000  b5f0              PUSH     {r4-r7,lr}
;;;108    	unsigned i;
;;;109    
;;;110    	// Enable clock to ports
;;;111    	SIM->SCGC5 |= SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTE_MASK;
000002  482a              LDR      r0,|L6.172|
000004  6b81              LDR      r1,[r0,#0x38]
000006  2205              MOVS     r2,#5
000008  02d2              LSLS     r2,r2,#11
00000a  4311              ORRS     r1,r1,r2
00000c  6381              STR      r1,[r0,#0x38]
;;;112    
;;;113    	// Make digital pins GPIO
;;;114    	// Data bus pins
;;;115    	for (i = LCD_DB8_POS; i <= LCD_DB15_POS; i++) {
;;;116    		PORTC->PCR[i] &= ~PORT_PCR_MUX_MASK;
00000e  4a28              LDR      r2,|L6.176|
000010  2607              MOVS     r6,#7
000012  0236              LSLS     r6,r6,#8
000014  2003              MOVS     r0,#3                 ;115
;;;117    		PORTC->PCR[i] |= PORT_PCR_MUX(1);
000016  1593              ASRS     r3,r2,#22
;;;118    		PTC->PDDR |= MASK(i);
000018  4926              LDR      r1,|L6.180|
00001a  2701              MOVS     r7,#1
                  |L6.28|
00001c  0084              LSLS     r4,r0,#2
00001e  18a4              ADDS     r4,r4,r2              ;116
000020  6825              LDR      r5,[r4,#0]            ;116
000022  43b5              BICS     r5,r5,r6              ;116
000024  6025              STR      r5,[r4,#0]            ;116
000026  6825              LDR      r5,[r4,#0]            ;117
000028  431d              ORRS     r5,r5,r3              ;117
00002a  6025              STR      r5,[r4,#0]            ;117
00002c  694d              LDR      r5,[r1,#0x14]
00002e  463c              MOV      r4,r7
000030  4084              LSLS     r4,r4,r0
000032  4325              ORRS     r5,r5,r4
000034  614d              STR      r5,[r1,#0x14]
000036  1c40              ADDS     r0,r0,#1
000038  280a              CMP      r0,#0xa               ;115
00003a  d9ef              BLS      |L6.28|
;;;119    	}
;;;120    
;;;121    	// Data/Command
;;;122    	PORTC->PCR[LCD_D_NC_POS] &= ~PORT_PCR_MUX_MASK;
00003c  6b10              LDR      r0,[r2,#0x30]
00003e  43b0              BICS     r0,r0,r6
000040  6310              STR      r0,[r2,#0x30]
;;;123    	PORTC->PCR[LCD_D_NC_POS] |= PORT_PCR_MUX(1);
000042  6b10              LDR      r0,[r2,#0x30]
000044  4318              ORRS     r0,r0,r3
000046  6310              STR      r0,[r2,#0x30]
;;;124    	// /Write
;;;125    	PORTC->PCR[LCD_NWR_POS] &= ~PORT_PCR_MUX_MASK;
000048  6b50              LDR      r0,[r2,#0x34]
00004a  43b0              BICS     r0,r0,r6
00004c  6350              STR      r0,[r2,#0x34]
;;;126    	PORTC->PCR[LCD_NWR_POS] |= PORT_PCR_MUX(1);
00004e  6b50              LDR      r0,[r2,#0x34]
000050  4318              ORRS     r0,r0,r3
000052  6350              STR      r0,[r2,#0x34]
;;;127    	// /Read
;;;128    	PORTC->PCR[LCD_NRD_POS] &= ~PORT_PCR_MUX_MASK;
000054  4816              LDR      r0,|L6.176|
000056  3040              ADDS     r0,r0,#0x40
000058  6802              LDR      r2,[r0,#0]
00005a  43b2              BICS     r2,r2,r6
00005c  6002              STR      r2,[r0,#0]
;;;129    	PORTC->PCR[LCD_NRD_POS] |= PORT_PCR_MUX(1);
00005e  6802              LDR      r2,[r0,#0]
000060  431a              ORRS     r2,r2,r3
000062  6002              STR      r2,[r0,#0]
;;;130    	// /Reset
;;;131    	PORTC->PCR[LCD_NRST_POS] &= ~PORT_PCR_MUX_MASK;
000064  6842              LDR      r2,[r0,#4]
000066  43b2              BICS     r2,r2,r6
000068  6042              STR      r2,[r0,#4]
;;;132    	PORTC->PCR[LCD_NRST_POS] |= PORT_PCR_MUX(1);
00006a  6842              LDR      r2,[r0,#4]
00006c  431a              ORRS     r2,r2,r3
00006e  6042              STR      r2,[r0,#4]
;;;133    
;;;134    	// Set port directions to outputs
;;;135    	PTC->PDDR |= MASK(LCD_D_NC_POS);
000070  694a              LDR      r2,[r1,#0x14]
000072  2001              MOVS     r0,#1
000074  0300              LSLS     r0,r0,#12
000076  4302              ORRS     r2,r2,r0
000078  614a              STR      r2,[r1,#0x14]
;;;136    	PTC->PDDR |= MASK(LCD_NWR_POS);
00007a  694b              LDR      r3,[r1,#0x14]
00007c  0042              LSLS     r2,r0,#1
00007e  4313              ORRS     r3,r3,r2
000080  614b              STR      r3,[r1,#0x14]
;;;137    	PTC->PDDR |= MASK(LCD_NRD_POS);
000082  694c              LDR      r4,[r1,#0x14]
000084  0103              LSLS     r3,r0,#4
000086  431c              ORRS     r4,r4,r3
000088  614c              STR      r4,[r1,#0x14]
;;;138    	PTC->PDDR |= MASK(LCD_NRST_POS);
00008a  694d              LDR      r5,[r1,#0x14]
00008c  0144              LSLS     r4,r0,#5
00008e  4325              ORRS     r5,r5,r4
000090  614d              STR      r5,[r1,#0x14]
;;;139    
;;;140    	// Set initial control line values to inactive (1)
;;;141    	PTC->PDOR |= MASK(LCD_D_NC_POS);
000092  680d              LDR      r5,[r1,#0]
000094  4305              ORRS     r5,r5,r0
000096  600d              STR      r5,[r1,#0]
;;;142    	PTC->PDOR |= MASK(LCD_NWR_POS);
000098  6808              LDR      r0,[r1,#0]
00009a  4310              ORRS     r0,r0,r2
00009c  6008              STR      r0,[r1,#0]
;;;143    	PTC->PDOR |= MASK(LCD_NRD_POS);
00009e  6808              LDR      r0,[r1,#0]
0000a0  4318              ORRS     r0,r0,r3
0000a2  6008              STR      r0,[r1,#0]
;;;144    	PTC->PDOR |= MASK(LCD_NRST_POS);
0000a4  6808              LDR      r0,[r1,#0]
0000a6  4320              ORRS     r0,r0,r4
0000a8  6008              STR      r0,[r1,#0]
;;;145    }
0000aa  bdf0              POP      {r4-r7,pc}
;;;146    
                          ENDP

                  |L6.172|
                          DCD      0x40048000
                  |L6.176|
                          DCD      0x4004b000
                  |L6.180|
                          DCD      0x400ff080

                          AREA ||i.LCD_Init||, CODE, READONLY, ALIGN=2

                  LCD_Init PROC
;;;215    components (TFT LCD controller, touch screen and backlight controller). */
;;;216    void LCD_Init(void) {
000000  b510              PUSH     {r4,lr}
;;;217    	LCD_GPIO_Init();
000002  f7fffffe          BL       LCD_GPIO_Init
;;;218    	LCD_TS_Init();
000006  f7fffffe          BL       LCD_TS_Init
00000a  4811              LDR      r0,|L7.80|
00000c  6b81              LDR      r1,[r0,#0x38]
00000e  1542              ASRS     r2,r0,#21
000010  4311              ORRS     r1,r1,r2
000012  6381              STR      r1,[r0,#0x38]
000014  4810              LDR      r0,|L7.88|
000016  490f              LDR      r1,|L7.84|
000018  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001a  f7fffffe          BL       __aeabi_uidivmod
00001e  2103              MOVS     r1,#3
000020  0389              LSLS     r1,r1,#14
000022  4341              MULS     r1,r0,r1
000024  0c0b              LSRS     r3,r1,#16
000026  b282              UXTH     r2,r0
000028  2100              MOVS     r1,#0
00002a  480c              LDR      r0,|L7.92|
00002c  f7fffffe          BL       PWM_Init
000030  480b              LDR      r0,|L7.96|
000032  6b01              LDR      r1,[r0,#0x30]
000034  2207              MOVS     r2,#7
000036  0212              LSLS     r2,r2,#8
000038  4011              ANDS     r1,r1,r2
00003a  6301              STR      r1,[r0,#0x30]
00003c  6b01              LDR      r1,[r0,#0x30]
00003e  2203              MOVS     r2,#3
000040  0212              LSLS     r2,r2,#8
000042  4311              ORRS     r1,r1,r2
000044  6301              STR      r1,[r0,#0x30]
;;;219    	LCD_Init_Backlight();
;;;220    
;;;221    #if LCD_CONTROLLER == CTLR_ILI9341
;;;222    	LCD_Controller_Init(Init_Seq_ILI9341);
;;;223    #else
;;;224    	LCD_Controller_Init(Init_Seq_ST7789);
000046  4807              LDR      r0,|L7.100|
000048  f7fffffe          BL       LCD_Controller_Init
;;;225    #endif
;;;226    
;;;227    }
00004c  bd10              POP      {r4,pc}
;;;228    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      0x40048000
                  |L7.84|
                          DCD      0x00009c40
                  |L7.88|
                          DCD      SystemCoreClock
                  |L7.92|
                          DCD      0x40039000
                  |L7.96|
                          DCD      0x40049000
                  |L7.100|
                          DCD      ||area_number.20||

                          AREA ||i.LCD_Plot_Pixel||, CODE, READONLY, ALIGN=1

                  LCD_Plot_Pixel PROC
;;;229    /* Set the pixel at pos to the given color. */
;;;230    void LCD_Plot_Pixel(PT_T * pos, COLOR_T * color) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;231    	uint8_t b1, b2;
;;;232    
;;;233    	// Column address set 0x2a
;;;234    	LCD_24S_Write_Command(0x002A);	//column address set
000006  202a              MOVS     r0,#0x2a
000008  f7fffffe          BL       LCD_24S_Write_Command
;;;235    	LCD_24S_Write_Data(0);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       LCD_24S_Write_Data
;;;236    	LCD_24S_Write_Data(pos->X & 0xff);	//start 
000012  7828              LDRB     r0,[r5,#0]
000014  f7fffffe          BL       LCD_24S_Write_Data
;;;237    	LCD_24S_Write_Data(0x0000);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       LCD_24S_Write_Data
;;;238    	LCD_24S_Write_Data(0x00EF);		//end 0x00EF
00001e  20ef              MOVS     r0,#0xef
000020  f7fffffe          BL       LCD_24S_Write_Data
;;;239    
;;;240    	// Page (row) address set 0x2b
;;;241    	LCD_24S_Write_Command(0x002B);	//page address set
000024  202b              MOVS     r0,#0x2b
000026  f7fffffe          BL       LCD_24S_Write_Command
;;;242    	LCD_24S_Write_Data(pos->Y >> 8);
00002a  88a8              LDRH     r0,[r5,#4]
00002c  0400              LSLS     r0,r0,#16
00002e  0e00              LSRS     r0,r0,#24
000030  f7fffffe          BL       LCD_24S_Write_Data
;;;243    	LCD_24S_Write_Data(pos->Y & 0xff);	//start 
000034  7928              LDRB     r0,[r5,#4]
000036  f7fffffe          BL       LCD_24S_Write_Data
;;;244    	LCD_24S_Write_Data(0x0001);
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       LCD_24S_Write_Data
;;;245    	LCD_24S_Write_Data(0x003F);		//end 0x013F  
000040  203f              MOVS     r0,#0x3f
000042  f7fffffe          BL       LCD_24S_Write_Data
;;;246    
;;;247    	// Memory Write 0x2c
;;;248    	// 16 bpp, 5-6-5. Assume color channel data is left-aligned
;;;249    	b1 = (color->R & 0xf8) | ((color->G & 0xe0) >> 5);
000046  7820              LDRB     r0,[r4,#0]
000048  08c6              LSRS     r6,r0,#3
00004a  7860              LDRB     r0,[r4,#1]
00004c  00f6              LSLS     r6,r6,#3
00004e  0941              LSRS     r1,r0,#5
000050  430e              ORRS     r6,r6,r1
;;;250    	b2 = ((color->G & 0x1c) << 3) | ((color->B & 0xf8) >> 3);
000052  211c              MOVS     r1,#0x1c
000054  4008              ANDS     r0,r0,r1
000056  00c5              LSLS     r5,r0,#3
000058  78a0              LDRB     r0,[r4,#2]
00005a  08c0              LSRS     r0,r0,#3
00005c  4305              ORRS     r5,r5,r0
;;;251    
;;;252    #if ENABLE_PIXEL_HASH
;;;253    	// Update pixel_data_hash
;;;254    	pixel_data_hash ^= b1 ^ b2;
;;;255    	if (pixel_data_hash & 0x01) {
;;;256    		pixel_data_hash >>= 1;
;;;257    		pixel_data_hash |= 0x80000000;
;;;258    	} else {
;;;259    		pixel_data_hash >>= 1;
;;;260    	}
;;;261    #endif
;;;262    
;;;263    	LCD_24S_Write_Command(0x002c);
00005e  202c              MOVS     r0,#0x2c
000060  f7fffffe          BL       LCD_24S_Write_Command
;;;264    	LCD_24S_Write_Data(b1);
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       LCD_24S_Write_Data
;;;265    	LCD_24S_Write_Data(b2);
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       LCD_24S_Write_Data
;;;266    }
000070  bd70              POP      {r4-r6,pc}
;;;267    
                          ENDP


                          AREA ||i.LCD_Refresh||, CODE, READONLY, ALIGN=1

                  LCD_Refresh PROC
;;;536    
;;;537    void LCD_Refresh(void) {
000000  4770              BX       lr
;;;538    	// Empty, since no local frame buffer used
;;;539    }
;;;540    
                          ENDP


                          AREA ||i.LCD_Set_BL||, CODE, READONLY, ALIGN=1

                  LCD_Set_BL PROC
;;;541    /* Enable (on > 0) or disable LED backlight via LCD controller. */
;;;542    void LCD_Set_BL(uint8_t on) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;543    	LCD_24S_Write_Command(0x53);
000004  2053              MOVS     r0,#0x53
000006  f7fffffe          BL       LCD_24S_Write_Command
;;;544    	LCD_24S_Write_Data(0x28 | (on ? 4 : 0));
00000a  2c00              CMP      r4,#0
00000c  d001              BEQ      |L10.18|
00000e  2004              MOVS     r0,#4
000010  e000              B        |L10.20|
                  |L10.18|
000012  2000              MOVS     r0,#0
                  |L10.20|
000014  3028              ADDS     r0,r0,#0x28
000016  f7fffffe          BL       LCD_24S_Write_Data
;;;545    }
00001a  bd10              POP      {r4,pc}
;;;546    
                          ENDP


                          AREA ||i.LCD_Set_Backlight_Brightness||, CODE, READONLY, ALIGN=2

                  LCD_Set_Backlight_Brightness PROC
;;;159    /* Set backlight brightness for LCD via duty cycle. */
;;;160    void LCD_Set_Backlight_Brightness(uint32_t brightness_percent) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;161    	if (brightness_percent > 100)
000004  2864              CMP      r0,#0x64
000006  d900              BLS      |L11.10|
;;;162    		brightness_percent = 100;
000008  2464              MOVS     r4,#0x64
                  |L11.10|
;;;163    	PWM_Set_Value(LCD_BL_TPM, LCD_BL_TPM_CHANNEL,
00000a  4808              LDR      r0,|L11.44|
00000c  4906              LDR      r1,|L11.40|
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  f7fffffe          BL       __aeabi_uidivmod
000014  4360              MULS     r0,r4,r0
000016  2164              MOVS     r1,#0x64
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  b282              UXTH     r2,r0
00001e  2100              MOVS     r1,#0
000020  4803              LDR      r0,|L11.48|
000022  f7fffffe          BL       PWM_Set_Value
;;;164    								(brightness_percent * LCD_BL_PERIOD) / 100);
;;;165    }
000026  bd10              POP      {r4,pc}
;;;166    
                          ENDP

                  |L11.40|
                          DCD      0x00009c40
                  |L11.44|
                          DCD      SystemCoreClock
                  |L11.48|
                          DCD      0x40039000

                          AREA ||i.LCD_Set_Controller_Brightness||, CODE, READONLY, ALIGN=1

                  LCD_Set_Controller_Brightness PROC
;;;547    /* Set brightness via LCD controller. */
;;;548    void LCD_Set_Controller_Brightness(uint8_t brightness) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;549    	LCD_24S_Write_Command(0x51);
000004  2051              MOVS     r0,#0x51
000006  f7fffffe          BL       LCD_24S_Write_Command
;;;550    	LCD_24S_Write_Data(brightness);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       LCD_24S_Write_Data
;;;551    }
000010  bd10              POP      {r4,pc}
;;;552    
                          ENDP


                          AREA ||i.LCD_Start_Rectangle||, CODE, READONLY, ALIGN=1

                  LCD_Start_Rectangle PROC
;;;365    */
;;;366    uint32_t LCD_Start_Rectangle(PT_T * p1, PT_T * p2) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;367    	uint32_t n;
;;;368    	uint16_t c_min, c_max, r_min, r_max;
;;;369    
;;;370    	// Find bounds of rectangle
;;;371    	c_min = MIN(p1->X, p2->X);
000002  6803              LDR      r3,[r0,#0]
000004  680a              LDR      r2,[r1,#0]
000006  4293              CMP      r3,r2
000008  d201              BCS      |L13.14|
00000a  461c              MOV      r4,r3
00000c  e000              B        |L13.16|
                  |L13.14|
00000e  4614              MOV      r4,r2
                  |L13.16|
000010  b2a6              UXTH     r6,r4
;;;372    	c_max = MAX(p1->X, p2->X);
000012  4293              CMP      r3,r2
000014  d900              BLS      |L13.24|
000016  461a              MOV      r2,r3
                  |L13.24|
;;;373    
;;;374    	r_min = MIN(p1->Y, p2->Y);
000018  6840              LDR      r0,[r0,#4]
00001a  6849              LDR      r1,[r1,#4]
00001c  b294              UXTH     r4,r2                 ;372
00001e  4288              CMP      r0,r1
000020  d201              BCS      |L13.38|
000022  4602              MOV      r2,r0
000024  e000              B        |L13.40|
                  |L13.38|
000026  460a              MOV      r2,r1
                  |L13.40|
000028  b295              UXTH     r5,r2
;;;375    	r_max = MAX(p1->Y, p2->Y);
00002a  4288              CMP      r0,r1
00002c  d800              BHI      |L13.48|
00002e  4608              MOV      r0,r1
                  |L13.48|
000030  b287              UXTH     r7,r0
;;;376    
;;;377    	// Clip to display size
;;;378    	c_max = MIN(c_max, LCD_WIDTH - 1);
000032  2cef              CMP      r4,#0xef
000034  d300              BCC      |L13.56|
000036  24ef              MOVS     r4,#0xef
                  |L13.56|
;;;379    	r_max = MIN(r_max, LCD_HEIGHT - 1);
000038  20ff              MOVS     r0,#0xff
00003a  3040              ADDS     r0,r0,#0x40
00003c  4287              CMP      r7,r0
00003e  d300              BCC      |L13.66|
000040  4607              MOV      r7,r0
                  |L13.66|
;;;380    
;;;381    	n = (c_max - c_min + 1) * (r_max - r_min + 1);
000042  1ba0              SUBS     r0,r4,r6
000044  1b79              SUBS     r1,r7,r5
000046  1c40              ADDS     r0,r0,#1
000048  1c49              ADDS     r1,r1,#1
00004a  4348              MULS     r0,r1,r0
;;;382    	if (n > 0) {
00004c  9000              STR      r0,[sp,#0]
00004e  d021              BEQ      |L13.148|
;;;383    		// Enable access to full screen, reset write pointer to origin
;;;384    		LCD_24S_Write_Command(0x002A);	//column address set
000050  202a              MOVS     r0,#0x2a
000052  f7fffffe          BL       LCD_24S_Write_Command
;;;385    		LCD_24S_Write_Data(c_min >> 8);
000056  0a30              LSRS     r0,r6,#8
000058  f7fffffe          BL       LCD_24S_Write_Data
;;;386    		LCD_24S_Write_Data(c_min & 0xff);	//start 
00005c  b2f0              UXTB     r0,r6
00005e  f7fffffe          BL       LCD_24S_Write_Data
;;;387    		LCD_24S_Write_Data(c_max >> 8);
000062  0a20              LSRS     r0,r4,#8
000064  f7fffffe          BL       LCD_24S_Write_Data
;;;388    		LCD_24S_Write_Data(c_max & 0xff);	//end 
000068  b2e0              UXTB     r0,r4
00006a  f7fffffe          BL       LCD_24S_Write_Data
;;;389    		LCD_24S_Write_Command(0x002B);	//page address set
00006e  202b              MOVS     r0,#0x2b
000070  f7fffffe          BL       LCD_24S_Write_Command
;;;390    		LCD_24S_Write_Data(r_min >> 8);
000074  0a28              LSRS     r0,r5,#8
000076  f7fffffe          BL       LCD_24S_Write_Data
;;;391    		LCD_24S_Write_Data(r_min & 0xff);	//start 
00007a  b2e8              UXTB     r0,r5
00007c  f7fffffe          BL       LCD_24S_Write_Data
;;;392    		LCD_24S_Write_Data(r_max >> 8);
000080  0a38              LSRS     r0,r7,#8
000082  f7fffffe          BL       LCD_24S_Write_Data
;;;393    		LCD_24S_Write_Data(r_max & 0xff);	//end 
000086  b2f8              UXTB     r0,r7
000088  f7fffffe          BL       LCD_24S_Write_Data
;;;394    
;;;395    		// Memory Write 0x2c
;;;396    		LCD_24S_Write_Command(0x002c);
00008c  202c              MOVS     r0,#0x2c
00008e  f7fffffe          BL       LCD_24S_Write_Command
;;;397    	}
;;;398    	return n;
000092  9800              LDR      r0,[sp,#0]
                  |L13.148|
;;;399    }
000094  bdf8              POP      {r3-r7,pc}
;;;400    
                          ENDP


                          AREA ||i.LCD_Write_Rectangle_N_Quad_Pixel_Components||, CODE, READONLY, ALIGN=2

                  LCD_Write_Rectangle_N_Quad_Pixel_Components PROC
;;;484    
;;;485    void LCD_Write_Rectangle_N_Quad_Pixel_Components(uint32_t * aR,
000000  b5ff              PUSH     {r0-r7,lr}
;;;486    																								 uint32_t * aG,
;;;487    																								 uint32_t * aB,
;;;488    																								 int32_t n) {
000002  b081              SUB      sp,sp,#4
000004  4617              MOV      r7,r2
                  |L14.6|
;;;489    	uint8_t b1, b2;
;;;490    #if 1
;;;491    	uint8_t i;
;;;492    #else
;;;493    	uint32_t i;
;;;494    #endif
;;;495    	uint32_t R, G, B, GH, GL, W1, W2;
;;;496    
;;;497    	do {
;;;498    		R = *aR++;
000006  9801              LDR      r0,[sp,#4]
000008  c810              LDM      r0!,{r4}
;;;499    		G = *aG++;
00000a  9001              STR      r0,[sp,#4]
00000c  9802              LDR      r0,[sp,#8]
00000e  c808              LDM      r0!,{r3}
;;;500    		B = *aB++;
000010  9002              STR      r0,[sp,#8]
;;;501    
;;;502    		R &= 0xf8f8f8f8;
000012  4811              LDR      r0,|L14.88|
000014  cf04              LDM      r7!,{r2}              ;500
000016  4004              ANDS     r4,r4,r0
;;;503    		GH = (G & 0xe0e0e0e0) >> 5;
000018  43c0              MVNS     r0,r0
00001a  0959              LSRS     r1,r3,#5
;;;504    		GL = (G & 0x1c1c1c1c) >> 2;
00001c  089d              LSRS     r5,r3,#2
00001e  4001              ANDS     r1,r1,r0              ;503
000020  4005              ANDS     r5,r5,r0
;;;505    		B = (B & 0xf8f8f8f8) >> 3;
000022  08d0              LSRS     r0,r2,#3
000024  4a0d              LDR      r2,|L14.92|
;;;506    
;;;507    		W1 = R | GH;
000026  430c              ORRS     r4,r4,r1
000028  4010              ANDS     r0,r0,r2              ;505
;;;508    		W2 = GL | B;
00002a  4305              ORRS     r5,r5,r0
;;;509    #if DEBUG_LCD_OPS
;;;510    		FPTB->PSOR = MASK(DBG_LCD_WR_PIXELS_POS);
;;;511    #endif
;;;512    		for (i = 0; i < 4; i++) {
00002c  2600              MOVS     r6,#0
                  |L14.46|
;;;513    			b1 = W1 & 0x000000ff;
;;;514    			b2 = W2 & 0x000000ff;
00002e  b2e9              UXTB     r1,r5
000030  b2e0              UXTB     r0,r4                 ;513
;;;515    			LCD_24S_Write_Data(b1);
000032  9100              STR      r1,[sp,#0]
000034  f7fffffe          BL       LCD_24S_Write_Data
;;;516    			LCD_24S_Write_Data(b2);
000038  9800              LDR      r0,[sp,#0]
00003a  f7fffffe          BL       LCD_24S_Write_Data
;;;517    #if ENABLE_PIXEL_HASH
;;;518    		// Update pixel_data_hash
;;;519    		pixel_data_hash ^= b1 ^ b2;
;;;520    		if (pixel_data_hash & 0x01) {
;;;521    			pixel_data_hash >>= 1;
;;;522    			pixel_data_hash |= 0x80000000;
;;;523    		} else {
;;;524    			pixel_data_hash >>= 1;
;;;525    		}
;;;526    #endif
;;;527    			W1 >>= 8;
;;;528    			W2 >>= 8;
00003e  1c76              ADDS     r6,r6,#1
000040  0a24              LSRS     r4,r4,#8              ;527
000042  0a2d              LSRS     r5,r5,#8
000044  b2f6              UXTB     r6,r6                 ;512
000046  2e04              CMP      r6,#4                 ;512
000048  d3f1              BCC      |L14.46|
;;;529    		}
;;;530    #if DEBUG_LCD_OPS
;;;531    		FPTB->PCOR = MASK(DBG_LCD_WR_PIXELS_POS);
;;;532    #endif
;;;533    	} while (--n > 0);
00004a  9804              LDR      r0,[sp,#0x10]
00004c  1e40              SUBS     r0,r0,#1
00004e  9004              STR      r0,[sp,#0x10]
000050  2800              CMP      r0,#0
000052  dcd8              BGT      |L14.6|
;;;534    }
000054  b005              ADD      sp,sp,#0x14
000056  bdf0              POP      {r4-r7,pc}
;;;535    
                          ENDP

                  |L14.88|
                          DCD      0xf8f8f8f8
                  |L14.92|
                          DCD      0x1f1f1f1f

                          AREA ||i.LCD_Write_Rectangle_Pixel||, CODE, READONLY, ALIGN=1

                  LCD_Write_Rectangle_Pixel PROC
;;;402    have called LCD_Write_Rectangle before calling this function. */
;;;403    void LCD_Write_Rectangle_Pixel(COLOR_T * color, unsigned int count) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
;;;404    	uint8_t b1, b2;
;;;405    
;;;406    	// 16 bpp, 5-6-5. Assume color channel data is left-aligned
;;;407    	b1 = (color->R & 0xf8) | ((color->G & 0xe0) >> 5);
000004  7801              LDRB     r1,[r0,#0]
000006  08cd              LSRS     r5,r1,#3
000008  7841              LDRB     r1,[r0,#1]
00000a  00ed              LSLS     r5,r5,#3
00000c  094a              LSRS     r2,r1,#5
00000e  4315              ORRS     r5,r5,r2
;;;408    	b2 = ((color->G & 0x1c) << 3) | ((color->B & 0xf8) >> 3);
000010  221c              MOVS     r2,#0x1c
000012  4011              ANDS     r1,r1,r2
000014  7880              LDRB     r0,[r0,#2]
000016  00ce              LSLS     r6,r1,#3
000018  08c0              LSRS     r0,r0,#3
00001a  4306              ORRS     r6,r6,r0
00001c  e005              B        |L15.42|
                  |L15.30|
;;;409    	while (count--) {
;;;410    		LCD_24S_Write_Data(b1);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       LCD_24S_Write_Data
;;;411    		LCD_24S_Write_Data(b2);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       LCD_24S_Write_Data
                  |L15.42|
00002a  1e64              SUBS     r4,r4,#1
00002c  d2f7              BCS      |L15.30|
;;;412    #if ENABLE_PIXEL_HASH
;;;413    		// Update pixel_data_hash
;;;414    		pixel_data_hash ^= b1 ^ b2;
;;;415    		if (pixel_data_hash & 0x01) {
;;;416    			pixel_data_hash >>= 1;
;;;417    			pixel_data_hash |= 0x80000000;
;;;418    		} else {
;;;419    			pixel_data_hash >>= 1;
;;;420    		}
;;;421    #endif
;;;422    	}
;;;423    }
00002e  bd70              POP      {r4-r6,pc}
;;;424    
                          ENDP


                          AREA ||i.LCD_Write_Rectangle_Quad_Pixel_Components||, CODE, READONLY, ALIGN=1

                  LCD_Write_Rectangle_Quad_Pixel_Components PROC
;;;450    have called LCD_Write_Rectangle before calling this function. */
;;;451    void LCD_Write_Rectangle_Quad_Pixel_Components(uint32_t * aR,
000000  b5f8              PUSH     {r3-r7,lr}
;;;452    																							 uint32_t * aG,
;;;453    																							 uint32_t * aB) {
;;;454    	uint8_t b1, b2, i;
;;;455    	uint32_t R, G, B;
;;;456    
;;;457    	R = *aR;
;;;458    	G = *aG;
000002  6804              LDR      r4,[r0,#0]
;;;459    	B = *aB;
000004  680e              LDR      r6,[r1,#0]
;;;460    
;;;461    	for (i = 0; i < 4; i++) {
000006  6817              LDR      r7,[r2,#0]
000008  2500              MOVS     r5,#0
                  |L16.10|
;;;462    		// 16 bpp, 5-6-5. Assume color channel data is left-aligned
;;;463    		b1 = (R & 0x000000f8) | ((G & 0x000000e0) >> 5);
00000a  4620              MOV      r0,r4
00000c  21f8              MOVS     r1,#0xf8
00000e  4008              ANDS     r0,r0,r1
000010  0631              LSLS     r1,r6,#24
000012  0f49              LSRS     r1,r1,#29
000014  4308              ORRS     r0,r0,r1
;;;464    		b2 = ((G & 0x0000001c) << 3) | ((B & 0x000000f8) >> 3);
000016  211c              MOVS     r1,#0x1c
000018  4031              ANDS     r1,r1,r6
00001a  063a              LSLS     r2,r7,#24
00001c  00c9              LSLS     r1,r1,#3
00001e  0ed2              LSRS     r2,r2,#27
000020  4311              ORRS     r1,r1,r2
;;;465    		LCD_24S_Write_Data(b1);
000022  9100              STR      r1,[sp,#0]
000024  f7fffffe          BL       LCD_24S_Write_Data
;;;466    		LCD_24S_Write_Data(b2);
000028  9800              LDR      r0,[sp,#0]
00002a  f7fffffe          BL       LCD_24S_Write_Data
;;;467    #if ENABLE_PIXEL_HASH
;;;468    		// Update pixel_data_hash
;;;469    		pixel_data_hash ^= b1 ^ b2;
;;;470    		if (pixel_data_hash & 0x01) {
;;;471    			pixel_data_hash >>= 1;
;;;472    			pixel_data_hash |= 0x80000000;
;;;473    		} else {
;;;474    			pixel_data_hash >>= 1;
;;;475    		}
;;;476    #endif
;;;477    		if (i < 3) {
00002e  2d03              CMP      r5,#3
000030  d202              BCS      |L16.56|
;;;478    			R >>= 8;
000032  0a24              LSRS     r4,r4,#8
;;;479    			G >>= 8;
000034  0a36              LSRS     r6,r6,#8
;;;480    			B >>= 8;
000036  0a3f              LSRS     r7,r7,#8
                  |L16.56|
000038  1c6d              ADDS     r5,r5,#1
00003a  b2ed              UXTB     r5,r5                 ;461
00003c  2d04              CMP      r5,#4                 ;461
00003e  d3e4              BCC      |L16.10|
;;;481    		}
;;;482    	}
;;;483    }
000040  bdf8              POP      {r3-r7,pc}
;;;484    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Init_Seq_ILI9341
000000  01280111          DCB      0x01,0x28,0x01,0x11
000004  020001cb          DCB      0x02,0x00,0x01,0xcb
000008  0239022c          DCB      0x02,0x39,0x02,0x2c
00000c  02000234          DCB      0x02,0x00,0x02,0x34
000010  020201cf          DCB      0x02,0x02,0x01,0xcf
000014  02000281          DCB      0x02,0x00,0x02,0x81
000018  023001e8          DCB      0x02,0x30,0x01,0xe8
00001c  02850201          DCB      0x02,0x85,0x02,0x01
000020  027901ea          DCB      0x02,0x79,0x01,0xea
000024  02000200          DCB      0x02,0x00,0x02,0x00
000028  01ed0264          DCB      0x01,0xed,0x02,0x64
00002c  02030212          DCB      0x02,0x03,0x02,0x12
000030  028101f7          DCB      0x02,0x81,0x01,0xf7
000034  022001c0          DCB      0x02,0x20,0x01,0xc0
000038  02260204          DCB      0x02,0x26,0x02,0x04
00003c  01c10211          DCB      0x01,0xc1,0x02,0x11
000040  01c50235          DCB      0x01,0xc5,0x02,0x35
000044  023e01c7          DCB      0x02,0x3e,0x01,0xc7
000048  02be0136          DCB      0x02,0xbe,0x01,0x36
00004c  020801b1          DCB      0x02,0x08,0x01,0xb1
000050  02000210          DCB      0x02,0x00,0x02,0x10
000054  01b6020a          DCB      0x01,0xb6,0x02,0x0a
000058  02a2013a          DCB      0x02,0xa2,0x01,0x3a
00005c  025501f2          DCB      0x02,0x55,0x01,0xf2
000060  02020126          DCB      0x02,0x02,0x01,0x26
000064  0201012a          DCB      0x02,0x01,0x01,0x2a
000068  02000200          DCB      0x02,0x00,0x02,0x00
00006c  020002ef          DCB      0x02,0x00,0x02,0xef
000070  012b0200          DCB      0x01,0x2b,0x02,0x00
000074  02000201          DCB      0x02,0x00,0x02,0x01
000078  023f0129          DCB      0x02,0x3f,0x01,0x29
00007c  0000              DCB      0x00,0x00

                          AREA ||area_number.20||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.20||, ||.constdata||
                  Init_Seq_ST7789
000000  01110136          DCB      0x01,0x11,0x01,0x36
000004  0200013a          DCB      0x02,0x00,0x01,0x3a
000008  025501b2          DCB      0x02,0x55,0x01,0xb2
00000c  020c020c          DCB      0x02,0x0c,0x02,0x0c
000010  02000233          DCB      0x02,0x00,0x02,0x33
000014  023301b7          DCB      0x02,0x33,0x01,0xb7
000018  023501bb          DCB      0x02,0x35,0x01,0xbb
00001c  022b01c0          DCB      0x02,0x2b,0x01,0xc0
000020  022c01c2          DCB      0x02,0x2c,0x01,0xc2
000024  020102ff          DCB      0x02,0x01,0x02,0xff
000028  01c30211          DCB      0x01,0xc3,0x02,0x11
00002c  01c40220          DCB      0x01,0xc4,0x02,0x20
000030  01c6020f          DCB      0x01,0xc6,0x02,0x0f
000034  01d002a4          DCB      0x01,0xd0,0x02,0xa4
000038  02a101e0          DCB      0x02,0xa1,0x01,0xe0
00003c  02d00200          DCB      0x02,0xd0,0x02,0x00
000040  0205020e          DCB      0x02,0x05,0x02,0x0e
000044  0215020d          DCB      0x02,0x15,0x02,0x0d
000048  02370243          DCB      0x02,0x37,0x02,0x43
00004c  02470209          DCB      0x02,0x47,0x02,0x09
000050  02150212          DCB      0x02,0x15,0x02,0x12
000054  02160219          DCB      0x02,0x16,0x02,0x19
000058  01e102d0          DCB      0x01,0xe1,0x02,0xd0
00005c  02000205          DCB      0x02,0x00,0x02,0x05
000060  020d020c          DCB      0x02,0x0d,0x02,0x0c
000064  0206022d          DCB      0x02,0x06,0x02,0x2d
000068  02440240          DCB      0x02,0x44,0x02,0x40
00006c  020e021c          DCB      0x02,0x0e,0x02,0x1c
000070  02180216          DCB      0x02,0x18,0x02,0x16
000074  0219012a          DCB      0x02,0x19,0x01,0x2a
000078  02000200          DCB      0x02,0x00,0x02,0x00
00007c  020002ef          DCB      0x02,0x00,0x02,0xef
000080  012b0200          DCB      0x01,0x2b,0x02,0x00
000084  02000201          DCB      0x02,0x00,0x02,0x01
000088  023f0129          DCB      0x02,0x3f,0x01,0x29
00008c  0000              DCB      0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  pixel_data_hash
                          DCD      0x00000000

                          AREA ||i.LCD_Write_Rectangle_Pixel_Components||, COMGROUP=LCD_Write_Rectangle_Pixel_Components, CODE, READONLY, ALIGN=1

                  LCD_Write_Rectangle_Pixel_Components PROC
;;;426    have called LCD_Write_Rectangle before calling this function. */
;;;427    __forceinline void LCD_Write_Rectangle_Pixel_Components(uint8_t R,
000000  08c0              LSRS     r0,r0,#3
;;;428    																												uint8_t G,
;;;429    																												uint8_t B) {
;;;430    	uint8_t b1, b2;
;;;431    
;;;432    	// 16 bpp, 5-6-5. Assume color channel data is left-aligned
;;;433    	b1 = (R & 0xf8) | ((G & 0xe0) >> 5);
000002  00c0              LSLS     r0,r0,#3
000004  094b              LSRS     r3,r1,#5
000006  4318              ORRS     r0,r0,r3
000008  b510              PUSH     {r4,lr}               ;429
;;;434    	b2 = ((G & 0x1c) << 3) | ((B & 0xf8) >> 3);
00000a  231c              MOVS     r3,#0x1c
00000c  4019              ANDS     r1,r1,r3
00000e  00cc              LSLS     r4,r1,#3
000010  08d1              LSRS     r1,r2,#3
000012  430c              ORRS     r4,r4,r1
;;;435    	LCD_24S_Write_Data(b1);
000014  f7fffffe          BL       LCD_24S_Write_Data
;;;436    	LCD_24S_Write_Data(b2);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       LCD_24S_Write_Data
;;;437    #if ENABLE_PIXEL_HASH
;;;438    		// Update pixel_data_hash
;;;439    		pixel_data_hash ^= b1 ^ b2;
;;;440    		if (pixel_data_hash & 0x01) {
;;;441    			pixel_data_hash >>= 1;
;;;442    			pixel_data_hash |= 0x80000000;
;;;443    		} else {
;;;444    			pixel_data_hash >>= 1;
;;;445    		}
;;;446    #endif
;;;447    }
00001e  bd10              POP      {r4,pc}
;;;448    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Source\\LCD\\ST7789.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_ST7789_c_3d2d791d____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_ST7789_c_3d2d791d____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_ST7789_c_3d2d791d____REVSH|
#line 462
|__asm___8_ST7789_c_3d2d791d____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
