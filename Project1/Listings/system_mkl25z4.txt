; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\system_mkl25z4.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\system_mkl25z4.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\system_mkl25z4.crf --remarks RTE\Device\MKL25Z128xxx4\system_MKL25Z4.c]
                          THUMB

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;276    
;;;277    void SystemCoreClockUpdate (void) {
000000  b510              PUSH     {r4,lr}
;;;278      uint32_t MCGOUTClock;                /* Variable to store output clock frequency of the MCG module */
;;;279      uint16_t Divider;
;;;280    
;;;281      if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x00U) {
000002  4c41              LDR      r4,|L1.264|
000004  7820              LDRB     r0,[r4,#0]
;;;282        /* Output of FLL or PLL is selected */
;;;283        if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U) {
;;;284          /* FLL is selected */
;;;285          if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U) {
;;;286            /* External reference clock is selected */
;;;287            MCGOUTClock = CPU_XTAL_CLK_HZ; /* System oscillator drives MCG clock */
;;;288            if ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x00U) {
;;;289              switch (MCG->C1 & MCG_C1_FRDIV_MASK) {
;;;290              case 0x38U:
;;;291                Divider = 1536U;
;;;292                break;
;;;293              case 0x30U:
;;;294                Divider = 1280U;
;;;295                break;
;;;296              default:
;;;297                Divider = (uint16_t)(32LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
;;;298                break;
;;;299              }
;;;300            } else {/* ((MCG->C2 & MCG_C2_RANGE_MASK) != 0x00U) */
;;;301              Divider = (uint16_t)(1LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
000006  2101              MOVS     r1,#1
000008  0983              LSRS     r3,r0,#6              ;281
00000a  4840              LDR      r0,|L1.268|
;;;302            }
;;;303            MCGOUTClock = (MCGOUTClock / Divider); /* Calculate the divided FLL reference clock */
;;;304          } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
;;;305            MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* The slow internal reference clock is selected */
00000c  03ca              LSLS     r2,r1,#15
00000e  2b00              CMP      r3,#0                 ;281
000010  d010              BEQ      |L1.52|
;;;306          } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
;;;307          /* Select correct multiplier to calculate the MCG output clock  */
;;;308          switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
;;;309            case 0x00U:
;;;310              MCGOUTClock *= 640U;
;;;311              break;
;;;312            case 0x20U:
;;;313              MCGOUTClock *= 1280U;
;;;314              break;
;;;315            case 0x40U:
;;;316              MCGOUTClock *= 1920U;
;;;317              break;
;;;318            case 0x60U:
;;;319              MCGOUTClock *= 2560U;
;;;320              break;
;;;321            case 0x80U:
;;;322              MCGOUTClock *= 732U;
;;;323              break;
;;;324            case 0xA0U:
;;;325              MCGOUTClock *= 1464U;
;;;326              break;
;;;327            case 0xC0U:
;;;328              MCGOUTClock *= 2197U;
;;;329              break;
;;;330            case 0xE0U:
;;;331              MCGOUTClock *= 2929U;
;;;332              break;
;;;333            default:
;;;334              break;
;;;335          }
;;;336        } else { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U)) */
;;;337          /* PLL is selected */
;;;338          Divider = (((uint16_t)MCG->C5 & MCG_C5_PRDIV0_MASK) + 0x01U);
;;;339          MCGOUTClock = (uint32_t)(CPU_XTAL_CLK_HZ / Divider); /* Calculate the PLL reference clock */
;;;340          Divider = (((uint16_t)MCG->C6 & MCG_C6_VDIV0_MASK) + 24U);
;;;341          MCGOUTClock *= Divider;          /* Calculate the MCG output clock */
;;;342        } /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U)) */
;;;343      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40U) {
000012  7823              LDRB     r3,[r4,#0]
000014  099b              LSRS     r3,r3,#6
000016  2b01              CMP      r3,#1
000018  d068              BEQ      |L1.236|
;;;344        /* Internal reference clock is selected */
;;;345        if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U) {
;;;346          MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* Slow internal reference clock selected */
;;;347        } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
;;;348          Divider = (uint16_t)(0x01LU << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));
;;;349          MCGOUTClock = (uint32_t) (CPU_INT_FAST_CLK_HZ / Divider); /* Fast internal reference clock selected */
;;;350        } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
;;;351      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U) {
00001a  7821              LDRB     r1,[r4,#0]
00001c  0989              LSRS     r1,r1,#6
00001e  2902              CMP      r1,#2
000020  d107              BNE      |L1.50|
                  |L1.34|
;;;352        /* External reference clock is selected */
;;;353        MCGOUTClock = CPU_XTAL_CLK_HZ;     /* System oscillator drives MCG clock */
;;;354      } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
;;;355        /* Reserved value */
;;;356        return;
;;;357      } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
;;;358      SystemCoreClock = (MCGOUTClock / (0x01U + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
000022  493b              LDR      r1,|L1.272|
000024  6849              LDR      r1,[r1,#4]
000026  0f09              LSRS     r1,r1,#28
000028  1c49              ADDS     r1,r1,#1
00002a  f7fffffe          BL       __aeabi_uidivmod
00002e  4939              LDR      r1,|L1.276|
;;;359    }
000030  6008              STR      r0,[r1,#0]  ; SystemCoreClock
                  |L1.50|
000032  bd10              POP      {r4,pc}
                  |L1.52|
000034  7963              LDRB     r3,[r4,#5]            ;283
000036  065b              LSLS     r3,r3,#25             ;283
000038  d44d              BMI      |L1.214|
00003a  7823              LDRB     r3,[r4,#0]            ;285
00003c  075b              LSLS     r3,r3,#29             ;285
00003e  d41f              BMI      |L1.128|
000040  7862              LDRB     r2,[r4,#1]            ;288
000042  0692              LSLS     r2,r2,#26             ;288
000044  0f92              LSRS     r2,r2,#30             ;288
000046  d013              BEQ      |L1.112|
000048  7821              LDRB     r1,[r4,#0]            ;289
00004a  2238              MOVS     r2,#0x38              ;289
00004c  4011              ANDS     r1,r1,r2              ;289
00004e  2930              CMP      r1,#0x30              ;289
000050  d00b              BEQ      |L1.106|
000052  2938              CMP      r1,#0x38              ;289
000054  d006              BEQ      |L1.100|
000056  7821              LDRB     r1,[r4,#0]            ;297
000058  2220              MOVS     r2,#0x20              ;297
00005a  0689              LSLS     r1,r1,#26
00005c  0f49              LSRS     r1,r1,#29
00005e  408a              LSLS     r2,r2,r1              ;297
000060  b291              UXTH     r1,r2                 ;297
000062  e00a              B        |L1.122|
                  |L1.100|
000064  2103              MOVS     r1,#3                 ;291
000066  0249              LSLS     r1,r1,#9              ;291
000068  e007              B        |L1.122|
                  |L1.106|
00006a  2105              MOVS     r1,#5                 ;294
00006c  0209              LSLS     r1,r1,#8              ;294
00006e  e004              B        |L1.122|
                  |L1.112|
000070  7822              LDRB     r2,[r4,#0]            ;301
000072  0692              LSLS     r2,r2,#26
000074  0f52              LSRS     r2,r2,#29
000076  4091              LSLS     r1,r1,r2              ;301
000078  b289              UXTH     r1,r1                 ;301
                  |L1.122|
00007a  f7fffffe          BL       __aeabi_uidivmod
00007e  e000              B        |L1.130|
                  |L1.128|
000080  4610              MOV      r0,r2                 ;305
                  |L1.130|
000082  78e1              LDRB     r1,[r4,#3]            ;308
000084  0949              LSRS     r1,r1,#5              ;308
000086  0149              LSLS     r1,r1,#5              ;308
000088  06ca              LSLS     r2,r1,#27             ;308
00008a  0ed2              LSRS     r2,r2,#27             ;308
00008c  d1c9              BNE      |L1.34|
00008e  1149              ASRS     r1,r1,#5              ;308
000090  2908              CMP      r1,#8                 ;308
000092  d2c6              BCS      |L1.34|
000094  000a              MOVS     r2,r1                 ;308
000096  447a              ADD      r2,r2,pc              ;308
000098  7912              LDRB     r2,[r2,#4]            ;308
00009a  1892              ADDS     r2,r2,r2              ;308
00009c  4497              ADD      pc,pc,r2              ;308
00009e  0306              DCB      0x03,0x06
0000a0  090c0f12          DCB      0x09,0x0c,0x0f,0x12
0000a4  1518              DCB      0x15,0x18
0000a6  2105              MOVS     r1,#5                 ;310
0000a8  01c9              LSLS     r1,r1,#7              ;310
0000aa  e00f              B        |L1.204|
0000ac  2105              MOVS     r1,#5                 ;313
0000ae  0209              LSLS     r1,r1,#8              ;313
0000b0  e00c              B        |L1.204|
0000b2  210f              MOVS     r1,#0xf               ;316
0000b4  01c9              LSLS     r1,r1,#7              ;316
0000b6  e009              B        |L1.204|
0000b8  2105              MOVS     r1,#5                 ;319
0000ba  0249              LSLS     r1,r1,#9              ;319
0000bc  e006              B        |L1.204|
0000be  21b7              MOVS     r1,#0xb7              ;322
0000c0  0089              LSLS     r1,r1,#2              ;322
0000c2  e003              B        |L1.204|
0000c4  21b7              MOVS     r1,#0xb7              ;325
0000c6  00c9              LSLS     r1,r1,#3              ;325
0000c8  e000              B        |L1.204|
0000ca  4913              LDR      r1,|L1.280|
                  |L1.204|
0000cc  4348              MULS     r0,r1,r0              ;325
0000ce  e7a8              B        |L1.34|
0000d0  4912              LDR      r1,|L1.284|
0000d2  4348              MULS     r0,r1,r0              ;331
0000d4  e7a5              B        |L1.34|
                  |L1.214|
0000d6  7921              LDRB     r1,[r4,#4]            ;338
0000d8  06c9              LSLS     r1,r1,#27             ;338
0000da  0ec9              LSRS     r1,r1,#27             ;338
0000dc  1c49              ADDS     r1,r1,#1              ;338
0000de  f7fffffe          BL       __aeabi_uidivmod
0000e2  7961              LDRB     r1,[r4,#5]            ;340
0000e4  06c9              LSLS     r1,r1,#27             ;340
0000e6  0ec9              LSRS     r1,r1,#27             ;340
0000e8  3118              ADDS     r1,r1,#0x18           ;340
0000ea  e7ef              B        |L1.204|
                  |L1.236|
0000ec  7860              LDRB     r0,[r4,#1]            ;345
0000ee  07c0              LSLS     r0,r0,#31             ;345
0000f0  d008              BEQ      |L1.260|
0000f2  7a20              LDRB     r0,[r4,#8]            ;348
0000f4  0700              LSLS     r0,r0,#28
0000f6  0f40              LSRS     r0,r0,#29
0000f8  4081              LSLS     r1,r1,r0              ;348
0000fa  b289              UXTH     r1,r1                 ;348
0000fc  4808              LDR      r0,|L1.288|
0000fe  f7fffffe          BL       __aeabi_uidivmod
000102  e78e              B        |L1.34|
                  |L1.260|
000104  4610              MOV      r0,r2                 ;346
000106  e78c              B        |L1.34|
                          ENDP

                  |L1.264|
                          DCD      0x40064000
                  |L1.268|
                          DCD      0x007a1200
                  |L1.272|
                          DCD      0x40048040
                  |L1.276|
                          DCD      ||.data||
                  |L1.280|
                          DCD      0x00000895
                  |L1.284|
                          DCD      0x00000b71
                  |L1.288|
                          DCD      0x003d0900

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;113    
;;;114    void SystemInit (void) {
000000  482d              LDR      r0,|L2.184|
;;;115    #if (DISABLE_WDOG)
;;;116      /* SIM_COPC: COPT=0,COPCLKS=0,COPW=0 */
;;;117      SIM->COPC = (uint32_t)0x00u;
000002  2200              MOVS     r2,#0
000004  6002              STR      r2,[r0,#0]
;;;118    #endif /* (DISABLE_WDOG) */
;;;119    #ifdef CLOCK_SETUP
;;;120      if((RCM->SRS0 & RCM_SRS0_WAKEUP_MASK) != 0x00U)
000006  482d              LDR      r0,|L2.188|
000008  7800              LDRB     r0,[r0,#0]
00000a  07c0              LSLS     r0,r0,#31
00000c  d007              BEQ      |L2.30|
;;;121      {
;;;122        if((PMC->REGSC & PMC_REGSC_ACKISO_MASK) != 0x00U)
00000e  482c              LDR      r0,|L2.192|
000010  7881              LDRB     r1,[r0,#2]
000012  0709              LSLS     r1,r1,#28
000014  d503              BPL      |L2.30|
;;;123        {
;;;124           PMC->REGSC |= PMC_REGSC_ACKISO_MASK; /* Release hold with ACKISO:  Only has an effect if recovering from VLLSx.*/
000016  7881              LDRB     r1,[r0,#2]
000018  2308              MOVS     r3,#8
00001a  4319              ORRS     r1,r1,r3
00001c  7081              STRB     r1,[r0,#2]
                  |L2.30|
;;;125        }
;;;126      }
;;;127    
;;;128      /* Power mode protection initialization */
;;;129    #ifdef SYSTEM_SMC_PMPROT_VALUE
;;;130      SMC->PMPROT = SYSTEM_SMC_PMPROT_VALUE;
00001e  4929              LDR      r1,|L2.196|
000020  202a              MOVS     r0,#0x2a
000022  7008              STRB     r0,[r1,#0]
;;;131    #endif
;;;132    
;;;133      /* System clock initialization */
;;;134      /* Internal reference clock trim initialization */
;;;135    #if defined(SLOW_TRIM_ADDRESS)
;;;136      if ( *((uint8_t*)SLOW_TRIM_ADDRESS) != 0xFFU) {                              /* Skip if non-volatile flash memory is erased */
;;;137        MCG->C3 = *((uint8_t*)SLOW_TRIM_ADDRESS);
;;;138      #endif /* defined(SLOW_TRIM_ADDRESS) */
;;;139      #if defined(SLOW_FINE_TRIM_ADDRESS)
;;;140        MCG->C4 = (MCG->C4 & ~(MCG_C4_SCFTRIM_MASK)) | ((*((uint8_t*) SLOW_FINE_TRIM_ADDRESS)) & MCG_C4_SCFTRIM_MASK);
;;;141      #endif
;;;142      #if defined(FAST_TRIM_ADDRESS)
;;;143        MCG->C4 = (MCG->C4 & ~(MCG_C4_FCTRIM_MASK)) |((*((uint8_t*) FAST_TRIM_ADDRESS)) & MCG_C4_FCTRIM_MASK);
;;;144      #endif
;;;145    #if defined(SLOW_TRIM_ADDRESS)
;;;146      }
;;;147      #endif /* defined(SLOW_TRIM_ADDRESS) */
;;;148    
;;;149      /* Set system prescalers and clock sources */
;;;150      SIM->CLKDIV1 = SYSTEM_SIM_CLKDIV1_VALUE; /* Set system prescalers */
000024  4929              LDR      r1,|L2.204|
000026  4828              LDR      r0,|L2.200|
000028  6048              STR      r0,[r1,#4]
;;;151      SIM->SOPT1 = ((SIM->SOPT1) & (uint32_t)(~(SIM_SOPT1_OSC32KSEL_MASK))) | ((SYSTEM_SIM_SOPT1_VALUE) & (SIM_SOPT1_OSC32KSEL_MASK)); /* Set 32 kHz clock source (ERCLK32K) */
00002a  4829              LDR      r0,|L2.208|
00002c  6801              LDR      r1,[r0,#0]
00002e  2303              MOVS     r3,#3
000030  049b              LSLS     r3,r3,#18
000032  4319              ORRS     r1,r1,r3
000034  6001              STR      r1,[r0,#0]
;;;152      SIM->SOPT2 = ((SIM->SOPT2) & (uint32_t)(~(SIM_SOPT2_PLLFLLSEL_MASK))) | ((SYSTEM_SIM_SOPT2_VALUE) & (SIM_SOPT2_PLLFLLSEL_MASK)); /* Selects the high frequency clock for various peripheral clocking options. */
000036  4827              LDR      r0,|L2.212|
000038  6841              LDR      r1,[r0,#4]
00003a  2301              MOVS     r3,#1
00003c  041b              LSLS     r3,r3,#16
00003e  4319              ORRS     r1,r1,r3
000040  6041              STR      r1,[r0,#4]
;;;153      SIM->SOPT2 = ((SIM->SOPT2) & (uint32_t)(~(SIM_SOPT2_TPMSRC_MASK))) | ((SYSTEM_SIM_SOPT2_VALUE) & (SIM_SOPT2_TPMSRC_MASK)); /* Selects the clock source for the TPM counter clock. */
000042  6841              LDR      r1,[r0,#4]
000044  2303              MOVS     r3,#3
000046  061b              LSLS     r3,r3,#24
000048  4399              BICS     r1,r1,r3
00004a  2301              MOVS     r3,#1
00004c  061b              LSLS     r3,r3,#24
00004e  18c9              ADDS     r1,r1,r3
000050  6041              STR      r1,[r0,#4]
;;;154    #if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FBI) || (MCG_MODE == MCG_MODE_BLPI))
;;;155      /* Set MCG and OSC */
;;;156    #if  ((((SYSTEM_OSC0_CR_VALUE) & OSC_CR_ERCLKEN_MASK) != 0x00U) || (((SYSTEM_MCG_C5_VALUE) & MCG_C5_PLLCLKEN0_MASK) != 0x00U))
;;;157      /* SIM_SCGC5: PORTA=1 */
;;;158      SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
;;;159      /* PORTA_PCR18: ISF=0,MUX=0 */
;;;160      PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
;;;161      if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS0_MASK) != 0x00U) {
;;;162      /* PORTA_PCR19: ISF=0,MUX=0 */
;;;163      PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
;;;164      }
;;;165    #endif
;;;166      MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
;;;167      MCG->C1 = SYSTEM_MCG_C1_VALUE;       /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
;;;168      /* Check that the source of the FLL reference clock is the requested one. */
;;;169      if (((SYSTEM_MCG_C1_VALUE) & MCG_C1_IREFS_MASK) != 0x00U) {
;;;170        while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) {
;;;171        }
;;;172      } else {
;;;173        while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) {
;;;174        }
;;;175      }
;;;176      MCG->C2 = (SYSTEM_MCG_C2_VALUE) & (uint8_t)(~(MCG_C2_LP_MASK)); /* Set C2 (freq. range, ext. and int. reference selection etc.; low power bit is set later) */
;;;177      MCG->C4 = ((SYSTEM_MCG_C4_VALUE) & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG->C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
;;;178      OSC0->CR = SYSTEM_OSC0_CR_VALUE;     /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
;;;179      #if (MCG_MODE == MCG_MODE_BLPI)
;;;180      /* BLPI specific */
;;;181      MCG->C2 |= (MCG_C2_LP_MASK);         /* Disable FLL and PLL in bypass mode */
;;;182      #endif
;;;183    
;;;184    #else /* MCG_MODE */
;;;185      /* Set MCG and OSC */
;;;186      /* SIM_SCGC5: PORTA=1 */
;;;187      SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
000052  6b81              LDR      r1,[r0,#0x38]
000054  1543              ASRS     r3,r0,#21
000056  4319              ORRS     r1,r1,r3
000058  6381              STR      r1,[r0,#0x38]
;;;188      /* PORTA_PCR18: ISF=0,MUX=0 */
;;;189      PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
00005a  481f              LDR      r0,|L2.216|
00005c  6883              LDR      r3,[r0,#8]
00005e  491f              LDR      r1,|L2.220|
000060  400b              ANDS     r3,r3,r1
000062  6083              STR      r3,[r0,#8]
;;;190      if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS0_MASK) != 0x00U) {
;;;191      /* PORTA_PCR19: ISF=0,MUX=0 */
;;;192      PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
000064  68c3              LDR      r3,[r0,#0xc]
000066  400b              ANDS     r3,r3,r1
000068  60c3              STR      r3,[r0,#0xc]
;;;193      }
;;;194      MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
00006a  481d              LDR      r0,|L2.224|
00006c  7202              STRB     r2,[r0,#8]
;;;195      MCG->C2 = (SYSTEM_MCG_C2_VALUE) & (uint8_t)(~(MCG_C2_LP_MASK)); /* Set C2 (freq. range, ext. and int. reference selection etc.; low power bit is set later) */
00006e  2124              MOVS     r1,#0x24
000070  7041              STRB     r1,[r0,#1]
;;;196      OSC0->CR = SYSTEM_OSC0_CR_VALUE;     /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
000072  4b1c              LDR      r3,|L2.228|
000074  2180              MOVS     r1,#0x80
000076  7019              STRB     r1,[r3,#0]
;;;197      #if (MCG_MODE == MCG_MODE_PEE)
;;;198      MCG->C1 = (SYSTEM_MCG_C1_VALUE) | MCG_C1_CLKS(0x02); /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) - PBE mode*/
000078  219a              MOVS     r1,#0x9a
00007a  7001              STRB     r1,[r0,#0]
                  |L2.124|
;;;199      #else
;;;200      MCG->C1 = SYSTEM_MCG_C1_VALUE;       /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
;;;201      #endif
;;;202      if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS0_MASK) != 0x00U) {
;;;203        while((MCG->S & MCG_S_OSCINIT0_MASK) == 0x00U) { /* Check that the oscillator is running */
00007c  7981              LDRB     r1,[r0,#6]
00007e  0789              LSLS     r1,r1,#30
000080  d5fc              BPL      |L2.124|
                  |L2.130|
;;;204        }
;;;205      }
;;;206      /* Check that the source of the FLL reference clock is the requested one. */
;;;207      if (((SYSTEM_MCG_C1_VALUE) & MCG_C1_IREFS_MASK) != 0x00U) {
;;;208        while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) {
;;;209        }
;;;210      } else {
;;;211        while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) {
000082  7981              LDRB     r1,[r0,#6]
000084  06c9              LSLS     r1,r1,#27
000086  d4fc              BMI      |L2.130|
;;;212        }
;;;213      }
;;;214      MCG->C4 = ((SYSTEM_MCG_C4_VALUE)  & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG->C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
000088  78c1              LDRB     r1,[r0,#3]
00008a  06c9              LSLS     r1,r1,#27
00008c  0ec9              LSRS     r1,r1,#27
00008e  70c1              STRB     r1,[r0,#3]
;;;215    #endif /* MCG_MODE */
;;;216    
;;;217      /* Common for all MCG modes */
;;;218    
;;;219      /* PLL clock can be used to generate clock for some devices regardless of clock generator (MCGOUTCLK) mode. */
;;;220      MCG->C5 = (SYSTEM_MCG_C5_VALUE) & (uint8_t)(~(MCG_C5_PLLCLKEN0_MASK)); /* Set C5 (PLL settings, PLL reference divider etc.) */
000090  2101              MOVS     r1,#1
000092  7101              STRB     r1,[r0,#4]
;;;221      MCG->C6 = (SYSTEM_MCG_C6_VALUE) & (uint8_t)~(MCG_C6_PLLS_MASK); /* Set C6 (PLL select, VCO divider etc.) */
000094  7142              STRB     r2,[r0,#5]
;;;222      if ((SYSTEM_MCG_C5_VALUE) & MCG_C5_PLLCLKEN0_MASK) {
;;;223        MCG->C5 |= MCG_C5_PLLCLKEN0_MASK;  /* PLL clock enable in mode other than PEE or PBE */
;;;224      }
;;;225      /* BLPE, PEE and PBE MCG mode specific */
;;;226    
;;;227    #if (MCG_MODE == MCG_MODE_BLPE)
;;;228      MCG->C2 |= (MCG_C2_LP_MASK);         /* Disable FLL and PLL in bypass mode */
;;;229    #elif ((MCG_MODE == MCG_MODE_PBE) || (MCG_MODE == MCG_MODE_PEE))
;;;230      MCG->C6 |= (MCG_C6_PLLS_MASK);       /* Set C6 (PLL select, VCO divider etc.) */
000096  7941              LDRB     r1,[r0,#5]
000098  2240              MOVS     r2,#0x40
00009a  4311              ORRS     r1,r1,r2
00009c  7141              STRB     r1,[r0,#5]
                  |L2.158|
;;;231      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until PLL is locked*/
00009e  7981              LDRB     r1,[r0,#6]
0000a0  0649              LSLS     r1,r1,#25
0000a2  d5fc              BPL      |L2.158|
;;;232      }
;;;233      #if (MCG_MODE == MCG_MODE_PEE)
;;;234      MCG->C1 &= (uint8_t)~(MCG_C1_CLKS_MASK);
0000a4  7801              LDRB     r1,[r0,#0]
0000a6  0689              LSLS     r1,r1,#26
0000a8  0e89              LSRS     r1,r1,#26
0000aa  7001              STRB     r1,[r0,#0]
                  |L2.172|
;;;235      #endif
;;;236    #endif
;;;237    #if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FEE))
;;;238      while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
;;;239      }
;;;240      /* Use LPTMR to wait for 1ms for FLL clock stabilization */
;;;241      SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;   /* Alow software control of LPMTR */
;;;242      LPTMR0->CMR = LPTMR_CMR_COMPARE(0);  /* Default 1 LPO tick */
;;;243      LPTMR0->CSR = (LPTMR_CSR_TCF_MASK | LPTMR_CSR_TPS(0x00));
;;;244      LPTMR0->PSR = (LPTMR_PSR_PCS(0x01) | LPTMR_PSR_PBYP_MASK); /* Clock source: LPO, Prescaler bypass enable */
;;;245      LPTMR0->CSR = LPTMR_CSR_TEN_MASK;    /* LPMTR enable */
;;;246      while((LPTMR0_CSR & LPTMR_CSR_TCF_MASK) == 0u) {
;;;247      }
;;;248      LPTMR0_CSR = 0x00;                   /* Disable LPTMR */
;;;249      SIM_SCGC5 &= (uint32_t)~(uint32_t)SIM_SCGC5_LPTMR_MASK;
;;;250    #elif ((MCG_MODE == MCG_MODE_FBI) || (MCG_MODE == MCG_MODE_BLPI))
;;;251      while((MCG->S & MCG_S_CLKST_MASK) != 0x04U) { /* Wait until internal reference clock is selected as MCG output */
;;;252      }
;;;253    #elif ((MCG_MODE == MCG_MODE_FBE) || (MCG_MODE == MCG_MODE_PBE) || (MCG_MODE == MCG_MODE_BLPE))
;;;254      while((MCG->S & MCG_S_CLKST_MASK) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
;;;255      }
;;;256    #elif (MCG_MODE == MCG_MODE_PEE)
;;;257      while((MCG->S & MCG_S_CLKST_MASK) != 0x0CU) { /* Wait until output of the PLL is selected */
0000ac  7981              LDRB     r1,[r0,#6]
0000ae  0709              LSLS     r1,r1,#28
0000b0  0f89              LSRS     r1,r1,#30
0000b2  2903              CMP      r1,#3
0000b4  d1fa              BNE      |L2.172|
;;;258      }
;;;259    #endif
;;;260    #if (((SYSTEM_SMC_PMCTRL_VALUE) & SMC_PMCTRL_RUNM_MASK) == (0x02U << SMC_PMCTRL_RUNM_SHIFT))
;;;261      SMC->PMCTRL = (uint8_t)((SYSTEM_SMC_PMCTRL_VALUE) & (SMC_PMCTRL_RUNM_MASK)); /* Enable VLPR mode */
;;;262      while(SMC->PMSTAT != 0x04U) {        /* Wait until the system is in VLPR mode */
;;;263      }
;;;264    #endif
;;;265    
;;;266      /* PLL loss of lock interrupt request initialization */
;;;267      if (((SYSTEM_MCG_C6_VALUE) & MCG_C6_LOLIE0_MASK) != 0U) {
;;;268        NVIC_EnableIRQ(MCG_IRQn);          /* Enable PLL loss of lock interrupt request */
;;;269      }
;;;270    #endif
;;;271    }
0000b6  4770              BX       lr
;;;272    
                          ENDP

                  |L2.184|
                          DCD      0x40048100
                  |L2.188|
                          DCD      0x4007f000
                  |L2.192|
                          DCD      0x4007d000
                  |L2.196|
                          DCD      0x4007e000
                  |L2.200|
                          DCD      0x10010000
                  |L2.204|
                          DCD      0x40048040
                  |L2.208|
                          DCD      0x40047000
                  |L2.212|
                          DCD      0x40048000
                  |L2.216|
                          DCD      0x40049040
                  |L2.220|
                          DCD      0xfefff8ff
                  |L2.224|
                          DCD      0x40064000
                  |L2.228|
                          DCD      0x40065000

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x02dc6c00

;*** Start embedded assembler ***

#line 1 "RTE\\Device\\MKL25Z128xxx4\\system_MKL25Z4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL25Z4_c_5d646a67____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_system_MKL25Z4_c_5d646a67____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL25Z4_c_5d646a67____REVSH|
#line 462
|__asm___16_system_MKL25Z4_c_5d646a67____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
