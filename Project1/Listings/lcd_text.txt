; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\lcd_text.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\lcd_text.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\lcd_text.crf Source\LCD\LCD_text.c]
                          THUMB

                          AREA ||i.Bit_Reverse_Byte||, CODE, READONLY, ALIGN=1

                  Bit_Reverse_Byte PROC
;;;21     
;;;22     uint8_t Bit_Reverse_Byte(uint8_t v) {
000000  2207              MOVS     r2,#7
;;;23     // http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious
;;;24     	// v: input bits to be reversed
;;;25     	int r = v;										// r will be reversed bits of v; first get LSB of v
;;;26     	int s = sizeof(v) * 8 - 1;		// extra shift needed at end
;;;27     
;;;28     	for (v >>= 1; v; v >>= 1) {
000002  0841              LSRS     r1,r0,#1
000004  d006              BEQ      |L1.20|
                  |L1.6|
;;;29     		r <<= 1;
000006  0043              LSLS     r3,r0,#1
;;;30     		r |= v & 1;
000008  07c8              LSLS     r0,r1,#31
00000a  0fc0              LSRS     r0,r0,#31
00000c  4318              ORRS     r0,r0,r3
00000e  1e52              SUBS     r2,r2,#1
000010  0849              LSRS     r1,r1,#1              ;28
000012  d1f8              BNE      |L1.6|
                  |L1.20|
;;;31     		s--;
;;;32     	}
;;;33     	r <<= s;											// shift when v's highest bits are zero
000014  4090              LSLS     r0,r0,r2
;;;34     	return r;
000016  b2c0              UXTB     r0,r0
;;;35     }
000018  4770              BX       lr
;;;36     
                          ENDP


                          AREA ||i.LCD_Erase||, CODE, READONLY, ALIGN=2

                  LCD_Erase PROC
;;;45     
;;;46     void LCD_Erase(void) {
000000  b510              PUSH     {r4,lr}
;;;47     	LCD_Fill_Buffer(&bg);
000002  4802              LDR      r0,|L2.12|
000004  f7fffffe          BL       LCD_Fill_Buffer
;;;48     }
000008  bd10              POP      {r4,pc}
;;;49     
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.data||+0x5

                          AREA ||i.LCD_Text_GetGlyphWidth||, CODE, READONLY, ALIGN=2

                  LCD_Text_GetGlyphWidth PROC
;;;85     
;;;86     uint8_t LCD_Text_GetGlyphWidth(char ch) {
000000  4904              LDR      r1,|L3.20|
;;;87     	uint8_t glyph_index_entry;
;;;88     
;;;89     	glyph_index_entry = ch - font_header->FirstChar;
000002  68ca              LDR      r2,[r1,#0xc]  ; font_header
;;;90     	return glyph_index[glyph_index_entry].Width;
000004  6909              LDR      r1,[r1,#0x10]  ; glyph_index
000006  7892              LDRB     r2,[r2,#2]            ;89
000008  1a80              SUBS     r0,r0,r2              ;89
00000a  0600              LSLS     r0,r0,#24             ;89
00000c  0d80              LSRS     r0,r0,#22
00000e  5c08              LDRB     r0,[r1,r0]
;;;91     }
000010  4770              BX       lr
;;;92     void LCD_Text_PrintChar(PT_T * pos, char ch) {
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      ||.data||

                          AREA ||i.LCD_Text_Init||, CODE, READONLY, ALIGN=2

                  LCD_Text_Init PROC
;;;49     
;;;50     void LCD_Text_Init(uint8_t font_num) {
000000  480b              LDR      r0,|L4.48|
;;;51     // font_num is ignored currently  
;;;52     #if 0														// Code for multiple fonts not working yet
;;;53     	font = fonts[font_num];
;;;54     	G_LCD_char_width = char_widths[font_num];
;;;55     	G_LCD_char_height = char_heights[font_num];
;;;56     #endif
;;;57     
;;;58     // // This code is not working
;;;59     //  font = Lucida_Console20x31;
;;;60     //  G_LCD_char_width = 20;
;;;61     //  G_LCD_char_height = 31;
;;;62     
;;;63     #if 1														// This code is working
;;;64     	font = Lucida_Console12x19;
000002  490a              LDR      r1,|L4.44|
;;;65     	G_LCD_char_width = 12;
000004  220c              MOVS     r2,#0xc
000006  6081              STR      r1,[r0,#8]  ; font
000008  7002              STRB     r2,[r0,#0]
;;;66     	G_LCD_char_height = 19;
00000a  2213              MOVS     r2,#0x13
00000c  7042              STRB     r2,[r0,#1]
;;;67     #else
;;;68     	font = Lucida_Console8x13;
;;;69     	G_LCD_char_width = 8;
;;;70     	G_LCD_char_height = 13;
;;;71     #endif
;;;72     
;;;73     	font_header = (FONT_HEADER_T *) font;
00000e  60c1              STR      r1,[r0,#0xc]  ; font_header
000010  3108              ADDS     r1,r1,#8
;;;74     	glyph_index = (GLYPH_INDEX_T *) (font + sizeof(FONT_HEADER_T));
;;;75     
;;;76     	// Set default FG and BG colors
;;;77     	fg.R = 255;
000012  6101              STR      r1,[r0,#0x10]  ; glyph_index
000014  4907              LDR      r1,|L4.52|
000016  20ff              MOVS     r0,#0xff
000018  7008              STRB     r0,[r1,#0]
;;;78     	fg.G = 255;
00001a  7048              STRB     r0,[r1,#1]
;;;79     	fg.B = 0;
00001c  2000              MOVS     r0,#0
00001e  7088              STRB     r0,[r1,#2]
;;;80     
;;;81     	bg.R = 0;
000020  4905              LDR      r1,|L4.56|
000022  7008              STRB     r0,[r1,#0]
;;;82     	bg.G = 0;
000024  7048              STRB     r0,[r1,#1]
;;;83     	bg.B = 0;
000026  7088              STRB     r0,[r1,#2]
;;;84     }
000028  4770              BX       lr
;;;85     
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      Lucida_Console12x19
                  |L4.48|
                          DCD      ||.data||
                  |L4.52|
                          DCD      ||.data||+0x2
                  |L4.56|
                          DCD      ||.data||+0x5

                          AREA ||i.LCD_Text_PrintChar||, CODE, READONLY, ALIGN=2

                  LCD_Text_PrintChar PROC
;;;91     }
;;;92     void LCD_Text_PrintChar(PT_T * pos, char ch) {
000000  b5f0              PUSH     {r4-r7,lr}
;;;93     	uint8_t glyph_index_entry;
;;;94     	const uint8_t *glyph_data;		// start of the data
;;;95     #if BITS_PER_PIXEL == 1					// Copy bitmap byte directly
;;;96     	PT_T cur_pos;
;;;97     #endif
;;;98     	PT_T end_pos;
;;;99     	COLOR_T *pixel_color;
;;;100    	uint8_t bitmap_byte;
;;;101    	uint8_t glyph_width, x_bm;
;;;102    	uint32_t offset;
;;;103    	uint32_t row, col, num_pixels;
;;;104    
;;;105    	glyph_index_entry = ch - font_header->FirstChar;
000002  4c66              LDR      r4,|L5.412|
000004  b085              SUB      sp,sp,#0x14           ;92
000006  68e2              LDR      r2,[r4,#0xc]  ; font_header
000008  7892              LDRB     r2,[r2,#2]
00000a  1a89              SUBS     r1,r1,r2
00000c  0609              LSLS     r1,r1,#24
;;;106    	glyph_width = glyph_index[glyph_index_entry].Width;
00000e  6922              LDR      r2,[r4,#0x10]  ; glyph_index
000010  0d89              LSRS     r1,r1,#22
000012  5851              LDR      r1,[r2,r1]
;;;107    	offset = glyph_index[glyph_index_entry].Offset;
;;;108    	glyph_data = &(font[offset]);
000014  68a2              LDR      r2,[r4,#8]  ; font
000016  b2cd              UXTB     r5,r1                 ;106
000018  0a09              LSRS     r1,r1,#8              ;107
00001a  1851              ADDS     r1,r2,r1
;;;109    
;;;110    #if BITS_PER_PIXEL == 1					// Copy bitmap byte directly
;;;111    	cur_pos.Y = pos->Y;
;;;112    
;;;113    	for (row = 0; row < CHAR_HEIGHT; row++) {
;;;114    		cur_pos.X = pos->X;
;;;115    		x_bm = 0;										// x position within glyph bitmap, can span bytes 
;;;116    		do {
;;;117    			bitmap_byte = *glyph_data;
;;;118    			bitmap_byte = Bit_Reverse_Byte(bitmap_byte);
;;;119    			num_pixels = MIN(8, glyph_width - x_bm);
;;;120    			if ((cur_pos.X & 0x07) == 0) {	// Glyph is byte-aligned, so ready to plot
;;;121    				LCD_Plot_Packed_Pixels(bitmap_byte, (&cur_pos));
;;;122    				// LCD_Refresh();
;;;123    				x_bm += num_pixels;
;;;124    			} else {									// Split and align as needed
;;;125    				LCD_Plot_Packed_Pixels_Unaligned(bitmap_byte,
;;;126    																				 (cur_pos.X & 0x07),
;;;127    																				 (&cur_pos));
;;;128    				// LCD_Refresh();
;;;129    				x_bm += num_pixels;
;;;130    			}
;;;131    			cur_pos.X += num_pixels;
;;;132    			glyph_data++;							// Advance to next byte of glyph data
;;;133    		} while (x_bm < glyph_width);
;;;134    		while (x_bm < CHAR_WIDTH) {
;;;135    			// fill in rest of cell with background color for narrow glyphs
;;;136    			LCD_Plot_Pixel(&cur_pos, &bg);
;;;137    			// LCD_Refresh();
;;;138    			x_bm++;
;;;139    			cur_pos.X++;
;;;140    		}
;;;141    		cur_pos.Y++;
;;;142    	}
;;;143    	LCD_Refresh();
;;;144    #else														// BPP != 1, so expand to given color
;;;145    	end_pos.X = pos->X + CHAR_WIDTH - 1;
00001c  9101              STR      r1,[sp,#4]
00001e  7821              LDRB     r1,[r4,#0]  ; G_LCD_char_width
000020  6802              LDR      r2,[r0,#0]
000022  1e49              SUBS     r1,r1,#1
000024  1851              ADDS     r1,r2,r1
;;;146    	end_pos.Y = pos->Y + CHAR_HEIGHT - 1;
000026  9102              STR      r1,[sp,#8]
000028  7861              LDRB     r1,[r4,#1]  ; G_LCD_char_height
00002a  6842              LDR      r2,[r0,#4]
00002c  1e49              SUBS     r1,r1,#1
00002e  1851              ADDS     r1,r2,r1
;;;147    
;;;148    	LCD_Start_Rectangle(pos, &end_pos);
000030  9103              STR      r1,[sp,#0xc]
000032  a902              ADD      r1,sp,#8
000034  f7fffffe          BL       LCD_Start_Rectangle
;;;149    
;;;150    	for (row = 0; row < CHAR_HEIGHT; row++) {
000038  2000              MOVS     r0,#0
00003a  9004              STR      r0,[sp,#0x10]
00003c  7860              LDRB     r0,[r4,#1]  ; G_LCD_char_height
00003e  2800              CMP      r0,#0
000040  d974              BLS      |L5.300|
                  |L5.66|
;;;151    		x_bm = 0;										// x position within glyph bitmap, can span bytes 
000042  2400              MOVS     r4,#0
                  |L5.68|
;;;152    		do {
;;;153    			bitmap_byte = *glyph_data;
000044  9801              LDR      r0,[sp,#4]
000046  7806              LDRB     r6,[r0,#0]
;;;154    
;;;155    			// Special cases with run starting at LSB 
;;;156    			// Up to 8 bit run
;;;157    			if (bitmap_byte == 0x00) {
000048  2e00              CMP      r6,#0
00004a  d014              BEQ      |L5.118|
;;;158    				num_pixels = MIN(8, glyph_width - x_bm);
;;;159    				LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;160    				x_bm += num_pixels;
;;;161    			} else if (bitmap_byte == 0xff) {
00004c  2eff              CMP      r6,#0xff
00004e  d01d              BEQ      |L5.140|
;;;162    				num_pixels = MIN(8, glyph_width - x_bm);
;;;163    				LCD_Write_Rectangle_Pixel(&fg, num_pixels);
;;;164    				x_bm += num_pixels;
;;;165    			} else {
;;;166    				col = 0;
000050  2700              MOVS     r7,#0
;;;167    				num_pixels = 0;
;;;168    				if ((bitmap_byte & 0x7f) == 0) {	// Up to 7 bit run
000052  0670              LSLS     r0,r6,#25
000054  d025              BEQ      |L5.162|
;;;169    					num_pixels = MIN(7, glyph_width - x_bm);
;;;170    					LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;171    				} else if ((bitmap_byte & 0x7f) == 0x7f) {
000056  43f0              MVNS     r0,r6
000058  0641              LSLS     r1,r0,#25
00005a  d02a              BEQ      |L5.178|
;;;172    					num_pixels = MIN(7, glyph_width - x_bm);
;;;173    					LCD_Write_Rectangle_Pixel(&fg, num_pixels);
;;;174    				} else if ((bitmap_byte & 0x3f) == 0) {	// Up to 6 bit run
00005c  06b1              LSLS     r1,r6,#26
00005e  d03d              BEQ      |L5.220|
;;;175    					num_pixels = MIN(6, glyph_width - x_bm);
;;;176    					LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;177    				} else if ((bitmap_byte & 0x3f) == 0x3f) {
000060  0681              LSLS     r1,r0,#26
000062  d047              BEQ      |L5.244|
;;;178    					num_pixels = MIN(6, glyph_width - x_bm);
;;;179    					LCD_Write_Rectangle_Pixel(&fg, num_pixels);
;;;180    				} else if ((bitmap_byte & 0x1f) == 0) {	// Up to 5 bit run
000064  06f1              LSLS     r1,r6,#27
000066  d051              BEQ      |L5.268|
;;;181    					num_pixels = MIN(5, glyph_width - x_bm);
;;;182    					LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;183    				} else if ((bitmap_byte & 0x1f) == 0x1f) {
000068  06c1              LSLS     r1,r0,#27
00006a  d057              BEQ      |L5.284|
;;;184    					num_pixels = MIN(5, glyph_width - x_bm);
;;;185    					LCD_Write_Rectangle_Pixel(&fg, num_pixels);
;;;186    				} else if ((bitmap_byte & 0x0f) == 0) {	// Up to 4 bit run
00006c  0731              LSLS     r1,r6,#28
00006e  d05e              BEQ      |L5.302|
;;;187    					num_pixels = MIN(4, glyph_width - x_bm);
;;;188    					LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;189    				} else if ((bitmap_byte & 0x0f) == 0x0f) {
000070  0700              LSLS     r0,r0,#28
000072  d064              BEQ      |L5.318|
000074  e077              B        |L5.358|
                  |L5.118|
000076  1b2e              SUBS     r6,r5,r4              ;158
000078  2e08              CMP      r6,#8                 ;158
00007a  dd00              BLE      |L5.126|
00007c  2608              MOVS     r6,#8                 ;158
                  |L5.126|
00007e  4631              MOV      r1,r6                 ;159
000080  4847              LDR      r0,|L5.416|
000082  f7fffffe          BL       LCD_Write_Rectangle_Pixel
000086  19a0              ADDS     r0,r4,r6              ;160
000088  b2c4              UXTB     r4,r0                 ;160
00008a  e070              B        |L5.366|
                  |L5.140|
00008c  1b2e              SUBS     r6,r5,r4              ;162
00008e  2e08              CMP      r6,#8                 ;162
000090  dd00              BLE      |L5.148|
000092  2608              MOVS     r6,#8                 ;162
                  |L5.148|
000094  4631              MOV      r1,r6                 ;163
000096  4843              LDR      r0,|L5.420|
000098  f7fffffe          BL       LCD_Write_Rectangle_Pixel
00009c  19a0              ADDS     r0,r4,r6              ;164
00009e  b2c4              UXTB     r4,r0                 ;164
0000a0  e065              B        |L5.366|
                  |L5.162|
0000a2  1b28              SUBS     r0,r5,r4              ;169
0000a4  2807              CMP      r0,#7                 ;169
0000a6  dd21              BLE      |L5.236|
0000a8  2007              MOVS     r0,#7                 ;169
0000aa  4601              MOV      r1,r0                 ;170
0000ac  9000              STR      r0,[sp,#0]            ;170
0000ae  483c              LDR      r0,|L5.416|
0000b0  e006              B        |L5.192|
                  |L5.178|
0000b2  1b28              SUBS     r0,r5,r4              ;172
0000b4  2807              CMP      r0,#7                 ;172
0000b6  dd25              BLE      |L5.260|
0000b8  2007              MOVS     r0,#7                 ;172
0000ba  4601              MOV      r1,r0                 ;173
0000bc  9000              STR      r0,[sp,#0]            ;173
0000be  4839              LDR      r0,|L5.420|
                  |L5.192|
0000c0  f7fffffe          BL       LCD_Write_Rectangle_Pixel
0000c4  e004              B        |L5.208|
                  |L5.198|
0000c6  f7fffffe          BL       LCD_Write_Rectangle_Pixel
;;;190    					num_pixels = MIN(4, glyph_width - x_bm);
;;;191    					LCD_Write_Rectangle_Pixel(&fg, num_pixels);
;;;192    				}
;;;193    				if (num_pixels > 0) {
0000ca  9800              LDR      r0,[sp,#0]
0000cc  2800              CMP      r0,#0
0000ce  d04a              BEQ      |L5.358|
                  |L5.208|
;;;194    					x_bm += num_pixels;		// Advance position in glyph bitmap
0000d0  9800              LDR      r0,[sp,#0]
;;;195    					col += num_pixels;		// Advance position withing glyph bitmap byte
;;;196    					bitmap_byte >>= num_pixels;
0000d2  9f00              LDR      r7,[sp,#0]
0000d4  1820              ADDS     r0,r4,r0              ;194
0000d6  b2c4              UXTB     r4,r0                 ;194
0000d8  40fe              LSRS     r6,r6,r7
0000da  e044              B        |L5.358|
                  |L5.220|
0000dc  1b28              SUBS     r0,r5,r4              ;175
0000de  2806              CMP      r0,#6                 ;175
0000e0  dd04              BLE      |L5.236|
0000e2  2006              MOVS     r0,#6                 ;175
0000e4  4601              MOV      r1,r0                 ;176
0000e6  9000              STR      r0,[sp,#0]            ;176
0000e8  482d              LDR      r0,|L5.416|
0000ea  e7e9              B        |L5.192|
                  |L5.236|
0000ec  4601              MOV      r1,r0                 ;176
0000ee  9000              STR      r0,[sp,#0]            ;176
0000f0  482b              LDR      r0,|L5.416|
0000f2  e7e8              B        |L5.198|
                  |L5.244|
0000f4  1b28              SUBS     r0,r5,r4              ;178
0000f6  2806              CMP      r0,#6                 ;178
0000f8  dd04              BLE      |L5.260|
0000fa  2006              MOVS     r0,#6                 ;178
0000fc  4601              MOV      r1,r0                 ;179
0000fe  9000              STR      r0,[sp,#0]            ;179
000100  4828              LDR      r0,|L5.420|
000102  e7dd              B        |L5.192|
                  |L5.260|
000104  4601              MOV      r1,r0                 ;179
000106  9000              STR      r0,[sp,#0]            ;179
000108  4826              LDR      r0,|L5.420|
00010a  e7dc              B        |L5.198|
                  |L5.268|
00010c  1b28              SUBS     r0,r5,r4              ;181
00010e  2805              CMP      r0,#5                 ;181
000110  ddec              BLE      |L5.236|
000112  2005              MOVS     r0,#5                 ;181
000114  4601              MOV      r1,r0                 ;182
000116  9000              STR      r0,[sp,#0]            ;182
000118  4821              LDR      r0,|L5.416|
00011a  e7d1              B        |L5.192|
                  |L5.284|
00011c  1b28              SUBS     r0,r5,r4              ;184
00011e  2805              CMP      r0,#5                 ;184
000120  ddf0              BLE      |L5.260|
000122  2005              MOVS     r0,#5                 ;184
000124  4601              MOV      r1,r0                 ;185
000126  9000              STR      r0,[sp,#0]            ;185
000128  481e              LDR      r0,|L5.420|
00012a  e7c9              B        |L5.192|
                  |L5.300|
00012c  e034              B        |L5.408|
                  |L5.302|
00012e  1b28              SUBS     r0,r5,r4              ;187
000130  2804              CMP      r0,#4                 ;187
000132  dddb              BLE      |L5.236|
000134  2004              MOVS     r0,#4                 ;187
000136  4601              MOV      r1,r0                 ;188
000138  9000              STR      r0,[sp,#0]            ;188
00013a  4819              LDR      r0,|L5.416|
00013c  e7c0              B        |L5.192|
                  |L5.318|
00013e  1b28              SUBS     r0,r5,r4              ;190
000140  2804              CMP      r0,#4                 ;190
000142  dddf              BLE      |L5.260|
000144  2004              MOVS     r0,#4                 ;190
000146  4601              MOV      r1,r0                 ;191
000148  9000              STR      r0,[sp,#0]            ;191
00014a  4816              LDR      r0,|L5.420|
00014c  e7b8              B        |L5.192|
                  |L5.334|
;;;197    				}
;;;198    				for (; (x_bm < glyph_width) && (col < 8); col++) {	// Remaining pixels in byte
;;;199    					if (bitmap_byte & 0x01)	// if pixel is to be set
00014e  07f0              LSLS     r0,r6,#31
000150  d001              BEQ      |L5.342|
;;;200    						pixel_color = &fg;
000152  4814              LDR      r0,|L5.420|
000154  e000              B        |L5.344|
                  |L5.342|
;;;201    					else
;;;202    						pixel_color = &bg;
000156  4812              LDR      r0,|L5.416|
                  |L5.344|
;;;203    					LCD_Write_Rectangle_Pixel(pixel_color, 1);
000158  2101              MOVS     r1,#1
00015a  f7fffffe          BL       LCD_Write_Rectangle_Pixel
;;;204    					bitmap_byte >>= 1;
00015e  1c64              ADDS     r4,r4,#1
000160  0876              LSRS     r6,r6,#1
;;;205    					x_bm++;
000162  b2e4              UXTB     r4,r4
000164  1c7f              ADDS     r7,r7,#1
                  |L5.358|
000166  42ac              CMP      r4,r5                 ;198
000168  d201              BCS      |L5.366|
00016a  2f08              CMP      r7,#8                 ;198
00016c  d3ef              BCC      |L5.334|
                  |L5.366|
;;;206    				}
;;;207    			}
;;;208    			glyph_data++;							// Advance to next byte of glyph data
00016e  9801              LDR      r0,[sp,#4]
000170  1c40              ADDS     r0,r0,#1
;;;209    		} while (x_bm < glyph_width);
000172  9001              STR      r0,[sp,#4]
000174  42ac              CMP      r4,r5
000176  d200              BCS      |L5.378|
000178  e764              B        |L5.68|
                  |L5.378|
;;;210    		if (x_bm < CHAR_WIDTH) {
00017a  4e08              LDR      r6,|L5.412|
00017c  7830              LDRB     r0,[r6,#0]  ; G_LCD_char_width
00017e  4284              CMP      r4,r0
000180  d203              BCS      |L5.394|
;;;211    			// fill in rest of cell with background color for narrow glyphs
;;;212    			LCD_Write_Rectangle_Pixel(&bg, CHAR_WIDTH - x_bm);
000182  1b01              SUBS     r1,r0,r4
000184  1d70              ADDS     r0,r6,#5
000186  f7fffffe          BL       LCD_Write_Rectangle_Pixel
                  |L5.394|
00018a  9804              LDR      r0,[sp,#0x10]         ;150
00018c  1c40              ADDS     r0,r0,#1              ;150
00018e  9004              STR      r0,[sp,#0x10]         ;150
000190  7871              LDRB     r1,[r6,#1]            ;150  ; G_LCD_char_height
000192  4288              CMP      r0,r1                 ;150
000194  d200              BCS      |L5.408|
000196  e754              B        |L5.66|
                  |L5.408|
;;;213    		}
;;;214    	}
;;;215    #endif													// BPP != 1
;;;216    }
000198  b005              ADD      sp,sp,#0x14
00019a  bdf0              POP      {r4-r7,pc}
;;;217    
                          ENDP

                  |L5.412|
                          DCD      ||.data||
                  |L5.416|
                          DCD      ||.data||+0x5
                  |L5.420|
                          DCD      ||.data||+0x2

                          AREA ||i.LCD_Text_PrintStr||, CODE, READONLY, ALIGN=2

                  LCD_Text_PrintStr PROC
;;;217    
;;;218    void LCD_Text_PrintStr(PT_T * pos, char *str) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;219    	while (*str) {
000004  7808              LDRB     r0,[r1,#0]
000006  460c              MOV      r4,r1                 ;218
000008  2800              CMP      r0,#0
00000a  d016              BEQ      |L6.58|
;;;220    		LCD_Text_PrintChar(pos, *str);
;;;221    #if FORCE_MONOSPACE
;;;222    		pos->X += CHAR_WIDTH;				// forces monospacing for fonts
;;;223    #else
;;;224    		if (*str == ' ')
;;;225    			pos->X += CHAR_WIDTH;			// Increase width for space character!
00000c  4e0e              LDR      r6,|L6.72|
                  |L6.14|
00000e  b2c1              UXTB     r1,r0                 ;220
000010  4628              MOV      r0,r5                 ;220
000012  f7fffffe          BL       LCD_Text_PrintChar
000016  7820              LDRB     r0,[r4,#0]            ;224
000018  2820              CMP      r0,#0x20              ;224
00001a  d00f              BEQ      |L6.60|
00001c  68f1              LDR      r1,[r6,#0xc]          ;224  ; font_header
00001e  7889              LDRB     r1,[r1,#2]            ;224
000020  1a40              SUBS     r0,r0,r1              ;224
000022  0600              LSLS     r0,r0,#24             ;224
000024  6931              LDR      r1,[r6,#0x10]         ;224  ; glyph_index
000026  0d80              LSRS     r0,r0,#22             ;224
000028  5c08              LDRB     r0,[r1,r0]            ;224
;;;226    		else
;;;227    			pos->X += LCD_Text_GetGlyphWidth(*str) + 1;	// add a pixel of padding 
00002a  6829              LDR      r1,[r5,#0]
00002c  1c40              ADDS     r0,r0,#1
00002e  1840              ADDS     r0,r0,r1
000030  6028              STR      r0,[r5,#0]
                  |L6.50|
000032  7860              LDRB     r0,[r4,#1]            ;219
000034  1c64              ADDS     r4,r4,#1              ;219
000036  2800              CMP      r0,#0                 ;219
000038  d1e9              BNE      |L6.14|
                  |L6.58|
;;;228    #endif
;;;229    		str++;
;;;230    	}
;;;231    }
00003a  bd70              POP      {r4-r6,pc}
                  |L6.60|
00003c  7831              LDRB     r1,[r6,#0]            ;225  ; G_LCD_char_width
00003e  6828              LDR      r0,[r5,#0]            ;225
000040  1840              ADDS     r0,r0,r1              ;225
000042  6028              STR      r0,[r5,#0]            ;225
000044  e7f5              B        |L6.50|
;;;232    
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      ||.data||

                          AREA ||i.LCD_Text_PrintStr_RC||, CODE, READONLY, ALIGN=2

                  LCD_Text_PrintStr_RC PROC
;;;232    
;;;233    void LCD_Text_PrintStr_RC(uint8_t row, uint8_t col, char *str) {
000000  b530              PUSH     {r4,r5,lr}
;;;234    	PT_T pos;
;;;235    	pos.X = COL_TO_X(col);
000002  4d14              LDR      r5,|L7.84|
000004  4614              MOV      r4,r2                 ;233
000006  782a              LDRB     r2,[r5,#0]  ; G_LCD_char_width
000008  b083              SUB      sp,sp,#0xc            ;233
00000a  4351              MULS     r1,r2,r1
;;;236    	pos.Y = ROW_TO_Y(row);
00000c  9100              STR      r1,[sp,#0]
00000e  7869              LDRB     r1,[r5,#1]  ; G_LCD_char_height
000010  4348              MULS     r0,r1,r0
;;;237    	while (*str) {
000012  9001              STR      r0,[sp,#4]
000014  7820              LDRB     r0,[r4,#0]
000016  2800              CMP      r0,#0
000018  d015              BEQ      |L7.70|
                  |L7.26|
;;;238    		LCD_Text_PrintChar(&pos, *str);
00001a  b2c1              UXTB     r1,r0
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       LCD_Text_PrintChar
;;;239    #if FORCE_MONOSPACE
;;;240    		pos.X += CHAR_WIDTH;				// forces monospacing for fonts
;;;241    #else
;;;242    		if (*str == ' ')
000022  7820              LDRB     r0,[r4,#0]
000024  2820              CMP      r0,#0x20
000026  d010              BEQ      |L7.74|
000028  68e9              LDR      r1,[r5,#0xc]  ; font_header
00002a  7889              LDRB     r1,[r1,#2]
00002c  1a40              SUBS     r0,r0,r1
00002e  0600              LSLS     r0,r0,#24
000030  6929              LDR      r1,[r5,#0x10]  ; glyph_index
000032  0d80              LSRS     r0,r0,#22
000034  5c08              LDRB     r0,[r1,r0]
;;;243    			pos.X += CHAR_WIDTH;			// Increase width for space character!
;;;244    		else
;;;245    			pos.X += LCD_Text_GetGlyphWidth(*str) + 1;	// add a pixel of padding 
000036  9900              LDR      r1,[sp,#0]
000038  1c40              ADDS     r0,r0,#1
00003a  1840              ADDS     r0,r0,r1
                  |L7.60|
00003c  9000              STR      r0,[sp,#0]            ;237
00003e  7860              LDRB     r0,[r4,#1]            ;237
000040  1c64              ADDS     r4,r4,#1              ;237
000042  2800              CMP      r0,#0                 ;237
000044  d1e9              BNE      |L7.26|
                  |L7.70|
;;;246    #endif
;;;247    		str++;
;;;248    	}
;;;249    }
000046  b003              ADD      sp,sp,#0xc
000048  bd30              POP      {r4,r5,pc}
                  |L7.74|
00004a  7828              LDRB     r0,[r5,#0]            ;243  ; G_LCD_char_width
00004c  9900              LDR      r1,[sp,#0]            ;243
00004e  1808              ADDS     r0,r1,r0              ;243
000050  e7f4              B        |L7.60|
;;;250    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      ||.data||

                          AREA ||i.LCD_Text_Set_Colors||, CODE, READONLY, ALIGN=2

                  LCD_Text_Set_Colors PROC
;;;36     
;;;37     void LCD_Text_Set_Colors(COLOR_T * foreground, COLOR_T * background) {
000000  4a07              LDR      r2,|L8.32|
;;;38     	fg.R = foreground->R;
000002  7803              LDRB     r3,[r0,#0]
000004  7013              STRB     r3,[r2,#0]
;;;39     	fg.G = foreground->G;
000006  7843              LDRB     r3,[r0,#1]
000008  7053              STRB     r3,[r2,#1]
;;;40     	fg.B = foreground->B;
00000a  7880              LDRB     r0,[r0,#2]
00000c  7090              STRB     r0,[r2,#2]
;;;41     	bg.R = background->R;
00000e  4805              LDR      r0,|L8.36|
000010  780a              LDRB     r2,[r1,#0]
000012  7002              STRB     r2,[r0,#0]
;;;42     	bg.G = background->G;
000014  784a              LDRB     r2,[r1,#1]
000016  7042              STRB     r2,[r0,#1]
;;;43     	bg.B = background->B;
000018  7889              LDRB     r1,[r1,#2]
00001a  7081              STRB     r1,[r0,#2]
;;;44     }
00001c  4770              BX       lr
;;;45     
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      ||.data||+0x2
                  |L8.36|
                          DCD      ||.data||+0x5

                          AREA ||i.LCD_Text_Test||, CODE, READONLY, ALIGN=2

                  LCD_Text_Test PROC
;;;250    
;;;251    void LCD_Text_Test(void) {
000000  b5f0              PUSH     {r4-r7,lr}
;;;252    	PT_T pos;
;;;253    	uint32_t c;
;;;254    	int i;
;;;255    
;;;256    	pos.X = 0;
000002  2000              MOVS     r0,#0
000004  b085              SUB      sp,sp,#0x14           ;251
000006  4d37              LDR      r5,|L9.228|
;;;257    	pos.Y = 0;
000008  9000              STR      r0,[sp,#0]
;;;258    
;;;259    	for (i = 0; i < 100; i++) {
00000a  4606              MOV      r6,r0
00000c  9001              STR      r0,[sp,#4]
                  |L9.14|
;;;260    		LCD_Text_PrintStr(&pos, "Testing");
00000e  466f              MOV      r7,sp
000010  a435              ADR      r4,|L9.232|
                  |L9.18|
000012  7821              LDRB     r1,[r4,#0]
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       LCD_Text_PrintChar
00001a  7820              LDRB     r0,[r4,#0]
00001c  2820              CMP      r0,#0x20
00001e  d057              BEQ      |L9.208|
000020  68e9              LDR      r1,[r5,#0xc]  ; font_header
000022  7889              LDRB     r1,[r1,#2]
000024  1a40              SUBS     r0,r0,r1
000026  0600              LSLS     r0,r0,#24
000028  6929              LDR      r1,[r5,#0x10]  ; glyph_index
00002a  0d80              LSRS     r0,r0,#22
00002c  5c08              LDRB     r0,[r1,r0]
00002e  9900              LDR      r1,[sp,#0]
000030  1c40              ADDS     r0,r0,#1
000032  1840              ADDS     r0,r0,r1
000034  9000              STR      r0,[sp,#0]
                  |L9.54|
000036  7860              LDRB     r0,[r4,#1]
000038  1c64              ADDS     r4,r4,#1
00003a  2800              CMP      r0,#0
00003c  d1e9              BNE      |L9.18|
;;;261    		LCD_Refresh();
00003e  f7fffffe          BL       LCD_Refresh
;;;262    		Delay(10);
000042  200a              MOVS     r0,#0xa
000044  f7fffffe          BL       Delay
000048  4829              LDR      r0,|L9.240|
00004a  f7fffffe          BL       LCD_Fill_Buffer
;;;263    		LCD_Erase();
;;;264    		pos.X = pos.Y = i++;
00004e  9601              STR      r6,[sp,#4]
000050  9600              STR      r6,[sp,#0]
000052  1cb6              ADDS     r6,r6,#2
000054  2e64              CMP      r6,#0x64              ;259
000056  dbda              BLT      |L9.14|
000058  2600              MOVS     r6,#0                 ;259
;;;265    	}
;;;266    
;;;267    	LCD_Text_PrintStr_RC(0, 0, "1+ACDVZ_af");
00005a  a426              ADR      r4,|L9.244|
00005c  9602              STR      r6,[sp,#8]
00005e  9603              STR      r6,[sp,#0xc]
                  |L9.96|
000060  7821              LDRB     r1,[r4,#0]
000062  a802              ADD      r0,sp,#8
000064  f7fffffe          BL       LCD_Text_PrintChar
000068  7820              LDRB     r0,[r4,#0]
00006a  2820              CMP      r0,#0x20
00006c  d035              BEQ      |L9.218|
00006e  68e9              LDR      r1,[r5,#0xc]  ; font_header
000070  7889              LDRB     r1,[r1,#2]
000072  1a40              SUBS     r0,r0,r1
000074  0600              LSLS     r0,r0,#24
000076  6929              LDR      r1,[r5,#0x10]  ; glyph_index
000078  0d80              LSRS     r0,r0,#22
00007a  5c08              LDRB     r0,[r1,r0]
00007c  9902              LDR      r1,[sp,#8]
00007e  1c40              ADDS     r0,r0,#1
000080  1840              ADDS     r0,r0,r1
000082  9002              STR      r0,[sp,#8]
                  |L9.132|
000084  7860              LDRB     r0,[r4,#1]
000086  1c64              ADDS     r4,r4,#1
000088  2800              CMP      r0,#0
00008a  d1e9              BNE      |L9.96|
;;;268    
;;;269    	pos.X = 0;
;;;270    	pos.Y = 80;
00008c  2050              MOVS     r0,#0x50
;;;271    
;;;272    	for (c = ' '; c <= '~'; c++) {
00008e  2420              MOVS     r4,#0x20
;;;273    		LCD_Text_PrintChar(&pos, c);
;;;274    		pos.X += CHAR_WIDTH + 2;
;;;275    		if (pos.X >= LCD_WIDTH - CHAR_WIDTH) {
000090  27f0              MOVS     r7,#0xf0
000092  9600              STR      r6,[sp,#0]
000094  9001              STR      r0,[sp,#4]
                  |L9.150|
000096  b2e1              UXTB     r1,r4                 ;273
000098  4668              MOV      r0,sp                 ;273
00009a  f7fffffe          BL       LCD_Text_PrintChar
00009e  7828              LDRB     r0,[r5,#0]            ;274  ; G_LCD_char_width
0000a0  9900              LDR      r1,[sp,#0]            ;274
0000a2  1c82              ADDS     r2,r0,#2              ;274
0000a4  1889              ADDS     r1,r1,r2              ;274
0000a6  1a38              SUBS     r0,r7,r0
0000a8  9100              STR      r1,[sp,#0]
0000aa  4281              CMP      r1,r0
0000ac  d30b              BCC      |L9.198|
;;;276    			pos.X = 0;
;;;277    			pos.Y += CHAR_HEIGHT + 2;
0000ae  9600              STR      r6,[sp,#0]
0000b0  7868              LDRB     r0,[r5,#1]  ; G_LCD_char_height
0000b2  9901              LDR      r1,[sp,#4]
0000b4  1c82              ADDS     r2,r0,#2
0000b6  1889              ADDS     r1,r1,r2
;;;278    			if (pos.Y >= LCD_HEIGHT - CHAR_HEIGHT) {
0000b8  22ff              MOVS     r2,#0xff
0000ba  3241              ADDS     r2,r2,#0x41
0000bc  1a10              SUBS     r0,r2,r0
0000be  9101              STR      r1,[sp,#4]
0000c0  4281              CMP      r1,r0
0000c2  d300              BCC      |L9.198|
;;;279    				pos.Y = 0;
0000c4  9601              STR      r6,[sp,#4]
                  |L9.198|
0000c6  1c64              ADDS     r4,r4,#1
0000c8  2c7e              CMP      r4,#0x7e              ;272
0000ca  d9e4              BLS      |L9.150|
;;;280    			}
;;;281    		}
;;;282    	}
;;;283    }
0000cc  b005              ADD      sp,sp,#0x14
0000ce  bdf0              POP      {r4-r7,pc}
                  |L9.208|
0000d0  7829              LDRB     r1,[r5,#0]  ; G_LCD_char_width
0000d2  9800              LDR      r0,[sp,#0]
0000d4  1840              ADDS     r0,r0,r1
0000d6  9000              STR      r0,[sp,#0]
0000d8  e7ad              B        |L9.54|
                  |L9.218|
0000da  7829              LDRB     r1,[r5,#0]  ; G_LCD_char_width
0000dc  9802              LDR      r0,[sp,#8]
0000de  1840              ADDS     r0,r0,r1
0000e0  9002              STR      r0,[sp,#8]
0000e2  e7cf              B        |L9.132|
                          ENDP

                  |L9.228|
                          DCD      ||.data||
                  |L9.232|
0000e8  54657374          DCB      "Testing",0
0000ec  696e6700
                  |L9.240|
                          DCD      ||.data||+0x5
                  |L9.244|
0000f4  312b4143          DCB      "1+ACDVZ_af",0
0000f8  44565a5f
0000fc  616600  
0000ff  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  G_LCD_char_width
000000  00                DCB      0x00
                  G_LCD_char_height
000001  00                DCB      0x00
                  ||fg||
000002  0000              DCB      0x00,0x00
000004  00                DCB      0x00
                  ||bg||
000005  000000            DCB      0x00,0x00,0x00
                  font
                          DCD      0x00000000
                  font_header
                          DCD      0x00000000
                  glyph_index
                          DCD      0x00000000
