; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\lcd_text.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\lcd_text.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\lcd_text.crf Source\LCD\LCD_text.c]
                          THUMB

                          AREA ||i.Bit_Reverse_Byte||, CODE, READONLY, ALIGN=1

                  Bit_Reverse_Byte PROC
;;;21     
;;;22     uint8_t Bit_Reverse_Byte(uint8_t v) {
000000  2207              MOVS     r2,#7
;;;23     // http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious
;;;24     	// v: input bits to be reversed
;;;25     	int r = v;										// r will be reversed bits of v; first get LSB of v
;;;26     	int s = sizeof(v) * 8 - 1;		// extra shift needed at end
;;;27     
;;;28     	for (v >>= 1; v; v >>= 1) {
000002  0841              LSRS     r1,r0,#1
000004  e005              B        |L1.18|
                  |L1.6|
;;;29     		r <<= 1;
000006  0043              LSLS     r3,r0,#1
;;;30     		r |= v & 1;
000008  07c8              LSLS     r0,r1,#31
00000a  0fc0              LSRS     r0,r0,#31
00000c  4318              ORRS     r0,r0,r3
00000e  0849              LSRS     r1,r1,#1              ;28
000010  1e52              SUBS     r2,r2,#1              ;28
                  |L1.18|
000012  2900              CMP      r1,#0                 ;28
000014  d1f7              BNE      |L1.6|
;;;31     		s--;
;;;32     	}
;;;33     	r <<= s;											// shift when v's highest bits are zero
000016  4090              LSLS     r0,r0,r2
;;;34     	return r;
000018  b2c0              UXTB     r0,r0
;;;35     }
00001a  4770              BX       lr
;;;36     
                          ENDP


                          AREA ||i.LCD_Erase||, CODE, READONLY, ALIGN=2

                  LCD_Erase PROC
;;;45     
;;;46     void LCD_Erase(void) {
000000  b510              PUSH     {r4,lr}
;;;47     	LCD_Fill_Buffer(&bg);
000002  4802              LDR      r0,|L2.12|
000004  f7fffffe          BL       LCD_Fill_Buffer
;;;48     }
000008  bd10              POP      {r4,pc}
;;;49     
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.data||+0x5

                          AREA ||i.LCD_Text_GetGlyphWidth||, CODE, READONLY, ALIGN=2

                  LCD_Text_GetGlyphWidth PROC
;;;85     
;;;86     uint8_t LCD_Text_GetGlyphWidth(char ch) {
000000  4904              LDR      r1,|L3.20|
;;;87     	uint8_t glyph_index_entry;
;;;88     
;;;89     	glyph_index_entry = ch - font_header->FirstChar;
000002  68ca              LDR      r2,[r1,#0xc]  ; font_header
;;;90     	return glyph_index[glyph_index_entry].Width;
000004  6909              LDR      r1,[r1,#0x10]  ; glyph_index
000006  7892              LDRB     r2,[r2,#2]            ;89
000008  1a80              SUBS     r0,r0,r2              ;89
00000a  0600              LSLS     r0,r0,#24             ;89
00000c  0d80              LSRS     r0,r0,#22
00000e  5c08              LDRB     r0,[r1,r0]
;;;91     }
000010  4770              BX       lr
;;;92     void LCD_Text_PrintChar(PT_T * pos, char ch) {
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      ||.data||

                          AREA ||i.LCD_Text_Init||, CODE, READONLY, ALIGN=2

                  LCD_Text_Init PROC
;;;49     
;;;50     void LCD_Text_Init(uint8_t font_num) {
000000  480b              LDR      r0,|L4.48|
;;;51     // font_num is ignored currently  
;;;52     #if 0														// Code for multiple fonts not working yet
;;;53     	font = fonts[font_num];
;;;54     	G_LCD_char_width = char_widths[font_num];
;;;55     	G_LCD_char_height = char_heights[font_num];
;;;56     #endif
;;;57     
;;;58     // // This code is not working
;;;59     //  font = Lucida_Console20x31;
;;;60     //  G_LCD_char_width = 20;
;;;61     //  G_LCD_char_height = 31;
;;;62     
;;;63     #if 1														// This code is working
;;;64     	font = Lucida_Console12x19;
000002  490a              LDR      r1,|L4.44|
;;;65     	G_LCD_char_width = 12;
000004  220c              MOVS     r2,#0xc
000006  6081              STR      r1,[r0,#8]  ; font
000008  7002              STRB     r2,[r0,#0]
;;;66     	G_LCD_char_height = 19;
00000a  2213              MOVS     r2,#0x13
00000c  7042              STRB     r2,[r0,#1]
;;;67     #else
;;;68     	font = Lucida_Console8x13;
;;;69     	G_LCD_char_width = 8;
;;;70     	G_LCD_char_height = 13;
;;;71     #endif
;;;72     
;;;73     	font_header = (FONT_HEADER_T *) font;
00000e  60c1              STR      r1,[r0,#0xc]  ; font_header
000010  3108              ADDS     r1,r1,#8
;;;74     	glyph_index = (GLYPH_INDEX_T *) (font + sizeof(FONT_HEADER_T));
;;;75     
;;;76     	// Set default FG and BG colors
;;;77     	fg.R = 255;
000012  6101              STR      r1,[r0,#0x10]  ; glyph_index
000014  4906              LDR      r1,|L4.48|
000016  20ff              MOVS     r0,#0xff
000018  1c89              ADDS     r1,r1,#2
00001a  7008              STRB     r0,[r1,#0]
;;;78     	fg.G = 255;
00001c  7048              STRB     r0,[r1,#1]
;;;79     	fg.B = 0;
00001e  2000              MOVS     r0,#0
000020  7088              STRB     r0,[r1,#2]
;;;80     
;;;81     	bg.R = 0;
000022  1cc9              ADDS     r1,r1,#3
000024  7008              STRB     r0,[r1,#0]
;;;82     	bg.G = 0;
000026  7048              STRB     r0,[r1,#1]
;;;83     	bg.B = 0;
000028  7088              STRB     r0,[r1,#2]
;;;84     }
00002a  4770              BX       lr
;;;85     
                          ENDP

                  |L4.44|
                          DCD      Lucida_Console12x19
                  |L4.48|
                          DCD      ||.data||

                          AREA ||i.LCD_Text_PrintChar||, CODE, READONLY, ALIGN=2

                  LCD_Text_PrintChar PROC
;;;91     }
;;;92     void LCD_Text_PrintChar(PT_T * pos, char ch) {
000000  b5f0              PUSH     {r4-r7,lr}
;;;93     	uint8_t glyph_index_entry;
;;;94     	const uint8_t *glyph_data;		// start of the data
;;;95     #if BITS_PER_PIXEL == 1					// Copy bitmap byte directly
;;;96     	PT_T cur_pos;
;;;97     #endif
;;;98     	PT_T end_pos;
;;;99     	COLOR_T *pixel_color;
;;;100    	uint8_t bitmap_byte;
;;;101    	uint8_t glyph_width, x_bm;
;;;102    	uint32_t offset;
;;;103    	uint32_t row, col, num_pixels;
;;;104    
;;;105    	glyph_index_entry = ch - font_header->FirstChar;
000002  4c5e              LDR      r4,|L5.380|
000004  b085              SUB      sp,sp,#0x14           ;92
000006  68e2              LDR      r2,[r4,#0xc]  ; font_header
000008  7892              LDRB     r2,[r2,#2]
00000a  1a89              SUBS     r1,r1,r2
00000c  0609              LSLS     r1,r1,#24
;;;106    	glyph_width = glyph_index[glyph_index_entry].Width;
00000e  6922              LDR      r2,[r4,#0x10]  ; glyph_index
000010  0d89              LSRS     r1,r1,#22
000012  5851              LDR      r1,[r2,r1]
;;;107    	offset = glyph_index[glyph_index_entry].Offset;
;;;108    	glyph_data = &(font[offset]);
000014  68a2              LDR      r2,[r4,#8]  ; font
000016  b2ce              UXTB     r6,r1                 ;106
000018  0a09              LSRS     r1,r1,#8              ;107
00001a  1857              ADDS     r7,r2,r1
;;;109    
;;;110    #if BITS_PER_PIXEL == 1					// Copy bitmap byte directly
;;;111    	cur_pos.Y = pos->Y;
;;;112    
;;;113    	for (row = 0; row < CHAR_HEIGHT; row++) {
;;;114    		cur_pos.X = pos->X;
;;;115    		x_bm = 0;										// x position within glyph bitmap, can span bytes 
;;;116    		do {
;;;117    			bitmap_byte = *glyph_data;
;;;118    			bitmap_byte = Bit_Reverse_Byte(bitmap_byte);
;;;119    			num_pixels = MIN(8, glyph_width - x_bm);
;;;120    			if ((cur_pos.X & 0x07) == 0) {	// Glyph is byte-aligned, so ready to plot
;;;121    				LCD_Plot_Packed_Pixels(bitmap_byte, (&cur_pos));
;;;122    				// LCD_Refresh();
;;;123    				x_bm += num_pixels;
;;;124    			} else {									// Split and align as needed
;;;125    				LCD_Plot_Packed_Pixels_Unaligned(bitmap_byte,
;;;126    																				 (cur_pos.X & 0x07),
;;;127    																				 (&cur_pos));
;;;128    				// LCD_Refresh();
;;;129    				x_bm += num_pixels;
;;;130    			}
;;;131    			cur_pos.X += num_pixels;
;;;132    			glyph_data++;							// Advance to next byte of glyph data
;;;133    		} while (x_bm < glyph_width);
;;;134    		while (x_bm < CHAR_WIDTH) {
;;;135    			// fill in rest of cell with background color for narrow glyphs
;;;136    			LCD_Plot_Pixel(&cur_pos, &bg);
;;;137    			// LCD_Refresh();
;;;138    			x_bm++;
;;;139    			cur_pos.X++;
;;;140    		}
;;;141    		cur_pos.Y++;
;;;142    	}
;;;143    	LCD_Refresh();
;;;144    #else														// BPP != 1, so expand to given color
;;;145    	end_pos.X = pos->X + CHAR_WIDTH - 1;
00001c  7821              LDRB     r1,[r4,#0]  ; G_LCD_char_width
00001e  6802              LDR      r2,[r0,#0]
000020  1e49              SUBS     r1,r1,#1
000022  1851              ADDS     r1,r2,r1
;;;146    	end_pos.Y = pos->Y + CHAR_HEIGHT - 1;
000024  9102              STR      r1,[sp,#8]
000026  7861              LDRB     r1,[r4,#1]  ; G_LCD_char_height
000028  6842              LDR      r2,[r0,#4]
00002a  1e49              SUBS     r1,r1,#1
00002c  1851              ADDS     r1,r2,r1
;;;147    
;;;148    	LCD_Start_Rectangle(pos, &end_pos);
00002e  9103              STR      r1,[sp,#0xc]
000030  a902              ADD      r1,sp,#8
000032  f7fffffe          BL       LCD_Start_Rectangle
;;;149    
;;;150    	for (row = 0; row < CHAR_HEIGHT; row++) {
000036  2000              MOVS     r0,#0
000038  e098              B        |L5.364|
                  |L5.58|
;;;151    		x_bm = 0;										// x position within glyph bitmap, can span bytes 
00003a  2400              MOVS     r4,#0
                  |L5.60|
;;;152    		do {
;;;153    			bitmap_byte = *glyph_data;
00003c  783d              LDRB     r5,[r7,#0]
;;;154    
;;;155    			// Special cases with run starting at LSB 
;;;156    			// Up to 8 bit run
;;;157    			if (bitmap_byte == 0x00) {
00003e  2d00              CMP      r5,#0
000040  d015              BEQ      |L5.110|
;;;158    				num_pixels = MIN(8, glyph_width - x_bm);
;;;159    				LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;160    				x_bm += num_pixels;
;;;161    			} else if (bitmap_byte == 0xff) {
000042  2dff              CMP      r5,#0xff
000044  d01b              BEQ      |L5.126|
;;;162    				num_pixels = MIN(8, glyph_width - x_bm);
;;;163    				LCD_Write_Rectangle_Pixel(&fg, num_pixels);
;;;164    				x_bm += num_pixels;
;;;165    			} else {
;;;166    				col = 0;
000046  2000              MOVS     r0,#0
;;;167    				num_pixels = 0;
;;;168    				if ((bitmap_byte & 0x7f) == 0) {	// Up to 7 bit run
000048  9001              STR      r0,[sp,#4]
00004a  0668              LSLS     r0,r5,#25
00004c  d023              BEQ      |L5.150|
;;;169    					num_pixels = MIN(7, glyph_width - x_bm);
;;;170    					LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;171    				} else if ((bitmap_byte & 0x7f) == 0x7f) {
00004e  43e8              MVNS     r0,r5
000050  0641              LSLS     r1,r0,#25
000052  d02a              BEQ      |L5.170|
;;;172    					num_pixels = MIN(7, glyph_width - x_bm);
;;;173    					LCD_Write_Rectangle_Pixel(&fg, num_pixels);
;;;174    				} else if ((bitmap_byte & 0x3f) == 0) {	// Up to 6 bit run
000054  06a9              LSLS     r1,r5,#26
000056  d03d              BEQ      |L5.212|
;;;175    					num_pixels = MIN(6, glyph_width - x_bm);
;;;176    					LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;177    				} else if ((bitmap_byte & 0x3f) == 0x3f) {
000058  0681              LSLS     r1,r0,#26
00005a  d044              BEQ      |L5.230|
;;;178    					num_pixels = MIN(6, glyph_width - x_bm);
;;;179    					LCD_Write_Rectangle_Pixel(&fg, num_pixels);
;;;180    				} else if ((bitmap_byte & 0x1f) == 0) {	// Up to 5 bit run
00005c  06e9              LSLS     r1,r5,#27
00005e  d04d              BEQ      |L5.252|
;;;181    					num_pixels = MIN(5, glyph_width - x_bm);
;;;182    					LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;183    				} else if ((bitmap_byte & 0x1f) == 0x1f) {
000060  06c1              LSLS     r1,r0,#27
000062  d050              BEQ      |L5.262|
;;;184    					num_pixels = MIN(5, glyph_width - x_bm);
;;;185    					LCD_Write_Rectangle_Pixel(&fg, num_pixels);
;;;186    				} else if ((bitmap_byte & 0x0f) == 0) {	// Up to 4 bit run
000064  0729              LSLS     r1,r5,#28
000066  d053              BEQ      |L5.272|
;;;187    					num_pixels = MIN(4, glyph_width - x_bm);
;;;188    					LCD_Write_Rectangle_Pixel(&bg, num_pixels);
;;;189    				} else if ((bitmap_byte & 0x0f) == 0x0f) {
000068  0700              LSLS     r0,r0,#28
00006a  d056              BEQ      |L5.282|
00006c  e06a              B        |L5.324|
                  |L5.110|
00006e  1b35              SUBS     r5,r6,r4              ;158
000070  2d08              CMP      r5,#8                 ;158
000072  dd00              BLE      |L5.118|
000074  2508              MOVS     r5,#8                 ;158
                  |L5.118|
000076  4841              LDR      r0,|L5.380|
000078  4629              MOV      r1,r5                 ;159
00007a  1d40              ADDS     r0,r0,#5              ;159
00007c  e006              B        |L5.140|
                  |L5.126|
00007e  1b35              SUBS     r5,r6,r4              ;162
000080  2d08              CMP      r5,#8                 ;162
000082  dd00              BLE      |L5.134|
000084  2508              MOVS     r5,#8                 ;162
                  |L5.134|
000086  483d              LDR      r0,|L5.380|
000088  4629              MOV      r1,r5                 ;163
00008a  1c80              ADDS     r0,r0,#2              ;163
                  |L5.140|
00008c  f7fffffe          BL       LCD_Write_Rectangle_Pixel
000090  1960              ADDS     r0,r4,r5              ;164
000092  b2c4              UXTB     r4,r0                 ;164
000094  e05b              B        |L5.334|
                  |L5.150|
000096  1b30              SUBS     r0,r6,r4              ;169
000098  2807              CMP      r0,#7                 ;169
00009a  dd01              BLE      |L5.160|
00009c  2007              MOVS     r0,#7                 ;169
00009e  e01d              B        |L5.220|
                  |L5.160|
0000a0  4601              MOV      r1,r0                 ;170
0000a2  9000              STR      r0,[sp,#0]            ;170
0000a4  4835              LDR      r0,|L5.380|
0000a6  1d40              ADDS     r0,r0,#5              ;170
0000a8  e008              B        |L5.188|
                  |L5.170|
0000aa  1b30              SUBS     r0,r6,r4              ;172
0000ac  2807              CMP      r0,#7                 ;172
0000ae  dd01              BLE      |L5.180|
0000b0  2007              MOVS     r0,#7                 ;172
0000b2  e01c              B        |L5.238|
                  |L5.180|
0000b4  4601              MOV      r1,r0                 ;173
0000b6  9000              STR      r0,[sp,#0]            ;173
0000b8  4830              LDR      r0,|L5.380|
0000ba  1c80              ADDS     r0,r0,#2              ;173
                  |L5.188|
;;;190    					num_pixels = MIN(4, glyph_width - x_bm);
;;;191    					LCD_Write_Rectangle_Pixel(&fg, num_pixels);
0000bc  f7fffffe          BL       LCD_Write_Rectangle_Pixel
;;;192    				}
;;;193    				if (num_pixels > 0) {
0000c0  9800              LDR      r0,[sp,#0]
0000c2  2800              CMP      r0,#0
0000c4  d03e              BEQ      |L5.324|
                  |L5.198|
;;;194    					x_bm += num_pixels;		// Advance position in glyph bitmap
0000c6  9800              LDR      r0,[sp,#0]
0000c8  1820              ADDS     r0,r4,r0
0000ca  b2c4              UXTB     r4,r0
;;;195    					col += num_pixels;		// Advance position withing glyph bitmap byte
0000cc  9800              LDR      r0,[sp,#0]
;;;196    					bitmap_byte >>= num_pixels;
0000ce  9001              STR      r0,[sp,#4]
0000d0  40c5              LSRS     r5,r5,r0
0000d2  e037              B        |L5.324|
                  |L5.212|
0000d4  1b30              SUBS     r0,r6,r4              ;175
0000d6  2806              CMP      r0,#6                 ;175
0000d8  dde2              BLE      |L5.160|
0000da  2006              MOVS     r0,#6                 ;175
                  |L5.220|
0000dc  4601              MOV      r1,r0                 ;170
0000de  9000              STR      r0,[sp,#0]            ;170
0000e0  4826              LDR      r0,|L5.380|
0000e2  1d40              ADDS     r0,r0,#5              ;170
0000e4  e007              B        |L5.246|
                  |L5.230|
0000e6  1b30              SUBS     r0,r6,r4              ;178
0000e8  2806              CMP      r0,#6                 ;178
0000ea  dde3              BLE      |L5.180|
0000ec  2006              MOVS     r0,#6                 ;178
                  |L5.238|
0000ee  4601              MOV      r1,r0                 ;173
0000f0  9000              STR      r0,[sp,#0]            ;173
0000f2  4822              LDR      r0,|L5.380|
0000f4  1c80              ADDS     r0,r0,#2              ;173
                  |L5.246|
0000f6  f7fffffe          BL       LCD_Write_Rectangle_Pixel
0000fa  e7e4              B        |L5.198|
                  |L5.252|
0000fc  1b30              SUBS     r0,r6,r4              ;181
0000fe  2805              CMP      r0,#5                 ;181
000100  ddce              BLE      |L5.160|
000102  2005              MOVS     r0,#5                 ;181
000104  e7ea              B        |L5.220|
                  |L5.262|
000106  1b30              SUBS     r0,r6,r4              ;184
000108  2805              CMP      r0,#5                 ;184
00010a  ddd3              BLE      |L5.180|
00010c  2005              MOVS     r0,#5                 ;184
00010e  e7ee              B        |L5.238|
                  |L5.272|
000110  1b30              SUBS     r0,r6,r4              ;187
000112  2804              CMP      r0,#4                 ;187
000114  ddc4              BLE      |L5.160|
000116  2004              MOVS     r0,#4                 ;187
000118  e7e0              B        |L5.220|
                  |L5.282|
00011a  1b30              SUBS     r0,r6,r4              ;190
00011c  2804              CMP      r0,#4                 ;190
00011e  ddc9              BLE      |L5.180|
000120  2004              MOVS     r0,#4                 ;190
000122  e7e4              B        |L5.238|
                  |L5.292|
;;;197    				}
;;;198    				for (; (x_bm < glyph_width) && (col < 8); col++) {	// Remaining pixels in byte
;;;199    					if (bitmap_byte & 0x01)	// if pixel is to be set
000124  07e8              LSLS     r0,r5,#31
000126  d002              BEQ      |L5.302|
;;;200    						pixel_color = &fg;
000128  4814              LDR      r0,|L5.380|
00012a  1c80              ADDS     r0,r0,#2
00012c  e001              B        |L5.306|
                  |L5.302|
;;;201    					else
;;;202    						pixel_color = &bg;
00012e  4813              LDR      r0,|L5.380|
000130  1d40              ADDS     r0,r0,#5
                  |L5.306|
;;;203    					LCD_Write_Rectangle_Pixel(pixel_color, 1);
000132  2101              MOVS     r1,#1
000134  f7fffffe          BL       LCD_Write_Rectangle_Pixel
;;;204    					bitmap_byte >>= 1;
000138  1c64              ADDS     r4,r4,#1
00013a  9801              LDR      r0,[sp,#4]            ;198
00013c  086d              LSRS     r5,r5,#1
00013e  1c40              ADDS     r0,r0,#1              ;198
;;;205    					x_bm++;
000140  b2e4              UXTB     r4,r4
000142  9001              STR      r0,[sp,#4]            ;198
                  |L5.324|
000144  42b4              CMP      r4,r6                 ;198
000146  d202              BCS      |L5.334|
000148  9801              LDR      r0,[sp,#4]            ;198
00014a  2808              CMP      r0,#8                 ;198
00014c  d3ea              BCC      |L5.292|
                  |L5.334|
00014e  1c7f              ADDS     r7,r7,#1              ;198
;;;206    				}
;;;207    			}
;;;208    			glyph_data++;							// Advance to next byte of glyph data
;;;209    		} while (x_bm < glyph_width);
000150  42b4              CMP      r4,r6
000152  d200              BCS      |L5.342|
000154  e772              B        |L5.60|
                  |L5.342|
;;;210    		if (x_bm < CHAR_WIDTH) {
000156  4809              LDR      r0,|L5.380|
000158  7800              LDRB     r0,[r0,#0]  ; G_LCD_char_width
00015a  4284              CMP      r4,r0
00015c  d204              BCS      |L5.360|
;;;211    			// fill in rest of cell with background color for narrow glyphs
;;;212    			LCD_Write_Rectangle_Pixel(&bg, CHAR_WIDTH - x_bm);
00015e  1b01              SUBS     r1,r0,r4
000160  4806              LDR      r0,|L5.380|
000162  1d40              ADDS     r0,r0,#5
000164  f7fffffe          BL       LCD_Write_Rectangle_Pixel
                  |L5.360|
000168  9804              LDR      r0,[sp,#0x10]         ;150
00016a  1c40              ADDS     r0,r0,#1              ;150
                  |L5.364|
00016c  4903              LDR      r1,|L5.380|
00016e  9004              STR      r0,[sp,#0x10]         ;150
000170  7849              LDRB     r1,[r1,#1]            ;150  ; G_LCD_char_height
000172  4288              CMP      r0,r1                 ;150
000174  d200              BCS      |L5.376|
000176  e760              B        |L5.58|
                  |L5.376|
;;;213    		}
;;;214    	}
;;;215    #endif													// BPP != 1
;;;216    }
000178  b005              ADD      sp,sp,#0x14
00017a  bdf0              POP      {r4-r7,pc}
;;;217    
                          ENDP

                  |L5.380|
                          DCD      ||.data||

                          AREA ||i.LCD_Text_PrintStr||, CODE, READONLY, ALIGN=2

                  LCD_Text_PrintStr PROC
;;;217    
;;;218    void LCD_Text_PrintStr(PT_T * pos, char *str) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;219    	while (*str) {
;;;220    		LCD_Text_PrintChar(pos, *str);
;;;221    #if FORCE_MONOSPACE
;;;222    		pos->X += CHAR_WIDTH;				// forces monospacing for fonts
;;;223    #else
;;;224    		if (*str == ' ')
;;;225    			pos->X += CHAR_WIDTH;			// Increase width for space character!
000006  4e0b              LDR      r6,|L6.52|
;;;226    		else
;;;227    			pos->X += LCD_Text_GetGlyphWidth(*str) + 1;	// add a pixel of padding 
;;;228    #endif
;;;229    		str++;
000008  e00c              B        |L6.36|
                  |L6.10|
00000a  4628              MOV      r0,r5                 ;220
00000c  f7fffffe          BL       LCD_Text_PrintChar
000010  7820              LDRB     r0,[r4,#0]            ;224
000012  2820              CMP      r0,#0x20              ;224
000014  d00a              BEQ      |L6.44|
000016  f7fffffe          BL       LCD_Text_GetGlyphWidth
00001a  6829              LDR      r1,[r5,#0]            ;227
00001c  1c40              ADDS     r0,r0,#1              ;227
                  |L6.30|
00001e  1840              ADDS     r0,r0,r1              ;227
000020  1c64              ADDS     r4,r4,#1              ;227
000022  6028              STR      r0,[r5,#0]            ;227
                  |L6.36|
000024  7821              LDRB     r1,[r4,#0]            ;219
000026  2900              CMP      r1,#0                 ;219
000028  d1ef              BNE      |L6.10|
;;;230    	}
;;;231    }
00002a  bd70              POP      {r4-r6,pc}
                  |L6.44|
00002c  7831              LDRB     r1,[r6,#0]            ;225  ; G_LCD_char_width
00002e  6828              LDR      r0,[r5,#0]            ;225
000030  e7f5              B        |L6.30|
;;;232    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      ||.data||

                          AREA ||i.LCD_Text_PrintStr_RC||, CODE, READONLY, ALIGN=2

                  LCD_Text_PrintStr_RC PROC
;;;232    
;;;233    void LCD_Text_PrintStr_RC(uint8_t row, uint8_t col, char *str) {
000000  b57c              PUSH     {r2-r6,lr}
;;;234    	PT_T pos;
;;;235    	pos.X = COL_TO_X(col);
000002  4d0e              LDR      r5,|L7.60|
000004  4614              MOV      r4,r2                 ;233
000006  782a              LDRB     r2,[r5,#0]  ; G_LCD_char_width
000008  4351              MULS     r1,r2,r1
;;;236    	pos.Y = ROW_TO_Y(row);
00000a  9100              STR      r1,[sp,#0]
00000c  7869              LDRB     r1,[r5,#1]  ; G_LCD_char_height
00000e  4348              MULS     r0,r1,r0
000010  9001              STR      r0,[sp,#4]            ;233
000012  e00c              B        |L7.46|
                  |L7.20|
;;;237    	while (*str) {
;;;238    		LCD_Text_PrintChar(&pos, *str);
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       LCD_Text_PrintChar
;;;239    #if FORCE_MONOSPACE
;;;240    		pos.X += CHAR_WIDTH;				// forces monospacing for fonts
;;;241    #else
;;;242    		if (*str == ' ')
00001a  7820              LDRB     r0,[r4,#0]
00001c  2820              CMP      r0,#0x20
00001e  d00a              BEQ      |L7.54|
;;;243    			pos.X += CHAR_WIDTH;			// Increase width for space character!
;;;244    		else
;;;245    			pos.X += LCD_Text_GetGlyphWidth(*str) + 1;	// add a pixel of padding 
000020  f7fffffe          BL       LCD_Text_GetGlyphWidth
000024  9900              LDR      r1,[sp,#0]
000026  1c40              ADDS     r0,r0,#1
                  |L7.40|
000028  1840              ADDS     r0,r0,r1
00002a  1c64              ADDS     r4,r4,#1
00002c  9000              STR      r0,[sp,#0]
                  |L7.46|
00002e  7821              LDRB     r1,[r4,#0]            ;237
000030  2900              CMP      r1,#0                 ;237
000032  d1ef              BNE      |L7.20|
;;;246    #endif
;;;247    		str++;
;;;248    	}
;;;249    }
000034  bd7c              POP      {r2-r6,pc}
                  |L7.54|
000036  7829              LDRB     r1,[r5,#0]            ;243  ; G_LCD_char_width
000038  9800              LDR      r0,[sp,#0]            ;243
00003a  e7f5              B        |L7.40|
;;;250    
                          ENDP

                  |L7.60|
                          DCD      ||.data||

                          AREA ||i.LCD_Text_Set_Colors||, CODE, READONLY, ALIGN=2

                  LCD_Text_Set_Colors PROC
;;;36     
;;;37     void LCD_Text_Set_Colors(COLOR_T * foreground, COLOR_T * background) {
000000  4a07              LDR      r2,|L8.32|
;;;38     	fg.R = foreground->R;
000002  7803              LDRB     r3,[r0,#0]
000004  7013              STRB     r3,[r2,#0]
;;;39     	fg.G = foreground->G;
000006  7843              LDRB     r3,[r0,#1]
000008  7053              STRB     r3,[r2,#1]
;;;40     	fg.B = foreground->B;
00000a  7880              LDRB     r0,[r0,#2]
00000c  7090              STRB     r0,[r2,#2]
;;;41     	bg.R = background->R;
00000e  4804              LDR      r0,|L8.32|
000010  780a              LDRB     r2,[r1,#0]
000012  1cc0              ADDS     r0,r0,#3
000014  7002              STRB     r2,[r0,#0]
;;;42     	bg.G = background->G;
000016  784a              LDRB     r2,[r1,#1]
000018  7042              STRB     r2,[r0,#1]
;;;43     	bg.B = background->B;
00001a  7889              LDRB     r1,[r1,#2]
00001c  7081              STRB     r1,[r0,#2]
;;;44     }
00001e  4770              BX       lr
;;;45     
                          ENDP

                  |L8.32|
                          DCD      ||.data||+0x2

                          AREA ||i.LCD_Text_Test||, CODE, READONLY, ALIGN=2

                  LCD_Text_Test PROC
;;;250    
;;;251    void LCD_Text_Test(void) {
000000  b5fe              PUSH     {r1-r7,lr}
;;;252    	PT_T pos;
;;;253    	uint32_t c;
;;;254    	int i;
;;;255    
;;;256    	pos.X = 0;
000002  2500              MOVS     r5,#0
;;;257    	pos.Y = 0;
000004  9500              STR      r5,[sp,#0]
;;;258    
;;;259    	for (i = 0; i < 100; i++) {
000006  462c              MOV      r4,r5
000008  9501              STR      r5,[sp,#4]
                  |L9.10|
;;;260    		LCD_Text_PrintStr(&pos, "Testing");
00000a  a11c              ADR      r1,|L9.124|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       LCD_Text_PrintStr
;;;261    		LCD_Refresh();
000012  f7fffffe          BL       LCD_Refresh
;;;262    		Delay(10);
000016  200a              MOVS     r0,#0xa
000018  f7fffffe          BL       Delay
00001c  4819              LDR      r0,|L9.132|
00001e  f7fffffe          BL       LCD_Fill_Buffer
;;;263    		LCD_Erase();
;;;264    		pos.X = pos.Y = i++;
000022  9401              STR      r4,[sp,#4]
000024  9400              STR      r4,[sp,#0]
000026  1ca4              ADDS     r4,r4,#2
000028  2c64              CMP      r4,#0x64              ;259
00002a  dbee              BLT      |L9.10|
;;;265    	}
;;;266    
;;;267    	LCD_Text_PrintStr_RC(0, 0, "1+ACDVZ_af");
00002c  2100              MOVS     r1,#0
00002e  a216              ADR      r2,|L9.136|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       LCD_Text_PrintStr_RC
;;;268    
;;;269    	pos.X = 0;
;;;270    	pos.Y = 80;
000036  2050              MOVS     r0,#0x50
;;;271    
;;;272    	for (c = ' '; c <= '~'; c++) {
;;;273    		LCD_Text_PrintChar(&pos, c);
;;;274    		pos.X += CHAR_WIDTH + 2;
000038  4e12              LDR      r6,|L9.132|
00003a  2420              MOVS     r4,#0x20              ;272
;;;275    		if (pos.X >= LCD_WIDTH - CHAR_WIDTH) {
00003c  27f0              MOVS     r7,#0xf0
00003e  1f76              SUBS     r6,r6,#5              ;274
000040  9500              STR      r5,[sp,#0]            ;274
000042  9001              STR      r0,[sp,#4]            ;274
                  |L9.68|
000044  b2e1              UXTB     r1,r4                 ;273
000046  4668              MOV      r0,sp                 ;273
000048  f7fffffe          BL       LCD_Text_PrintChar
00004c  7830              LDRB     r0,[r6,#0]            ;274  ; G_LCD_char_width
00004e  9900              LDR      r1,[sp,#0]            ;274
000050  1c82              ADDS     r2,r0,#2              ;274
000052  1889              ADDS     r1,r1,r2              ;274
000054  1a38              SUBS     r0,r7,r0
000056  9100              STR      r1,[sp,#0]
000058  4281              CMP      r1,r0
00005a  d30b              BCC      |L9.116|
;;;276    			pos.X = 0;
;;;277    			pos.Y += CHAR_HEIGHT + 2;
00005c  9500              STR      r5,[sp,#0]
00005e  7870              LDRB     r0,[r6,#1]  ; G_LCD_char_height
000060  9901              LDR      r1,[sp,#4]
000062  1c82              ADDS     r2,r0,#2
000064  1889              ADDS     r1,r1,r2
;;;278    			if (pos.Y >= LCD_HEIGHT - CHAR_HEIGHT) {
000066  22ff              MOVS     r2,#0xff
000068  3241              ADDS     r2,r2,#0x41
00006a  1a10              SUBS     r0,r2,r0
00006c  9101              STR      r1,[sp,#4]
00006e  4281              CMP      r1,r0
000070  d300              BCC      |L9.116|
;;;279    				pos.Y = 0;
000072  9501              STR      r5,[sp,#4]
                  |L9.116|
000074  1c64              ADDS     r4,r4,#1
000076  2c7e              CMP      r4,#0x7e              ;272
000078  d9e4              BLS      |L9.68|
;;;280    			}
;;;281    		}
;;;282    	}
;;;283    }
00007a  bdfe              POP      {r1-r7,pc}
                          ENDP

                  |L9.124|
00007c  54657374          DCB      "Testing",0
000080  696e6700
                  |L9.132|
                          DCD      ||.data||+0x5
                  |L9.136|
000088  312b4143          DCB      "1+ACDVZ_af",0
00008c  44565a5f
000090  616600  
000093  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  G_LCD_char_width
000000  00                DCB      0x00
                  G_LCD_char_height
000001  00                DCB      0x00
                  ||fg||
000002  0000              DCB      0x00,0x00
000004  00                DCB      0x00
                  ||bg||
000005  000000            DCB      0x00,0x00,0x00
                  font
                          DCD      0x00000000
                  font_header
                          DCD      0x00000000
                  glyph_index
                          DCD      0x00000000
