; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\spi_io.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spi_io.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\spi_io.crf Source\ulibSD\spi_io.c]
                          THUMB

                          AREA ||i.Init_DMA_Transmit||, CODE, READONLY, ALIGN=2

                  Init_DMA_Transmit PROC
;;;20     
;;;21     void Init_DMA_Transmit(void){
000000  480f              LDR      r0,|L1.64|
;;;22     	
;;;23     	SIM->SCGC7 |= SIM_SCGC7_DMA_MASK;
000002  6801              LDR      r1,[r0,#0]
000004  1582              ASRS     r2,r0,#22
000006  4311              ORRS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;24     	SIM->SCGC6 |= SIM_SCGC6_DMAMUX_MASK;
00000a  480d              LDR      r0,|L1.64|
00000c  3840              SUBS     r0,r0,#0x40
00000e  6bc1              LDR      r1,[r0,#0x3c]
000010  2202              MOVS     r2,#2
000012  4311              ORRS     r1,r1,r2
000014  63c1              STR      r1,[r0,#0x3c]
;;;25     	
;;;26     	DMAMUX0->CHCFG[0] = 0;
000016  480b              LDR      r0,|L1.68|
000018  2100              MOVS     r1,#0
00001a  7001              STRB     r1,[r0,#0]
;;;27     	
;;;28     	DMA0->DMA[0].DCR = DMA_DCR_EINT_MASK | DMA_DCR_SINC_MASK | DMA_DCR_SSIZE(1) | DMA_DCR_DSIZE(1) | 
00001c  4a0b              LDR      r2,|L1.76|
00001e  490a              LDR      r1,|L1.72|
000020  60d1              STR      r1,[r2,#0xc]
000022  490b              LDR      r1,|L1.80|
000024  680a              LDR      r2,[r1,#0]
000026  2380              MOVS     r3,#0x80
000028  0a12              LSRS     r2,r2,#8
00002a  0212              LSLS     r2,r2,#8
00002c  431a              ORRS     r2,r2,r3
00002e  600a              STR      r2,[r1,#0]
000030  4a08              LDR      r2,|L1.84|
000032  2101              MOVS     r1,#1
000034  6011              STR      r1,[r2,#0]
000036  4a08              LDR      r2,|L1.88|
000038  6011              STR      r1,[r2,#0]
;;;29     	DMA_DCR_ERQ_MASK | DMA_DCR_CS_MASK;
;;;30     	
;;;31     	// Configure DMA ISR
;;;32     	NVIC_SetPriority(DMA0_IRQn, 2);
;;;33     	NVIC_ClearPendingIRQ(DMA0_IRQn);
;;;34     	NVIC_EnableIRQ(DMA0_IRQn);
;;;35     	
;;;36     	// Set DMA MUX channel to use SPI1 Transmit as Trigger
;;;37     	DMAMUX0->CHCFG[0] = DMAMUX_CHCFG_SOURCE(19);
00003a  2113              MOVS     r1,#0x13
00003c  7001              STRB     r1,[r0,#0]
;;;38     	
;;;39     }
00003e  4770              BX       lr
;;;40     
                          ENDP

                  |L1.64|
                          DCD      0x40048040
                  |L1.68|
                          DCD      0x40021000
                  |L1.72|
                          DCD      0xe0520000
                  |L1.76|
                          DCD      0x40008100
                  |L1.80|
                          DCD      0xe000e400
                  |L1.84|
                          DCD      0xe000e280
                  |L1.88|
                          DCD      0xe000e100

                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                  SPI_Init PROC
;;;53     
;;;54     void SPI_Init(void) {
000000  4810              LDR      r0,|L2.68|
;;;55     
;;;56     	SIM_SCGC5 |= SIM_SCGC5_PORTE_MASK;
000002  6b81              LDR      r1,[r0,#0x38]
000004  2201              MOVS     r2,#1
000006  0352              LSLS     r2,r2,#13
000008  4311              ORRS     r1,r1,r2
00000a  6381              STR      r1,[r0,#0x38]
;;;57     	/*
;;;58     	 *SPI1 Clock gate control. 1 clock enabled
;;;59     	 */
;;;60     	SIM_SCGC4 |= SIM_SCGC4_SPI1_MASK;
00000c  6b41              LDR      r1,[r0,#0x34]
00000e  0292              LSLS     r2,r2,#10
000010  4311              ORRS     r1,r1,r2
000012  6341              STR      r1,[r0,#0x34]
;;;61     	/*
;;;62     	 * Multiplexing pines
;;;63     	 */
;;;64     	PORTE_PCR4 = PORT_PCR_MUX(1) | PORT_PCR_DSE_MASK & (~PORT_PCR_SRE_MASK);	//CS
000014  21ff              MOVS     r1,#0xff
000016  480c              LDR      r0,|L2.72|
000018  3141              ADDS     r1,r1,#0x41
00001a  6101              STR      r1,[r0,#0x10]
;;;65     	FGPIOE_PDDR |= 1 << 4;					// Pin is configured as general-purpose output, for the GPIO function.
00001c  490b              LDR      r1,|L2.76|
00001e  694a              LDR      r2,[r1,#0x14]
000020  2310              MOVS     r3,#0x10
000022  431a              ORRS     r2,r2,r3
000024  614a              STR      r2,[r1,#0x14]
;;;66     
;;;67     	PORTE_PCR2 = PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK & (~PORT_PCR_SRE_MASK);	// SCK
000026  2109              MOVS     r1,#9
000028  0189              LSLS     r1,r1,#6
00002a  6081              STR      r1,[r0,#8]
;;;68     	PORTE_PCR1 = PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK & (~PORT_PCR_SRE_MASK);	// MOSI
00002c  6041              STR      r1,[r0,#4]
;;;69     	PORTE_PCR3 = PORT_PCR_MUX(2) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;	// MISO
00002e  4908              LDR      r1,|L2.80|
000030  60c1              STR      r1,[r0,#0xc]
;;;70     
;;;71     	/*
;;;72     	 * Bit 7 SPIE   = 0 Disables receive and mode fault interrupts
;;;73     	 * Bit 6 SPE    = 1 Enables the SPI system
;;;74     	 * Bit 5 SPTIE  = 0 Disables SPI transmit interrupts
;;;75     	 * Bit 4 MSTR   = 1 Sets the SPI module as a master SPI device
;;;76     	 * Bit 3 CPOL   = 0 Configures SPI clock as active-high
;;;77     	 * Bit 2 CPHA   = 0 First edge on SPSCK at start of first data transfer cycle
;;;78     	 * Bit 1 SSOE   = 1 Determines SS pin function when mode fault enabled
;;;79     	 * Bit 0 LSBFE  = 0 SPI serial data transfers start with most significant bit
;;;80     	 */
;;;81     	SPI1_C1 = 0xD0;
000032  4808              LDR      r0,|L2.84|
000034  21d0              MOVS     r1,#0xd0
000036  7001              STRB     r1,[r0,#0]
;;;82     	/*
;;;83     	 * Bit 7 PMIE       = 0 SPI hardware match interrupt disabled
;;;84     	 * Bit 6            = 0 Unimplemented
;;;85     	 * Bit 5 TXDMAE     = 0 DMA request disabled
;;;86     	 * Bit 4 MODFEN     = 1 In master mode, ~SS pin function is automatic ~SS output
;;;87     	 * Bit 3 BIDIROE    = 0 SPI data I/O pin acts as input
;;;88     	 * Bit 2 RXDMAE     = 0 DMA request disabled
;;;89     	 * Bit 1 SPISWAI    = 0 SPI clocks operate in wait mode
;;;90     	 * Bit 0 SPC0       = 0 uses separate pins for data input and output
;;;91     	 */
;;;92     	SPI1_C2 = 0x24;
000038  2124              MOVS     r1,#0x24
00003a  7041              STRB     r1,[r0,#1]
;;;93     
;;;94     	/*
;;;95     	 * Bit 7    SPRF    = 0 Flag is set when receive data buffer is full
;;;96     	 * Bit 6    SPMF    = 0 Flag is set when SPIx_M = receive data buffer
;;;97     	 * Bit 5    SPTEF   = 0 Flag is set when transmit data buffer is empty
;;;98     	 * Bit 4    MODF    = 0 Mode fault flag for master mode
;;;99     	 * Bit 3:0          = 0 Reserved
;;;100    	 */
;;;101    	SPI1_S = 0x00;
00003c  2100              MOVS     r1,#0
00003e  70c1              STRB     r1,[r0,#3]
;;;102    }
000040  4770              BX       lr
;;;103    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x40048000
                  |L2.72|
                          DCD      0x4004d000
                  |L2.76|
                          DCD      0xf80ff100
                  |L2.80|
                          DCD      0x00000203
                  |L2.84|
                          DCD      0x40077000

                          AREA ||i.SPI_RW||, CODE, READONLY, ALIGN=2

                  SPI_RW PROC
;;;103    
;;;104    BYTE SPI_RW(BYTE d) { 
000000  4904              LDR      r1,|L3.20|
                  |L3.2|
;;;105    	//DEBUG_START(DBG_1);
;;;106    
;;;107    	while (!(SPI1_S & SPI_S_SPTEF_MASK)) {
000002  78ca              LDRB     r2,[r1,#3]
000004  0692              LSLS     r2,r2,#26
000006  d5fc              BPL      |L3.2|
;;;108    		//DEBUG_TOGGLE(DBG_1);
;;;109    	}
;;;110    	//DEBUG_START(DBG_1);
;;;111    	SPI1_D = d;
000008  7148              STRB     r0,[r1,#5]
                  |L3.10|
;;;112    	while (!(SPI1_S & SPI_S_SPRF_MASK)) {
00000a  78c8              LDRB     r0,[r1,#3]
00000c  0600              LSLS     r0,r0,#24
00000e  d5fc              BPL      |L3.10|
;;;113    		//DEBUG_TOGGLE(DBG_1);
;;;114    	}
;;;115    	//DEBUG_STOP(DBG_1);
;;;116    	return ((BYTE) (SPI1_D));
000010  7948              LDRB     r0,[r1,#5]
;;;117    }
000012  4770              BX       lr
;;;118    
                          ENDP

                  |L3.20|
                          DCD      0x40077000

                          AREA ||i.SPI_Release||, CODE, READONLY, ALIGN=1

                  SPI_Release PROC
;;;118    
;;;119    void SPI_Release(void) {
000000  b500              PUSH     {lr}
;;;120    	WORD idx;
;;;121    	for (idx = 512; idx && (SPI_RW(0xFF) != 0xFF); idx--);
000002  2301              MOVS     r3,#1
000004  025b              LSLS     r3,r3,#9
000006  e003              B        |L4.16|
                  |L4.8|
000008  1e5b              SUBS     r3,r3,#1              ;119
00000a  041b              LSLS     r3,r3,#16
00000c  0c1b              LSRS     r3,r3,#16
00000e  d004              BEQ      |L4.26|
                  |L4.16|
000010  20ff              MOVS     r0,#0xff
000012  f7fffffe          BL       SPI_RW
000016  28ff              CMP      r0,#0xff
000018  d1f6              BNE      |L4.8|
                  |L4.26|
;;;122    }
00001a  bd00              POP      {pc}
;;;123    
                          ENDP


                          AREA ||i.SPI_Timer_On||, CODE, READONLY, ALIGN=2

                  SPI_Timer_On PROC
;;;139    
;;;140    void SPI_Timer_On(WORD ms) {
000000  4906              LDR      r1,|L5.28|
;;;141    	SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;	// Make sure clock is enabled
000002  6b8b              LDR      r3,[r1,#0x38]
000004  2201              MOVS     r2,#1
000006  4313              ORRS     r3,r3,r2
000008  638b              STR      r3,[r1,#0x38]
;;;142    	LPTMR0_CSR = 0;								// Reset LPTMR settings
00000a  4905              LDR      r1,|L5.32|
00000c  2300              MOVS     r3,#0
00000e  600b              STR      r3,[r1,#0]
;;;143    	LPTMR0_CMR = ms;							// Set compare value (in ms)
000010  6088              STR      r0,[r1,#8]
;;;144    	// Use 1kHz LPO with no prescaler
;;;145    	LPTMR0_PSR = LPTMR_PSR_PCS(1) | LPTMR_PSR_PBYP_MASK;
000012  2005              MOVS     r0,#5
000014  6048              STR      r0,[r1,#4]
;;;146    	// Start the timer and wait for it to reach the compare value
;;;147    	LPTMR0_CSR = LPTMR_CSR_TEN_MASK;
000016  600a              STR      r2,[r1,#0]
;;;148    }
000018  4770              BX       lr
;;;149    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40048000
                  |L5.32|
                          DCD      0x40040000

                          AREA ||i.Start_DMA||, CODE, READONLY, ALIGN=2

                  Start_DMA PROC
;;;40     
;;;41     void Start_DMA(uint32_t * source, uint32_t * destination, uint32_t count){
000000  4b08              LDR      r3,|L6.36|
;;;42     	// Initialize Source/Dest Pointers
;;;43     	DMA0->DMA[0].SAR = DMA_SAR_SAR((uint32_t) source);
000002  6018              STR      r0,[r3,#0]
;;;44     	DMA0->DMA[0].DAR = DMA_DAR_DAR((uint32_t) destination);
000004  6059              STR      r1,[r3,#4]
;;;45     	// byte count
;;;46     	DMA0->DMA[0].DSR_BCR = DMA_DSR_BCR_BCR(count);
000006  0210              LSLS     r0,r2,#8
000008  0a00              LSRS     r0,r0,#8
00000a  6098              STR      r0,[r3,#8]
;;;47     	// clear done flag
;;;48     	DMA0->DMA[0].DSR_BCR &= ~DMA_DSR_BCR_DONE_MASK;
00000c  6898              LDR      r0,[r3,#8]
00000e  2101              MOVS     r1,#1
000010  0609              LSLS     r1,r1,#24
000012  4388              BICS     r0,r0,r1
000014  6098              STR      r0,[r3,#8]
;;;49     	// set enable flag
;;;50     	DMAMUX0->CHCFG[0] |= DMAMUX_CHCFG_ENBL_MASK;
000016  4804              LDR      r0,|L6.40|
000018  7801              LDRB     r1,[r0,#0]
00001a  2280              MOVS     r2,#0x80
00001c  4311              ORRS     r1,r1,r2
00001e  7001              STRB     r1,[r0,#0]
;;;51     	
;;;52     }
000020  4770              BX       lr
;;;53     
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x40008100
                  |L6.40|
                          DCD      0x40021000

                          AREA ||.data||, DATA, ALIGN=0

                  msgReceive
000000  00                DCB      0x00

                          AREA ||i.SPI_CS_Low||, COMGROUP=SPI_CS_Low, CODE, READONLY, ALIGN=2

                  SPI_CS_Low PROC
;;;123    
;;;124    inline void SPI_CS_Low(void) {
000000  4802              LDR      r0,|L45.12|
;;;125    	GPIOE_PDOR &= ~(1 << 4);			//CS LOW
000002  6801              LDR      r1,[r0,#0]
000004  2210              MOVS     r2,#0x10
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;126    }
00000a  4770              BX       lr
;;;127    
                          ENDP

                  |L45.12|
                          DCD      0x400ff100

                          AREA ||i.SPI_CS_High||, COMGROUP=SPI_CS_High, CODE, READONLY, ALIGN=2

                  SPI_CS_High PROC
;;;127    
;;;128    inline void SPI_CS_High(void) {
000000  4802              LDR      r0,|L52.12|
;;;129    	GPIOE_PDOR |= (1 << 4);				//CS HIGH
000002  6801              LDR      r1,[r0,#0]
000004  2210              MOVS     r2,#0x10
000006  4311              ORRS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;130    }
00000a  4770              BX       lr
;;;131    
                          ENDP

                  |L52.12|
                          DCD      0x400ff100

                          AREA ||i.SPI_Freq_High||, COMGROUP=SPI_Freq_High, CODE, READONLY, ALIGN=2

                  SPI_Freq_High PROC
;;;131    
;;;132    inline void SPI_Freq_High(void) {
000000  4901              LDR      r1,|L59.8|
;;;133    	SPI1_BR = 0x10;								
000002  2010              MOVS     r0,#0x10
000004  7088              STRB     r0,[r1,#2]
;;;134    }
000006  4770              BX       lr
;;;135    
                          ENDP

                  |L59.8|
                          DCD      0x40077000

                          AREA ||i.SPI_Freq_Low||, COMGROUP=SPI_Freq_Low, CODE, READONLY, ALIGN=2

                  SPI_Freq_Low PROC
;;;135    
;;;136    inline void SPI_Freq_Low(void) {
000000  4901              LDR      r1,|L66.8|
;;;137    	SPI1_BR = 0x44;								
000002  2044              MOVS     r0,#0x44
000004  7088              STRB     r0,[r1,#2]
;;;138    }
000006  4770              BX       lr
;;;139    
                          ENDP

                  |L66.8|
                          DCD      0x40077000

                          AREA ||i.SPI_Timer_Status||, COMGROUP=SPI_Timer_Status, CODE, READONLY, ALIGN=2

                  SPI_Timer_Status PROC
;;;149    
;;;150    inline BOOL SPI_Timer_Status(void) {
000000  4802              LDR      r0,|L73.12|
;;;151    	return (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK) ? TRUE : FALSE);
000002  6800              LDR      r0,[r0,#0]
000004  0600              LSLS     r0,r0,#24
000006  17c0              ASRS     r0,r0,#31
000008  1c40              ADDS     r0,r0,#1
;;;152    }
00000a  4770              BX       lr
;;;153    
                          ENDP

                  |L73.12|
                          DCD      0x40040000

                          AREA ||i.SPI_Timer_Off||, COMGROUP=SPI_Timer_Off, CODE, READONLY, ALIGN=2

                  SPI_Timer_Off PROC
;;;153    
;;;154    inline void SPI_Timer_Off(void) {
000000  4901              LDR      r1,|L80.8|
;;;155    	LPTMR0_CSR = 0;								// Turn off timer
000002  2000              MOVS     r0,#0
000004  6008              STR      r0,[r1,#0]
;;;156    }
000006  4770              BX       lr
;;;157    
                          ENDP

                  |L80.8|
                          DCD      0x40040000

;*** Start embedded assembler ***

#line 1 "Source\\ulibSD\\spi_io.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_spi_io_c_6260c657____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_spi_io_c_6260c657____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_spi_io_c_6260c657____REVSH|
#line 462
|__asm___8_spi_io_c_6260c657____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
