; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\spi_io.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spi_io.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\spi_io.crf Source\ulibSD\spi_io.c]
                          THUMB

                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                  SPI_Init PROC
;;;20     
;;;21     void SPI_Init(void) {
000000  480f              LDR      r0,|L1.64|
;;;22     
;;;23     	SIM_SCGC5 |= SIM_SCGC5_PORTE_MASK;
000002  6b81              LDR      r1,[r0,#0x38]
000004  2201              MOVS     r2,#1
000006  0352              LSLS     r2,r2,#13
000008  4311              ORRS     r1,r1,r2
00000a  6381              STR      r1,[r0,#0x38]
;;;24     	/*
;;;25     	 *SPI1 Clock gate control. 1 clock enabled
;;;26     	 */
;;;27     	SIM_SCGC4 |= SIM_SCGC4_SPI1_MASK;
00000c  6b41              LDR      r1,[r0,#0x34]
00000e  0292              LSLS     r2,r2,#10
000010  4311              ORRS     r1,r1,r2
000012  6341              STR      r1,[r0,#0x34]
;;;28     	/*
;;;29     	 * Multiplexing pines
;;;30     	 */
;;;31     	PORTE_PCR4 = PORT_PCR_MUX(1) | PORT_PCR_DSE_MASK & (~PORT_PCR_SRE_MASK);	//CS
000014  21ff              MOVS     r1,#0xff
000016  480b              LDR      r0,|L1.68|
000018  3141              ADDS     r1,r1,#0x41
00001a  6101              STR      r1,[r0,#0x10]
;;;32     	FGPIOE_PDDR |= 1 << 4;					// Pin is configured as general-purpose output, for the GPIO function.
00001c  490a              LDR      r1,|L1.72|
00001e  694a              LDR      r2,[r1,#0x14]
000020  2310              MOVS     r3,#0x10
000022  431a              ORRS     r2,r2,r3
000024  614a              STR      r2,[r1,#0x14]
;;;33     
;;;34     	PORTE_PCR2 = PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK & (~PORT_PCR_SRE_MASK);	// SCK
000026  2109              MOVS     r1,#9
000028  0189              LSLS     r1,r1,#6
00002a  6081              STR      r1,[r0,#8]
;;;35     	PORTE_PCR1 = PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK & (~PORT_PCR_SRE_MASK);	// MOSI
00002c  6041              STR      r1,[r0,#4]
;;;36     	PORTE_PCR3 = PORT_PCR_MUX(2) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;	// MISO
00002e  4907              LDR      r1,|L1.76|
000030  60c1              STR      r1,[r0,#0xc]
;;;37     
;;;38     	/*
;;;39     	 * Bit 7 SPIE   = 1 Disables receive and mode fault interrupts
;;;40     	 * Bit 6 SPE    = 1 Enables the SPI system
;;;41     	 * Bit 5 SPTIE  = 0 Disables SPI transmit interrupts
;;;42     	 * Bit 4 MSTR   = 1 Sets the SPI module as a master SPI device
;;;43     	 * Bit 3 CPOL   = 0 Configures SPI clock as active-high
;;;44     	 * Bit 2 CPHA   = 0 First edge on SPSCK at start of first data transfer cycle
;;;45     	 * Bit 1 SSOE   = 0 Determines SS pin function when mode fault enabled
;;;46     	 * Bit 0 LSBFE  = 0 SPI serial data transfers start with most significant bit
;;;47     	 */
;;;48     	SPI1_C1 = 0xD0;
000032  4807              LDR      r0,|L1.80|
000034  21d0              MOVS     r1,#0xd0
000036  7001              STRB     r1,[r0,#0]
;;;49     	/*
;;;50     	 * Bit 7 PMIE       = 0 SPI hardware match interrupt disabled
;;;51     	 * Bit 6            = 0 Unimplemented
;;;52     	 * Bit 5 TXDMAE     = 1 DMA request enabled
;;;53     	 * Bit 4 MODFEN     = 0 In master mode, ~SS pin function is automatic ~SS output
;;;54     	 * Bit 3 BIDIROE    = 0 SPI data I/O pin acts as input
;;;55     	 * Bit 2 RXDMAE     = 1 DMA request enabled
;;;56     	 * Bit 1 SPISWAI    = 0 SPI clocks operate in wait mode
;;;57     	 * Bit 0 SPC0       = 0 uses separate pins for data input and output
;;;58     	 */
;;;59     	SPI1_C2 = 0x00;
000038  2100              MOVS     r1,#0
00003a  7041              STRB     r1,[r0,#1]
;;;60     
;;;61     	/*
;;;62     	 * Bit 7    SPRF    = 0 Flag is set when receive data buffer is full
;;;63     	 * Bit 6    SPMF    = 0 Flag is set when SPIx_M = receive data buffer
;;;64     	 * Bit 5    SPTEF   = 0 Flag is set when transmit data buffer is empty
;;;65     	 * Bit 4    MODF    = 0 Mode fault flag for master mode
;;;66     	 * Bit 3:0          = 0 Reserved
;;;67     	 */
;;;68     	SPI1_S = 0x00;
00003c  70c1              STRB     r1,[r0,#3]
;;;69     }
00003e  4770              BX       lr
;;;70     
                          ENDP

                  |L1.64|
                          DCD      0x40048000
                  |L1.68|
                          DCD      0x4004d000
                  |L1.72|
                          DCD      0xf80ff100
                  |L1.76|
                          DCD      0x00000203
                  |L1.80|
                          DCD      0x40077000

                          AREA ||i.SPI_RW||, CODE, READONLY, ALIGN=2

                  SPI_RW PROC
;;;70     
;;;71     BYTE SPI_RW(BYTE d) { 
000000  b410              PUSH     {r4}
;;;72     	#if DEBUG_ENABLE
;;;73     	DEBUG_START(DBG_1);
000002  4b0c              LDR      r3,|L2.52|
000004  2202              MOVS     r2,#2
000006  605a              STR      r2,[r3,#4]
;;;74     	#endif
;;;75     
;;;76     	while (!(SPI1_S & SPI_S_SPTEF_MASK)) {
000008  490b              LDR      r1,|L2.56|
00000a  78cc              LDRB     r4,[r1,#3]
00000c  06a4              LSLS     r4,r4,#26
00000e  d403              BMI      |L2.24|
                  |L2.16|
;;;77     		#if DEBUG_ENABLE
;;;78     		DEBUG_TOGGLE(DBG_1);
000010  60da              STR      r2,[r3,#0xc]
000012  78cc              LDRB     r4,[r1,#3]            ;76
000014  06a4              LSLS     r4,r4,#26             ;76
000016  d5fb              BPL      |L2.16|
                  |L2.24|
;;;79     		#endif
;;;80     	}
;;;81     	#if DEBUG_ENABLE
;;;82     	DEBUG_START(DBG_1);
000018  605a              STR      r2,[r3,#4]
;;;83     	#endif
;;;84     	SPI1_D = d;
00001a  7148              STRB     r0,[r1,#5]
;;;85     	while (!(SPI1_S & SPI_S_SPRF_MASK)) {
00001c  78c8              LDRB     r0,[r1,#3]
00001e  0600              LSLS     r0,r0,#24
000020  d403              BMI      |L2.42|
                  |L2.34|
;;;86     		#if DEBUG_ENABLE
;;;87     		DEBUG_TOGGLE(DBG_1);
000022  60da              STR      r2,[r3,#0xc]
000024  78c8              LDRB     r0,[r1,#3]            ;85
000026  0600              LSLS     r0,r0,#24             ;85
000028  d5fb              BPL      |L2.34|
                  |L2.42|
;;;88     		#endif
;;;89     	}
;;;90     	#if DEBUG_ENABLE
;;;91     	DEBUG_STOP(DBG_1);
00002a  609a              STR      r2,[r3,#8]
;;;92     	#endif
;;;93     	return ((BYTE) (SPI1_D));
00002c  7948              LDRB     r0,[r1,#5]
;;;94     }
00002e  bc10              POP      {r4}
000030  4770              BX       lr
;;;95     
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0xf80ff040
                  |L2.56|
                          DCD      0x40077000

                          AREA ||i.SPI_Release||, CODE, READONLY, ALIGN=2

                  SPI_Release PROC
;;;95     
;;;96     void SPI_Release(void) {
000000  b430              PUSH     {r4,r5}
;;;97     	WORD idx;
;;;98     	for (idx = 512; idx && (SPI_RW(0xFF) != 0xFF); idx--);
000002  2501              MOVS     r5,#1
000004  026d              LSLS     r5,r5,#9
000006  2202              MOVS     r2,#2
000008  4b0f              LDR      r3,|L3.72|
00000a  4910              LDR      r1,|L3.76|
00000c  e003              B        |L3.22|
                  |L3.14|
00000e  1e6d              SUBS     r5,r5,#1              ;96
000010  042d              LSLS     r5,r5,#16
000012  0c2d              LSRS     r5,r5,#16
000014  d015              BEQ      |L3.66|
                  |L3.22|
000016  24ff              MOVS     r4,#0xff
000018  605a              STR      r2,[r3,#4]
00001a  78c8              LDRB     r0,[r1,#3]
00001c  0680              LSLS     r0,r0,#26
00001e  d403              BMI      |L3.40|
                  |L3.32|
000020  60da              STR      r2,[r3,#0xc]
000022  78c8              LDRB     r0,[r1,#3]
000024  0680              LSLS     r0,r0,#26
000026  d5fb              BPL      |L3.32|
                  |L3.40|
000028  605a              STR      r2,[r3,#4]
00002a  714c              STRB     r4,[r1,#5]
00002c  78c8              LDRB     r0,[r1,#3]
00002e  0600              LSLS     r0,r0,#24
000030  d403              BMI      |L3.58|
                  |L3.50|
000032  60da              STR      r2,[r3,#0xc]
000034  78c8              LDRB     r0,[r1,#3]
000036  0600              LSLS     r0,r0,#24
000038  d5fb              BPL      |L3.50|
                  |L3.58|
00003a  609a              STR      r2,[r3,#8]
00003c  7948              LDRB     r0,[r1,#5]
00003e  28ff              CMP      r0,#0xff
000040  d1e5              BNE      |L3.14|
                  |L3.66|
;;;99     }
000042  bc30              POP      {r4,r5}
000044  4770              BX       lr
;;;100    
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      0xf80ff040
                  |L3.76|
                          DCD      0x40077000

                          AREA ||i.SPI_Timer_On||, CODE, READONLY, ALIGN=2

                  SPI_Timer_On PROC
;;;116    
;;;117    void SPI_Timer_On(WORD ms) {
000000  4906              LDR      r1,|L4.28|
;;;118    	SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;	// Make sure clock is enabled
000002  6b8b              LDR      r3,[r1,#0x38]
000004  2201              MOVS     r2,#1
000006  4313              ORRS     r3,r3,r2
000008  638b              STR      r3,[r1,#0x38]
;;;119    	LPTMR0_CSR = 0;								// Reset LPTMR settings
00000a  4905              LDR      r1,|L4.32|
00000c  2300              MOVS     r3,#0
00000e  600b              STR      r3,[r1,#0]
;;;120    	LPTMR0_CMR = ms;							// Set compare value (in ms)
000010  6088              STR      r0,[r1,#8]
;;;121    	// Use 1kHz LPO with no prescaler
;;;122    	LPTMR0_PSR = LPTMR_PSR_PCS(1) | LPTMR_PSR_PBYP_MASK;
000012  2005              MOVS     r0,#5
000014  6048              STR      r0,[r1,#4]
;;;123    	// Start the timer and wait for it to reach the compare value
;;;124    	LPTMR0_CSR = LPTMR_CSR_TEN_MASK;
000016  600a              STR      r2,[r1,#0]
;;;125    }
000018  4770              BX       lr
;;;126    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40048000
                  |L4.32|
                          DCD      0x40040000

                          AREA ||.data||, DATA, ALIGN=0

                  msgReceive
000000  00                DCB      0x00

                          AREA ||i.SPI_CS_Low||, COMGROUP=SPI_CS_Low, CODE, READONLY, ALIGN=2

                  SPI_CS_Low PROC
;;;100    
;;;101    inline void SPI_CS_Low(void) {
000000  4802              LDR      r0,|L33.12|
;;;102    	FGPIOE_PDOR &= ~(1 << 4);			//CS LOW
000002  6801              LDR      r1,[r0,#0]
000004  2210              MOVS     r2,#0x10
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;103    }
00000a  4770              BX       lr
;;;104    
                          ENDP

                  |L33.12|
                          DCD      0xf80ff100

                          AREA ||i.SPI_CS_High||, COMGROUP=SPI_CS_High, CODE, READONLY, ALIGN=2

                  SPI_CS_High PROC
;;;104    
;;;105    inline void SPI_CS_High(void) {
000000  4802              LDR      r0,|L40.12|
;;;106    	FGPIOE_PDOR |= (1 << 4);				//CS HIGH
000002  6801              LDR      r1,[r0,#0]
000004  2210              MOVS     r2,#0x10
000006  4311              ORRS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;107    }
00000a  4770              BX       lr
;;;108    
                          ENDP

                  |L40.12|
                          DCD      0xf80ff100

                          AREA ||i.SPI_Freq_High||, COMGROUP=SPI_Freq_High, CODE, READONLY, ALIGN=2

                  SPI_Freq_High PROC
;;;108    
;;;109    inline void SPI_Freq_High(void) {
000000  4901              LDR      r1,|L47.8|
;;;110    	SPI1_BR = 0x10;								
000002  2010              MOVS     r0,#0x10
000004  7088              STRB     r0,[r1,#2]
;;;111    }
000006  4770              BX       lr
;;;112    
                          ENDP

                  |L47.8|
                          DCD      0x40077000

                          AREA ||i.SPI_Freq_Low||, COMGROUP=SPI_Freq_Low, CODE, READONLY, ALIGN=2

                  SPI_Freq_Low PROC
;;;112    
;;;113    inline void SPI_Freq_Low(void) {
000000  4901              LDR      r1,|L54.8|
;;;114    	SPI1_BR = 0x44;								
000002  2044              MOVS     r0,#0x44
000004  7088              STRB     r0,[r1,#2]
;;;115    }
000006  4770              BX       lr
;;;116    
                          ENDP

                  |L54.8|
                          DCD      0x40077000

                          AREA ||i.SPI_Timer_Status||, COMGROUP=SPI_Timer_Status, CODE, READONLY, ALIGN=2

                  SPI_Timer_Status PROC
;;;126    
;;;127    inline BOOL SPI_Timer_Status(void) {
000000  4802              LDR      r0,|L61.12|
;;;128    	return (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK) ? TRUE : FALSE);
000002  6800              LDR      r0,[r0,#0]
000004  0600              LSLS     r0,r0,#24
000006  17c0              ASRS     r0,r0,#31
000008  1c40              ADDS     r0,r0,#1
;;;129    }
00000a  4770              BX       lr
;;;130    
                          ENDP

                  |L61.12|
                          DCD      0x40040000

                          AREA ||i.SPI_Timer_Off||, COMGROUP=SPI_Timer_Off, CODE, READONLY, ALIGN=2

                  SPI_Timer_Off PROC
;;;130    
;;;131    inline void SPI_Timer_Off(void) {
000000  4901              LDR      r1,|L68.8|
;;;132    	LPTMR0_CSR = 0;								// Turn off timer
000002  2000              MOVS     r0,#0
000004  6008              STR      r0,[r1,#0]
;;;133    }
000006  4770              BX       lr
;;;134    
                          ENDP

                  |L68.8|
                          DCD      0x40040000

;*** Start embedded assembler ***

#line 1 "Source\\ulibSD\\spi_io.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_spi_io_c_SPI_Init____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_spi_io_c_SPI_Init____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_spi_io_c_SPI_Init____REVSH|
#line 462
|__asm___8_spi_io_c_SPI_Init____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
