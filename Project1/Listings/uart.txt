; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\uart.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\uart.crf --remarks Source\UART.c]
                          THUMB

                          AREA ||i.Get_Rx_Char||, CODE, READONLY, ALIGN=2

                  Get_Rx_Char PROC
;;;189    
;;;190    uint8_t	Get_Rx_Char(void) {
000000  b510              PUSH     {r4,lr}
;;;191    	return Q_Dequeue(&RxQ);
000002  4802              LDR      r0,|L1.12|
000004  f7fffffe          BL       Q_Dequeue
;;;192    }
000008  bd10              POP      {r4,pc}
;;;193    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      ||.bss||+0x10c

                          AREA ||i.Init_UART0||, CODE, READONLY, ALIGN=2

                  Init_UART0 PROC
;;;39     // Code listing 8.8, p. 231
;;;40     void Init_UART0(uint32_t baud_rate) {
000000  b510              PUSH     {r4,lr}
;;;41     	uint16_t sbr;
;;;42     	uint8_t temp;
;;;43     	
;;;44     	// Enable clock gating for UART0 and Port A
;;;45     	SIM->SCGC4 |= SIM_SCGC4_UART0_MASK; 										
000002  4924              LDR      r1,|L2.148|
000004  6b4a              LDR      r2,[r1,#0x34]
000006  150b              ASRS     r3,r1,#20
000008  431a              ORRS     r2,r2,r3
00000a  634a              STR      r2,[r1,#0x34]
;;;46     	SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK;											
00000c  6b8a              LDR      r2,[r1,#0x38]
00000e  154b              ASRS     r3,r1,#21
000010  431a              ORRS     r2,r2,r3
000012  638a              STR      r2,[r1,#0x38]
;;;47     	
;;;48     	// Make sure transmitter and receiver are disabled before init
;;;49     	UART0->C2 &= ~UART0_C2_TE_MASK & ~UART0_C2_RE_MASK; 		
000014  4c20              LDR      r4,|L2.152|
000016  78e2              LDRB     r2,[r4,#3]
000018  23f3              MOVS     r3,#0xf3
00001a  401a              ANDS     r2,r2,r3
00001c  70e2              STRB     r2,[r4,#3]
;;;50     	
;;;51     	// Set UART clock to 48 MHz clock 
;;;52     	SIM->SOPT2 |= SIM_SOPT2_UART0SRC(1);
00001e  684a              LDR      r2,[r1,#4]
000020  2301              MOVS     r3,#1
000022  069b              LSLS     r3,r3,#26
000024  431a              ORRS     r2,r2,r3
000026  604a              STR      r2,[r1,#4]
;;;53     	SIM->SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK;
000028  684a              LDR      r2,[r1,#4]
00002a  129b              ASRS     r3,r3,#10
00002c  431a              ORRS     r2,r2,r3
00002e  604a              STR      r2,[r1,#4]
;;;54     
;;;55     	// Set pins to UART0 Rx and Tx
;;;56     	PORTA->PCR[1] = PORT_PCR_ISF_MASK | PORT_PCR_MUX(2); // Rx
000030  4a1b              LDR      r2,|L2.160|
000032  491a              LDR      r1,|L2.156|
000034  6051              STR      r1,[r2,#4]
;;;57     	PORTA->PCR[2] = PORT_PCR_ISF_MASK | PORT_PCR_MUX(2); // Tx
000036  6091              STR      r1,[r2,#8]
;;;58     	
;;;59     	// Set baud rate and oversampling ratio
;;;60     	sbr = (uint16_t)((SYS_CLOCK)/(baud_rate * UART_OVERSAMPLE_RATE)); 			
000038  0100              LSLS     r0,r0,#4
00003a  f7fffffe          BL       __aeabi_ui2d
00003e  4602              MOV      r2,r0
000040  460b              MOV      r3,r1
000042  2000              MOVS     r0,#0
000044  4917              LDR      r1,|L2.164|
000046  f7fffffe          BL       __aeabi_ddiv
00004a  f7fffffe          BL       __aeabi_d2uiz
;;;61     	UART0->BDH &= ~UART0_BDH_SBR_MASK;
00004e  7821              LDRB     r1,[r4,#0]
000050  0949              LSRS     r1,r1,#5
000052  0149              LSLS     r1,r1,#5
000054  7021              STRB     r1,[r4,#0]
;;;62     	UART0->BDH |= UART0_BDH_SBR(sbr>>8);
000056  7821              LDRB     r1,[r4,#0]
000058  04c2              LSLS     r2,r0,#19
00005a  0ed2              LSRS     r2,r2,#27
00005c  4311              ORRS     r1,r1,r2
00005e  7021              STRB     r1,[r4,#0]
;;;63     	UART0->BDL = UART0_BDL_SBR(sbr);
000060  7060              STRB     r0,[r4,#1]
;;;64     	UART0->C4 |= UART0_C4_OSR(UART_OVERSAMPLE_RATE-1);				
000062  7aa1              LDRB     r1,[r4,#0xa]
000064  200f              MOVS     r0,#0xf
000066  4301              ORRS     r1,r1,r0
000068  72a1              STRB     r1,[r4,#0xa]
;;;65     
;;;66     	// Disable interrupts for RX active edge and LIN break detect, select one stop bit
;;;67     	UART0->BDH |= UART0_BDH_RXEDGIE(0) | UART0_BDH_SBNS(0) | UART0_BDH_LBKDIE(0);
00006a  7821              LDRB     r1,[r4,#0]
00006c  7021              STRB     r1,[r4,#0]
;;;68     	
;;;69     	// Don't enable loopback mode, use 8 data bit mode, don't use parity
;;;70     	UART0->C1 = UART0_C1_LOOPS(0) | UART0_C1_M(0) | UART0_C1_PE(0); 
00006e  2100              MOVS     r1,#0
000070  70a1              STRB     r1,[r4,#2]
;;;71     	// Don't invert transmit data, don't enable interrupts for errors
;;;72     	UART0->C3 = UART0_C3_TXINV(0) | UART0_C3_ORIE(0)| UART0_C3_NEIE(0) 
000072  71a1              STRB     r1,[r4,#6]
;;;73     			| UART0_C3_FEIE(0) | UART0_C3_PEIE(0);
;;;74     
;;;75     	// Clear error flags
;;;76     	UART0->S1 = UART0_S1_OR(1) | UART0_S1_NF(1) | UART0_S1_FE(1) | UART0_S1_PF(1);
000074  7120              STRB     r0,[r4,#4]
;;;77     
;;;78     	// Try it a different way
;;;79     	UART0->S1 |= UART0_S1_OR_MASK | UART0_S1_NF_MASK | 
000076  7922              LDRB     r2,[r4,#4]
000078  4302              ORRS     r2,r2,r0
00007a  7122              STRB     r2,[r4,#4]
;;;80     									UART0_S1_FE_MASK | UART0_S1_PF_MASK;
;;;81     	
;;;82     	// Send LSB first, do not invert received data
;;;83     	UART0->S2 = UART0_S2_MSBF(0) | UART0_S2_RXINV(0); 
00007c  7161              STRB     r1,[r4,#5]
;;;84     	
;;;85     #if USE_UART_INTERRUPTS
;;;86     	// Enable interrupts. Listing 8.11 on p. 234
;;;87     	Q_Init(&TxQ);
;;;88     	Q_Init(&RxQ);
;;;89     
;;;90     	NVIC_SetPriority(UART0_IRQn, 2); // 0, 1, 2, or 3
;;;91     	NVIC_ClearPendingIRQ(UART0_IRQn); 
;;;92     	NVIC_EnableIRQ(UART0_IRQn);
;;;93     
;;;94     	// Enable receive interrupts but not transmit interrupts yet
;;;95     	UART0->C2 |= UART_C2_RIE(1);
;;;96     #endif
;;;97     
;;;98     	// Enable UART receiver and transmitter
;;;99     	UART0->C2 |= UART0_C2_RE(1) | UART0_C2_TE(1);	
00007e  78e0              LDRB     r0,[r4,#3]
000080  210c              MOVS     r1,#0xc
000082  4308              ORRS     r0,r0,r1
000084  70e0              STRB     r0,[r4,#3]
;;;100    	
;;;101    	// Clear the UART RDRF flag
;;;102    	temp = UART0->D;
000086  79e0              LDRB     r0,[r4,#7]
;;;103    	UART0->S1 &= ~UART0_S1_RDRF_MASK;
000088  7920              LDRB     r0,[r4,#4]
00008a  21df              MOVS     r1,#0xdf
00008c  4008              ANDS     r0,r0,r1
00008e  7120              STRB     r0,[r4,#4]
;;;104    }
000090  bd10              POP      {r4,pc}
;;;105    #pragma pop
                          ENDP

000092  0000              DCW      0x0000
                  |L2.148|
                          DCD      0x40048000
                  |L2.152|
                          DCD      0x4006a000
                  |L2.156|
                          DCD      0x01000200
                  |L2.160|
                          DCD      0x40049000
                  |L2.164|
                          DCD      0x4186e360

                          AREA ||i.Rx_Chars_Available||, CODE, READONLY, ALIGN=2

                  Rx_Chars_Available PROC
;;;185    
;;;186    uint32_t Rx_Chars_Available(void) {
000000  b510              PUSH     {r4,lr}
;;;187    	return Q_Size(&RxQ);
000002  4802              LDR      r0,|L3.12|
000004  f7fffffe          BL       Q_Size
;;;188    }
000008  bd10              POP      {r4,pc}
;;;189    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      ||.bss||+0x10c

                          AREA ||i.Send_String||, CODE, READONLY, ALIGN=2

                  Send_String PROC
;;;169    
;;;170    void Send_String(uint8_t * str) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;171    	// enqueue string
;;;172    	while (*str != '\0') { // copy characters up to null terminator
000004  7800              LDRB     r0,[r0,#0]
000006  2800              CMP      r0,#0
000008  d00c              BEQ      |L4.36|
                  |L4.10|
;;;173    		while (Q_Full(&TxQ))
00000a  480d              LDR      r0,|L4.64|
00000c  f7fffffe          BL       Q_Full
000010  2800              CMP      r0,#0
000012  d1fa              BNE      |L4.10|
;;;174    			; // wait for space to open up
;;;175    		Q_Enqueue(&TxQ, *str);
000014  7821              LDRB     r1,[r4,#0]
000016  480a              LDR      r0,|L4.64|
000018  f7fffffe          BL       Q_Enqueue
00001c  7860              LDRB     r0,[r4,#1]            ;172
00001e  1c64              ADDS     r4,r4,#1              ;172
000020  2800              CMP      r0,#0                 ;172
000022  d1f2              BNE      |L4.10|
                  |L4.36|
;;;176    		str++;
;;;177    	}
;;;178    	// start transmitter if it isn't already running
;;;179    	if (!(UART0->C2 & UART0_C2_TIE_MASK)) {
000024  4c07              LDR      r4,|L4.68|
000026  78e0              LDRB     r0,[r4,#3]
000028  0600              LSLS     r0,r0,#24
00002a  d407              BMI      |L4.60|
;;;180    		UART0->D = Q_Dequeue(&TxQ); 
00002c  4804              LDR      r0,|L4.64|
00002e  f7fffffe          BL       Q_Dequeue
000032  71e0              STRB     r0,[r4,#7]
;;;181    		UART0->C2 |= UART0_C2_TIE(1);
000034  78e0              LDRB     r0,[r4,#3]
000036  2180              MOVS     r1,#0x80
000038  4308              ORRS     r0,r0,r1
00003a  70e0              STRB     r0,[r4,#3]
                  |L4.60|
;;;182    	}
;;;183    }
00003c  bd10              POP      {r4,pc}
;;;184    
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      ||.bss||
                  |L4.68|
                          DCD      0x4006a000

                          AREA ||i.Send_String_Poll||, CODE, READONLY, ALIGN=2

                  Send_String_Poll PROC
;;;162    
;;;163    void Send_String_Poll(uint8_t * str) {
000000  7801              LDRB     r1,[r0,#0]
;;;164    	// enqueue string
;;;165    	while (*str != '\0') { // Send characters up to null terminator
000002  2900              CMP      r1,#0
000004  d009              BEQ      |L5.26|
000006  4905              LDR      r1,|L5.28|
                  |L5.8|
;;;166    		UART0_Transmit_Poll(*str++);
000008  7803              LDRB     r3,[r0,#0]
00000a  1c40              ADDS     r0,r0,#1
                  |L5.12|
00000c  790a              LDRB     r2,[r1,#4]
00000e  0612              LSLS     r2,r2,#24
000010  d5fc              BPL      |L5.12|
000012  71cb              STRB     r3,[r1,#7]
000014  7802              LDRB     r2,[r0,#0]            ;165
000016  2a00              CMP      r2,#0                 ;165
000018  d1f6              BNE      |L5.8|
                  |L5.26|
;;;167    	}
;;;168    }
00001a  4770              BX       lr
;;;169    
                          ENDP

                  |L5.28|
                          DCD      0x4006a000

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;129    // UART0 IRQ Handler. Listing 8.12 on p. 235
;;;130    void UART0_IRQHandler(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;131    	uint8_t ch;
;;;132    	
;;;133    	if (UART0->S1 & (UART_S1_OR_MASK |UART_S1_NF_MASK | 
000002  4c15              LDR      r4,|L6.88|
000004  7920              LDRB     r0,[r4,#4]
000006  0700              LSLS     r0,r0,#28
000008  d004              BEQ      |L6.20|
;;;134    		UART_S1_FE_MASK | UART_S1_PF_MASK)) {
;;;135    			// clear the error flags
;;;136    			UART0->S1 |= UART0_S1_OR_MASK | UART0_S1_NF_MASK | 
00000a  7920              LDRB     r0,[r4,#4]
00000c  210f              MOVS     r1,#0xf
00000e  4308              ORRS     r0,r0,r1
000010  7120              STRB     r0,[r4,#4]
;;;137    									UART0_S1_FE_MASK | UART0_S1_PF_MASK;	
;;;138    			// read the data register to clear RDRF
;;;139    			ch = UART0->D;
000012  79e0              LDRB     r0,[r4,#7]
                  |L6.20|
;;;140    	}
;;;141    	if (UART0->S1 & UART0_S1_RDRF_MASK) {
000014  7920              LDRB     r0,[r4,#4]
000016  0680              LSLS     r0,r0,#26
000018  d509              BPL      |L6.46|
;;;142    		// received a character
;;;143    		ch = UART0->D;
00001a  79e5              LDRB     r5,[r4,#7]
;;;144    		if (!Q_Full(&RxQ)) {
00001c  480f              LDR      r0,|L6.92|
00001e  f7fffffe          BL       Q_Full
000022  2800              CMP      r0,#0
000024  d103              BNE      |L6.46|
;;;145    			Q_Enqueue(&RxQ, ch);
000026  4629              MOV      r1,r5
000028  480c              LDR      r0,|L6.92|
00002a  f7fffffe          BL       Q_Enqueue
                  |L6.46|
;;;146    		} else {
;;;147    			// error - queue full.
;;;148    			// discard character
;;;149    		}
;;;150    	}
;;;151    	if ( (UART0->C2 & UART0_C2_TIE_MASK) && // transmitter interrupt enabled
00002e  78e0              LDRB     r0,[r4,#3]
000030  0600              LSLS     r0,r0,#24
000032  d50b              BPL      |L6.76|
;;;152    			(UART0->S1 & UART0_S1_TDRE_MASK) ) { // tx buffer empty
000034  7920              LDRB     r0,[r4,#4]
000036  0600              LSLS     r0,r0,#24
000038  d508              BPL      |L6.76|
;;;153    		// can send another character
;;;154    		if (!Q_Empty(&TxQ)) {
00003a  4809              LDR      r0,|L6.96|
00003c  f7fffffe          BL       Q_Empty
000040  2800              CMP      r0,#0
000042  d004              BEQ      |L6.78|
;;;155    			UART0->D = Q_Dequeue(&TxQ);
;;;156    		} else {
;;;157    			// queue is empty so disable transmitter interrupt
;;;158    			UART0->C2 &= ~UART0_C2_TIE_MASK;
000044  78e0              LDRB     r0,[r4,#3]
000046  0640              LSLS     r0,r0,#25
000048  0e40              LSRS     r0,r0,#25
00004a  70e0              STRB     r0,[r4,#3]
                  |L6.76|
;;;159    		}
;;;160    	}
;;;161    }
00004c  bd70              POP      {r4-r6,pc}
                  |L6.78|
00004e  4804              LDR      r0,|L6.96|
000050  f7fffffe          BL       Q_Dequeue
000054  71e0              STRB     r0,[r4,#7]            ;155
000056  bd70              POP      {r4-r6,pc}
;;;162    
                          ENDP

                  |L6.88|
                          DCD      0x4006a000
                  |L6.92|
                          DCD      ||.bss||+0x10c
                  |L6.96|
                          DCD      ||.bss||

                          AREA ||i.UART0_Receive_Poll||, CODE, READONLY, ALIGN=2

                  UART0_Receive_Poll PROC
;;;122    
;;;123    uint8_t UART0_Receive_Poll(void) {
000000  4802              LDR      r0,|L7.12|
                  |L7.2|
;;;124    		while (!(UART0->S1 & UART0_S1_RDRF_MASK))
000002  7901              LDRB     r1,[r0,#4]
000004  0689              LSLS     r1,r1,#26
000006  d5fc              BPL      |L7.2|
;;;125    			;
;;;126    		return UART0->D;
000008  79c0              LDRB     r0,[r0,#7]
;;;127    }	
00000a  4770              BX       lr
;;;128    
                          ENDP

                  |L7.12|
                          DCD      0x4006a000

                          AREA ||i.UART0_Transmit_Poll||, CODE, READONLY, ALIGN=2

                  UART0_Transmit_Poll PROC
;;;116    // Code listing 8.9, p. 233
;;;117    void UART0_Transmit_Poll(uint8_t data) {
000000  4902              LDR      r1,|L8.12|
                  |L8.2|
;;;118    		while (!(UART0->S1 & UART0_S1_TDRE_MASK))
000002  790a              LDRB     r2,[r1,#4]
000004  0612              LSLS     r2,r2,#24
000006  d5fc              BPL      |L8.2|
;;;119    			;
;;;120    		UART0->D = data;
000008  71c8              STRB     r0,[r1,#7]
;;;121    }	
00000a  4770              BX       lr
;;;122    
                          ENDP

                  |L8.12|
                          DCD      0x4006a000

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;31     //Retarget the fgetc method to use the UART0
;;;32     int fgetc(FILE *f){
000000  4802              LDR      r0,|L9.12|
                  |L9.2|
;;;33     	while(!(UART0->S1 & UART_S1_RDRF_MASK));
000002  7901              LDRB     r1,[r0,#4]
000004  0689              LSLS     r1,r1,#26
000006  d5fc              BPL      |L9.2|
;;;34     	return UART0->D;
000008  79c0              LDRB     r0,[r0,#7]
;;;35     }
00000a  4770              BX       lr
;;;36     
                          ENDP

                  |L9.12|
                          DCD      0x4006a000

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;24     //Retarget the fputc method to use the UART0
;;;25     int fputc(int ch, FILE *f){
000000  4904              LDR      r1,|L10.20|
                  |L10.2|
;;;26     	while(!(UART0->S1 & UART_S1_TDRE_MASK) && !(UART0->S1 & UART_S1_TC_MASK));
000002  790a              LDRB     r2,[r1,#4]
000004  0612              LSLS     r2,r2,#24
000006  d402              BMI      |L10.14|
000008  790a              LDRB     r2,[r1,#4]
00000a  0652              LSLS     r2,r2,#25
00000c  d5f9              BPL      |L10.2|
                  |L10.14|
;;;27     	UART0->D = ch;
00000e  71c8              STRB     r0,[r1,#7]
;;;28     	return ch;
;;;29     }
000010  4770              BX       lr
;;;30     
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x4006a000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  TxQ
                          %        268
                  ||RxQ||
                          %        268

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Source\\UART.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_UART_c_fputc____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_UART_c_fputc____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_UART_c_fputc____REVSH|
#line 462
|__asm___6_UART_c_fputc____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
