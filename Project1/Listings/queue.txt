; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\queue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\queue.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork//ropi -O3 --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\queue.crf --remarks Source\queue.c]
                          THUMB

                          AREA ||i.Q_Dequeue||, CODE, READONLY, ALIGN=1

                  Q_Dequeue PROC
;;;45     
;;;46     uint8_t Q_Dequeue(Q_T * q) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;47     	uint32_t masking_state;
;;;48       uint8_t t=0;
000004  2200              MOVS     r2,#0
;;;49       // Check to see if queue is empty before dequeueing
;;;50       if (!Q_Empty(q)) {
000006  f7fffffe          BL       Q_Empty
00000a  2800              CMP      r0,#0
00000c  d114              BNE      |L1.56|
;;;51         t = q->Data[q->Head];
00000e  680a              LDR      r2,[r1,#0]
000010  4608              MOV      r0,r1
000012  300c              ADDS     r0,r0,#0xc
000014  5c12              LDRB     r2,[r2,r0]
;;;52         q->Data[q->Head++] = '_'; // empty unused entries for debugging
000016  6808              LDR      r0,[r1,#0]
000018  235f              MOVS     r3,#0x5f
00001a  180c              ADDS     r4,r1,r0
00001c  1c40              ADDS     r0,r0,#1
00001e  6008              STR      r0,[r1,#0]
000020  7323              STRB     r3,[r4,#0xc]
;;;53     		q->Head %= Q_MAX_SIZE;
000022  6808              LDR      r0,[r1,#0]
000024  b2c0              UXTB     r0,r0
000026  6008              STR      r0,[r1,#0]
000028  f3ef8010          MRS      r0,PRIMASK
;;;54     
;;;55     		// protect q->Size-- operation from preemption
;;;56     		// save current masking state
;;;57     		masking_state = __get_PRIMASK();
;;;58     		// disable interrupts
;;;59     		__disable_irq();
00002c  b672              CPSID    i
;;;60     		// update variable
;;;61         q->Size--;
00002e  688b              LDR      r3,[r1,#8]
000030  1e5b              SUBS     r3,r3,#1
000032  608b              STR      r3,[r1,#8]
000034  f3808810          MSR      PRIMASK,r0
                  |L1.56|
;;;62     		// restore  interrupt masking state
;;;63     		__set_PRIMASK(masking_state);
;;;64       }
;;;65       return t;
000038  4610              MOV      r0,r2
;;;66     }
00003a  bd10              POP      {r4,pc}
;;;67     
                          ENDP


                          AREA ||i.Q_Empty||, CODE, READONLY, ALIGN=1

                  Q_Empty PROC
;;;11     
;;;12     int Q_Empty(Q_T * q) {
000000  6880              LDR      r0,[r0,#8]
;;;13       return q->Size == 0;
000002  2800              CMP      r0,#0
000004  d001              BEQ      |L2.10|
000006  2000              MOVS     r0,#0
;;;14     }
000008  4770              BX       lr
                  |L2.10|
00000a  2001              MOVS     r0,#1                 ;13
00000c  4770              BX       lr
;;;15     
                          ENDP


                          AREA ||i.Q_Enqueue||, CODE, READONLY, ALIGN=1

                  Q_Enqueue PROC
;;;23     
;;;24     int Q_Enqueue(Q_T * q, uint8_t d) {
000000  b500              PUSH     {lr}
000002  460b              MOV      r3,r1
000004  4602              MOV      r2,r0
;;;25     	uint32_t masking_state;
;;;26       // If queue is full, don't overwrite data, but do return an error code
;;;27       if (!Q_Full(q)) {
000006  f7fffffe          BL       Q_Full
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L3.18|
;;;28         q->Data[q->Tail++] = d;
;;;29         q->Tail %= Q_MAX_SIZE;
;;;30     		
;;;31     		// protect q->Size++ operation from preemption
;;;32     		// save current masking state
;;;33     		masking_state = __get_PRIMASK();
;;;34     		// disable interrupts
;;;35     		__disable_irq();
;;;36     		// update variable
;;;37         q->Size++;
;;;38     		// restore  interrupt masking state
;;;39     		__set_PRIMASK(masking_state);
;;;40     		
;;;41         return 1; // success
;;;42       } else 
;;;43         return 0; // failure
00000e  2000              MOVS     r0,#0
;;;44     }
000010  bd00              POP      {pc}
                  |L3.18|
000012  6850              LDR      r0,[r2,#4]            ;28
000014  1811              ADDS     r1,r2,r0              ;28
000016  1c40              ADDS     r0,r0,#1              ;28
000018  6050              STR      r0,[r2,#4]            ;28
00001a  730b              STRB     r3,[r1,#0xc]          ;28
00001c  6850              LDR      r0,[r2,#4]            ;29
00001e  b2c0              UXTB     r0,r0                 ;29
000020  6050              STR      r0,[r2,#4]            ;29
000022  f3ef8010          MRS      r0,PRIMASK            ;29
000026  b672              CPSID    i                     ;35
000028  6891              LDR      r1,[r2,#8]            ;37
00002a  1c49              ADDS     r1,r1,#1              ;37
00002c  6091              STR      r1,[r2,#8]            ;37
00002e  f3808810          MSR      PRIMASK,r0            ;37
000032  2001              MOVS     r0,#1                 ;41
000034  bd00              POP      {pc}
;;;45     
                          ENDP


                          AREA ||i.Q_Full||, CODE, READONLY, ALIGN=1

                  Q_Full PROC
;;;15     
;;;16     int Q_Full(Q_T * q) {
000000  6880              LDR      r0,[r0,#8]
;;;17       return q->Size == Q_MAX_SIZE;
000002  1fc1              SUBS     r1,r0,#7
000004  39f9              SUBS     r1,r1,#0xf9
000006  d001              BEQ      |L4.12|
000008  2000              MOVS     r0,#0
;;;18     }
00000a  4770              BX       lr
                  |L4.12|
00000c  2001              MOVS     r0,#1                 ;17
00000e  4770              BX       lr
;;;19     
                          ENDP


                          AREA ||i.Q_Init||, CODE, READONLY, ALIGN=1

                  Q_Init PROC
;;;2      
;;;3      void Q_Init(Q_T * q) {
000000  2100              MOVS     r1,#0
;;;4        unsigned int i;
;;;5        for (i=0; i<Q_MAX_SIZE; i++)  
;;;6          q->Data[i] = '_';  // to simplify our lives when debugging
000002  225f              MOVS     r2,#0x5f
                  |L5.4|
000004  1843              ADDS     r3,r0,r1
000006  731a              STRB     r2,[r3,#0xc]
000008  1c49              ADDS     r1,r1,#1
00000a  29ff              CMP      r1,#0xff              ;5
00000c  d9fa              BLS      |L5.4|
;;;7        q->Head = 0;
00000e  2100              MOVS     r1,#0
000010  6001              STR      r1,[r0,#0]
;;;8        q->Tail = 0;
000012  6041              STR      r1,[r0,#4]
;;;9        q->Size = 0;
000014  6081              STR      r1,[r0,#8]
;;;10     }
000016  4770              BX       lr
;;;11     
                          ENDP


                          AREA ||i.Q_Size||, CODE, READONLY, ALIGN=1

                  Q_Size PROC
;;;19     
;;;20     int Q_Size(Q_T * q) {
000000  6880              LDR      r0,[r0,#8]
;;;21     	return q->Size;
;;;22     }
000002  4770              BX       lr
;;;23     
                          ENDP


;*** Start embedded assembler ***

#line 1 "Source\\queue.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_Q_Init____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_queue_c_Q_Init____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_Q_Init____REVSH|
#line 462
|__asm___7_queue_c_Q_Init____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
