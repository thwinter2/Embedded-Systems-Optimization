; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\sd_io.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\sd_io.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\sd_io.crf Source\ulibSD\sd_io.c]
                          THUMB

                          AREA ||i.SD_Init||, CODE, READONLY, ALIGN=2

                  SD_Init PROC
;;;228    
;;;229    SDRESULTS SD_Init(SD_DEV * dev) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4606              MOV      r6,r0
;;;230    	BYTE n, cmd, ct, ocr[4];
;;;231    	BYTE idx;
;;;232    	BYTE init_trys;
;;;233    	#if DEBUG_ENABLE
;;;234    	DEBUG_START(DBG_5);
000004  2001              MOVS     r0,#1
000006  4978              LDR      r1,|L1.488|
000008  b085              SUB      sp,sp,#0x14           ;229
00000a  0240              LSLS     r0,r0,#9
00000c  6048              STR      r0,[r1,#4]
;;;235    	#endif
;;;236    	ct = 0;
00000e  2200              MOVS     r2,#0
;;;237    	for (init_trys = 0; ((init_trys != SD_INIT_TRYS) && (!ct));
000010  4617              MOV      r7,r2
000012  9201              STR      r2,[sp,#4]
                  |L1.20|
;;;238    			 init_trys++) {
;;;239    		// Initialize SPI for use with the memory card
;;;240    		SPI_Init();
000014  f7fffffe          BL       SPI_Init
;;;241    		
;;;242    
;;;243    		SPI_CS_High();
000018  f7fffffe          BL       SPI_CS_High
;;;244    		SPI_Freq_High();
00001c  f7fffffe          BL       SPI_Freq_High
;;;245    
;;;246    		// 80 dummy clocks
;;;247    		for (idx = 0; idx != 10; idx++){
000020  2400              MOVS     r4,#0
                  |L1.34|
;;;248    			SPI_RW(0xFF);
000022  20ff              MOVS     r0,#0xff
000024  f7fffffe          BL       SPI_RW
000028  1c64              ADDS     r4,r4,#1
00002a  b2e4              UXTB     r4,r4                 ;247
00002c  2c0a              CMP      r4,#0xa               ;247
00002e  d1f8              BNE      |L1.34|
;;;249    		}
;;;250    		SPI_Timer_On(500);
000030  20ff              MOVS     r0,#0xff
000032  30f5              ADDS     r0,r0,#0xf5
000034  f7fffffe          BL       SPI_Timer_On
;;;251    		while (SPI_Timer_Status() == TRUE) {
000038  f7fffffe          BL       SPI_Timer_Status
00003c  2801              CMP      r0,#1
00003e  d106              BNE      |L1.78|
000040  4d69              LDR      r5,|L1.488|
000042  0244              LSLS     r4,r0,#9              ;234
                  |L1.68|
;;;252    			#if DEBUG_ENABLE
;;;253    			DEBUG_TOGGLE(DBG_5)
000044  60ec              STR      r4,[r5,#0xc]
000046  f7fffffe          BL       SPI_Timer_Status
00004a  2801              CMP      r0,#1                 ;251
00004c  d0fa              BEQ      |L1.68|
                  |L1.78|
;;;254    			#endif
;;;255    		}
;;;256    		#if DEBUG_ENABLE
;;;257    		DEBUG_START(DBG_5);
00004e  2501              MOVS     r5,#1
000050  4c65              LDR      r4,|L1.488|
000052  026d              LSLS     r5,r5,#9
000054  6065              STR      r5,[r4,#4]
;;;258    		#endif
;;;259    		SPI_Timer_Off();
000056  f7fffffe          BL       SPI_Timer_Off
;;;260    
;;;261    		dev->mount = FALSE;
00005a  2000              MOVS     r0,#0
00005c  7030              STRB     r0,[r6,#0]
;;;262    		SPI_Timer_On(500);
00005e  20ff              MOVS     r0,#0xff
000060  30f5              ADDS     r0,r0,#0xf5
000062  f7fffffe          BL       SPI_Timer_On
;;;263    		while ((__SD_Send_Cmd(CMD0, 0) != 1)
000066  e000              B        |L1.106|
                  |L1.104|
;;;264    					 && (SPI_Timer_Status() == TRUE)) {
;;;265    						#if DEBUG_ENABLE
;;;266    						DEBUG_TOGGLE(DBG_5);
000068  60e5              STR      r5,[r4,#0xc]
                  |L1.106|
00006a  2100              MOVS     r1,#0                 ;263
00006c  2040              MOVS     r0,#0x40              ;263
00006e  f7fffffe          BL       __SD_Send_Cmd
000072  2801              CMP      r0,#1                 ;263
000074  d003              BEQ      |L1.126|
000076  f7fffffe          BL       SPI_Timer_Status
00007a  2801              CMP      r0,#1                 ;264
00007c  d0f4              BEQ      |L1.104|
                  |L1.126|
;;;267    						#endif
;;;268    		}
;;;269    		#if DEBUG_ENABLE
;;;270    		DEBUG_START(DBG_5);
00007e  2001              MOVS     r0,#1
000080  4959              LDR      r1,|L1.488|
000082  0240              LSLS     r0,r0,#9
000084  6048              STR      r0,[r1,#4]
;;;271    		#endif
;;;272    		SPI_Timer_Off();
000086  f7fffffe          BL       SPI_Timer_Off
;;;273    		// Idle state
;;;274    		if (__SD_Send_Cmd(CMD0, 0) == 1) {
00008a  2100              MOVS     r1,#0
00008c  2040              MOVS     r0,#0x40
00008e  f7fffffe          BL       __SD_Send_Cmd
000092  2801              CMP      r0,#1
000094  d17e              BNE      |L1.404|
;;;275    			// SD version 2?
;;;276    			if (__SD_Send_Cmd(CMD8, 0x1AA) == 1) {
000096  21ff              MOVS     r1,#0xff
000098  31ab              ADDS     r1,r1,#0xab
00009a  2048              MOVS     r0,#0x48
00009c  f7fffffe          BL       __SD_Send_Cmd
0000a0  2801              CMP      r0,#1
0000a2  d009              BEQ      |L1.184|
;;;277    				// Get trailing return value of R7 resp
;;;278    				for (n = 0; n < 4; n++){
;;;279    					ocr[n] = SPI_RW(0xFF);
;;;280    					/*while (!(SPI1_S & SPI_S_SPTEF_MASK)) {
;;;281    					}
;;;282    					SPI1_D = 0xff;
;;;283    					while (!(SPI1_S & SPI_S_SPRF_MASK)) {
;;;284    					}
;;;285    					ocr[n] = SPI1_D;*/
;;;286    				}
;;;287    				// VDD range of 2.7-3.6V is OK?  
;;;288    				if ((ocr[2] == 0x01) && (ocr[3] == 0xAA)) {
;;;289    					// Wait for leaving idle state (ACMD41 with HCS bit)...
;;;290    					SPI_Timer_On(1000);
;;;291    					while ((SPI_Timer_Status() == TRUE)
;;;292    								 && (__SD_Send_Cmd(ACMD41, 1UL << 30))) {
;;;293    						#if DEBUG_ENABLE
;;;294    						DEBUG_TOGGLE(DBG_5);
;;;295    						#endif
;;;296    					}
;;;297    					#if DEBUG_ENABLE
;;;298    					DEBUG_START(DBG_5);
;;;299    					#endif
;;;300    					SPI_Timer_Off();
;;;301    					// CCS in the OCR? 
;;;302    					if ((SPI_Timer_Status() == TRUE)
;;;303    							&& (__SD_Send_Cmd(CMD58, 0) == 0)) {
;;;304    						for (n = 0; n < 4; n++){
;;;305    	
;;;306    							ocr[n] = SPI_RW(0xFF);
;;;307    							/*while (!(SPI1_S & SPI_S_SPTEF_MASK)) {
;;;308    							}
;;;309    							SPI1_D = 0xff;
;;;310    							while (!(SPI1_S & SPI_S_SPRF_MASK)) {
;;;311    							}
;;;312    							ocr[n] = SPI1_D;*/
;;;313    						}
;;;314    						// SD version 2?
;;;315    						ct = (ocr[0] & 0x40) ? SDCT_SD2 | SDCT_BLOCK : SDCT_SD2;
;;;316    					}
;;;317    				}
;;;318    			} else {
;;;319    				// SD version 1 or MMC?
;;;320    				if (__SD_Send_Cmd(ACMD41, 0) <= 1) {
0000a4  2100              MOVS     r1,#0
0000a6  20e9              MOVS     r0,#0xe9
0000a8  f7fffffe          BL       __SD_Send_Cmd
0000ac  2801              CMP      r0,#1
0000ae  d848              BHI      |L1.322|
;;;321    					// SD version 1
;;;322    					ct = SDCT_SD1;
0000b0  2002              MOVS     r0,#2
;;;323    					cmd = ACMD41;
0000b2  9001              STR      r0,[sp,#4]
0000b4  20e9              MOVS     r0,#0xe9
0000b6  e047              B        |L1.328|
                  |L1.184|
0000b8  2400              MOVS     r4,#0                 ;278
0000ba  466d              MOV      r5,sp                 ;230
                  |L1.188|
0000bc  20ff              MOVS     r0,#0xff              ;279
0000be  f7fffffe          BL       SPI_RW
0000c2  5528              STRB     r0,[r5,r4]            ;279
0000c4  1c64              ADDS     r4,r4,#1              ;279
0000c6  b2e4              UXTB     r4,r4                 ;278
0000c8  2c04              CMP      r4,#4                 ;278
0000ca  d3f7              BCC      |L1.188|
0000cc  4668              MOV      r0,sp                 ;288
0000ce  7880              LDRB     r0,[r0,#2]            ;288
0000d0  2801              CMP      r0,#1                 ;288
0000d2  d15f              BNE      |L1.404|
0000d4  4668              MOV      r0,sp                 ;288
0000d6  78c0              LDRB     r0,[r0,#3]            ;288
0000d8  28aa              CMP      r0,#0xaa              ;288
0000da  d15b              BNE      |L1.404|
0000dc  207d              MOVS     r0,#0x7d              ;290
0000de  00c0              LSLS     r0,r0,#3              ;290
0000e0  f7fffffe          BL       SPI_Timer_On
0000e4  2401              MOVS     r4,#1                 ;234
0000e6  0264              LSLS     r4,r4,#9              ;234
0000e8  e001              B        |L1.238|
                  |L1.234|
0000ea  483f              LDR      r0,|L1.488|
0000ec  60c4              STR      r4,[r0,#0xc]          ;294
                  |L1.238|
0000ee  f7fffffe          BL       SPI_Timer_Status
0000f2  2801              CMP      r0,#1                 ;291
0000f4  d105              BNE      |L1.258|
0000f6  0781              LSLS     r1,r0,#30             ;292
0000f8  20e9              MOVS     r0,#0xe9              ;292
0000fa  f7fffffe          BL       __SD_Send_Cmd
0000fe  2800              CMP      r0,#0                 ;292
000100  d1f3              BNE      |L1.234|
                  |L1.258|
000102  4839              LDR      r0,|L1.488|
000104  6044              STR      r4,[r0,#4]            ;298
000106  f7fffffe          BL       SPI_Timer_Off
00010a  f7fffffe          BL       SPI_Timer_Status
00010e  2801              CMP      r0,#1                 ;302
000110  d140              BNE      |L1.404|
000112  2100              MOVS     r1,#0                 ;303
000114  207a              MOVS     r0,#0x7a              ;303
000116  f7fffffe          BL       __SD_Send_Cmd
00011a  2800              CMP      r0,#0                 ;303
00011c  d13a              BNE      |L1.404|
00011e  2400              MOVS     r4,#0                 ;304
                  |L1.288|
000120  20ff              MOVS     r0,#0xff              ;306
000122  f7fffffe          BL       SPI_RW
000126  5528              STRB     r0,[r5,r4]            ;306
000128  1c64              ADDS     r4,r4,#1              ;306
00012a  b2e4              UXTB     r4,r4                 ;304
00012c  2c04              CMP      r4,#4                 ;304
00012e  d3f7              BCC      |L1.288|
000130  4668              MOV      r0,sp                 ;315
000132  7800              LDRB     r0,[r0,#0]            ;315
000134  0640              LSLS     r0,r0,#25             ;315
000136  d501              BPL      |L1.316|
000138  200c              MOVS     r0,#0xc               ;315
00013a  e000              B        |L1.318|
                  |L1.316|
00013c  2004              MOVS     r0,#4                 ;315
                  |L1.318|
00013e  9001              STR      r0,[sp,#4]            ;315
000140  e028              B        |L1.404|
                  |L1.322|
;;;324    				} else {
;;;325    					// MMC version 3
;;;326    					ct = SDCT_MMC;
000142  2001              MOVS     r0,#1
;;;327    					cmd = CMD1;
000144  9001              STR      r0,[sp,#4]
000146  2041              MOVS     r0,#0x41
                  |L1.328|
;;;328    				}
;;;329    				// Wait for leaving idle state
;;;330    				SPI_Timer_On(250);
000148  9003              STR      r0,[sp,#0xc]
00014a  20fa              MOVS     r0,#0xfa
00014c  f7fffffe          BL       SPI_Timer_On
000150  2401              MOVS     r4,#1                 ;234
000152  4d25              LDR      r5,|L1.488|
000154  0264              LSLS     r4,r4,#9              ;234
;;;331    				while ((SPI_Timer_Status() == TRUE)
000156  e000              B        |L1.346|
                  |L1.344|
;;;332    							 && (__SD_Send_Cmd(cmd, 0))) {
;;;333    					#if DEBUG_ENABLE
;;;334    					DEBUG_TOGGLE(DBG_5);
000158  60ec              STR      r4,[r5,#0xc]
                  |L1.346|
00015a  f7fffffe          BL       SPI_Timer_Status
00015e  2801              CMP      r0,#1                 ;331
000160  d105              BNE      |L1.366|
000162  2100              MOVS     r1,#0                 ;332
000164  9803              LDR      r0,[sp,#0xc]          ;332
000166  f7fffffe          BL       __SD_Send_Cmd
00016a  2800              CMP      r0,#0                 ;332
00016c  d1f4              BNE      |L1.344|
                  |L1.366|
;;;335    					#endif								 
;;;336    				}
;;;337    				#if DEBUG_ENABLE
;;;338    				DEBUG_START(DBG_5);
00016e  606c              STR      r4,[r5,#4]
;;;339    				#endif
;;;340    				SPI_Timer_Off();
000170  f7fffffe          BL       SPI_Timer_Off
;;;341    				//if (SPI_Timer_Status() == FALSE)
;;;342    					//ct = 0;
;;;343    				if (__SD_Send_Cmd(CMD59, 0))
000174  2100              MOVS     r1,#0
000176  207b              MOVS     r0,#0x7b
000178  f7fffffe          BL       __SD_Send_Cmd
00017c  2800              CMP      r0,#0
00017e  d001              BEQ      |L1.388|
;;;344    					ct = 0;								// Deactivate CRC check (default)
000180  2000              MOVS     r0,#0
000182  9001              STR      r0,[sp,#4]
                  |L1.388|
;;;345    				if (__SD_Send_Cmd(CMD16, 512))
000184  4621              MOV      r1,r4
000186  2050              MOVS     r0,#0x50
000188  f7fffffe          BL       __SD_Send_Cmd
00018c  2800              CMP      r0,#0
00018e  d001              BEQ      |L1.404|
;;;346    					ct = 0;								// Set R/W block length to 512 bytes
000190  2000              MOVS     r0,#0
000192  9001              STR      r0,[sp,#4]
                  |L1.404|
000194  1c7f              ADDS     r7,r7,#1
000196  b2ff              UXTB     r7,r7                 ;238
000198  9801              LDR      r0,[sp,#4]            ;238
00019a  2f03              CMP      r7,#3                 ;237
00019c  d003              BEQ      |L1.422|
00019e  2800              CMP      r0,#0                 ;237
0001a0  d100              BNE      |L1.420|
0001a2  e737              B        |L1.20|
                  |L1.420|
0001a4  e001              B        |L1.426|
                  |L1.422|
;;;347    			}
;;;348    		}
;;;349    	}
;;;350    	if (ct) {
0001a6  2800              CMP      r0,#0
0001a8  d015              BEQ      |L1.470|
                  |L1.426|
;;;351    		dev->cardtype = ct;
0001aa  7070              STRB     r0,[r6,#1]
;;;352    		dev->mount = TRUE;
0001ac  2001              MOVS     r0,#1
0001ae  7030              STRB     r0,[r6,#0]
;;;353    		dev->last_sector = __SD_Sectors(dev) - 1;
0001b0  4630              MOV      r0,r6
0001b2  f7fffffe          BL       __SD_Sectors
0001b6  1e40              SUBS     r0,r0,#1
;;;354    		dev->debug.read = 0;
0001b8  6070              STR      r0,[r6,#4]
0001ba  2000              MOVS     r0,#0
0001bc  8130              STRH     r0,[r6,#8]
;;;355    		dev->debug.write = 0;
0001be  8170              STRH     r0,[r6,#0xa]
0001c0  f7fffffe          BL       SPI_Freq_High
;;;356    		__SD_Speed_Transfer(HIGH);	// High speed transfer
;;;357    	}
;;;358    	SPI_Release();
0001c4  f7fffffe          BL       SPI_Release
;;;359    	#if DEBUG_ENABLE
;;;360    	DEBUG_STOP(DBG_5);
0001c8  2001              MOVS     r0,#1
0001ca  4907              LDR      r1,|L1.488|
0001cc  0240              LSLS     r0,r0,#9
0001ce  6088              STR      r0,[r1,#8]
;;;361    	#endif
;;;362    	return (ct ? SD_OK : SD_NOINIT);
0001d0  2000              MOVS     r0,#0
;;;363    }
0001d2  b005              ADD      sp,sp,#0x14
0001d4  bdf0              POP      {r4-r7,pc}
                  |L1.470|
0001d6  f7fffffe          BL       SPI_Release
0001da  2001              MOVS     r0,#1                 ;360
0001dc  4902              LDR      r1,|L1.488|
0001de  0240              LSLS     r0,r0,#9              ;360
0001e0  6088              STR      r0,[r1,#8]            ;360
0001e2  2001              MOVS     r0,#1                 ;362
0001e4  b005              ADD      sp,sp,#0x14
0001e6  bdf0              POP      {r4-r7,pc}
;;;364    
                          ENDP

                  |L1.488|
                          DCD      0xf80ff040

                          AREA ||i.SD_Read||, CODE, READONLY, ALIGN=2

                  SD_Read PROC
;;;367    #pragma diag_suppress 1441
;;;368    SDRESULTS SD_Read(SD_DEV * dev, void *dat, DWORD sector, WORD ofs,
000000  b5ff              PUSH     {r0-r7,lr}
;;;369    									WORD cnt) {
;;;370    	SDRESULTS res;
;;;371    	WORD byte_num;
;;;372    	BYTE tkn, data;
;;;373    	volatile uint8_t dummy;
;;;374    	#if DEBUG_ENABLE
;;;375    	DEBUG_START(DBG_2);
000002  483c              LDR      r0,|L2.244|
000004  b081              SUB      sp,sp,#4              ;369
000006  2404              MOVS     r4,#4
000008  461e              MOV      r6,r3                 ;369
00000a  460d              MOV      r5,r1                 ;369
00000c  6044              STR      r4,[r0,#4]
;;;376    	#endif
;;;377    
;;;378    	res = SD_ERROR;
00000e  2002              MOVS     r0,#2
;;;379    	if ((sector > dev->last_sector) || (cnt == 0)) {
000010  9000              STR      r0,[sp,#0]
000012  9801              LDR      r0,[sp,#4]
000014  6840              LDR      r0,[r0,#4]
000016  4290              CMP      r0,r2
000018  d309              BCC      |L2.46|
00001a  980a              LDR      r0,[sp,#0x28]
00001c  2800              CMP      r0,#0
00001e  d006              BEQ      |L2.46|
;;;380    		#if DEBUG_ENABLE
;;;381    		DEBUG_STOP(DBG_2);
;;;382    		#endif
;;;383    		return (SD_PARERR);
;;;384    	}
;;;385    	// Convert sector number to byte address (sector * SD_BLK_SIZE)
;;;386    	//    if (__SD_Send_Cmd(CMD17, sector * SD_BLK_SIZE) == 0) { // Only for SDSC
;;;387    	if (__SD_Send_Cmd(CMD17, sector) == 0) {	// Only for SDHC or SDXC 
000020  4611              MOV      r1,r2
000022  2051              MOVS     r0,#0x51
000024  f7fffffe          BL       __SD_Send_Cmd
000028  2800              CMP      r0,#0
00002a  d005              BEQ      |L2.56|
00002c  e02d              B        |L2.138|
                  |L2.46|
00002e  4831              LDR      r0,|L2.244|
000030  6084              STR      r4,[r0,#8]            ;381
000032  2003              MOVS     r0,#3                 ;383
;;;388    		
;;;389    		SPI_Timer_On(100);
;;;390    		SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;	// Make sure clock is enabled
;;;391    		LPTMR0_CSR = 0;								// Reset LPTMR settings
;;;392    		LPTMR0_CMR = 100;							// Set compare value (in ms)
;;;393    		// Use 1kHz LPO with no prescaler
;;;394    		LPTMR0_PSR = LPTMR_PSR_PCS(1) | LPTMR_PSR_PBYP_MASK;
;;;395    		// Start the timer and wait for it to reach the compare value
;;;396    		LPTMR0_CSR = LPTMR_CSR_TEN_MASK;
;;;397    		
;;;398    		do {
;;;399    			#if DEBUG_ENABLE
;;;400    			DEBUG_TOGGLE(DBG_2);
;;;401    			#endif
;;;402    			
;;;403    			//tkn = SPI_RW(0xFF);
;;;404    			SPI1_D = 0xFF;
;;;405    			while (!(SPI1_S & SPI_S_SPTEF_MASK)) {
;;;406    			}
;;;407    			while (!(SPI1_S & SPI_S_SPRF_MASK)) {
;;;408    			}
;;;409    			tkn = SPI1_D;
;;;410    				
;;;411    		} while ((tkn == 0xFF) && (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK)));
;;;412    		#if DEBUG_ENABLE
;;;413    		DEBUG_START(DBG_2);
;;;414    		#endif
;;;415    		//SPI_Timer_Off();
;;;416    		LPTMR0_CSR = 0;
;;;417    		// Token of single block?
;;;418    		if (tkn == 0xFE) {
;;;419    			// AGD: Loop fusion to simplify FSM formation
;;;420    			byte_num = 0;
;;;421    			do {
;;;422    				#if DEBUG_ENABLE
;;;423    				DEBUG_TOGGLE(DBG_2); 
;;;424    				#endif
;;;425    				
;;;426    				//data = SPI_RW(0xff);
;;;427    				SPI1_D = 0xff;
;;;428    				while (!(SPI1_S & SPI_S_SPTEF_MASK)) {
;;;429    				}
;;;430    				while (!(SPI1_S & SPI_S_SPRF_MASK)) {
;;;431    				}
;;;432    				data = SPI1_D;
;;;433    	
;;;434    				if ((byte_num >= ofs) && (byte_num < ofs + cnt)) {
;;;435    					*(BYTE *) dat = data;
;;;436    					((BYTE *) dat)++;
;;;437    				}												// else discard bytes before and after data
;;;438    			} while (++byte_num < SD_BLK_SIZE + 2);	// 512 byte block + 2 byte CRC
;;;439    			#if DEBUG_ENABLE
;;;440    			DEBUG_START(DBG_2);
;;;441    			#endif
;;;442    			res = SD_OK;
;;;443    		}
;;;444    	}
;;;445    	//SPI_Release();
;;;446    	for (WORD idx = 512; idx && (SPI_RW(0xFF) != 0xFF); idx--);
;;;447    	dev->debug.read++;
;;;448    	#if DEBUG_ENABLE
;;;449    	DEBUG_STOP(DBG_2);
;;;450    	#endif
;;;451    	return (res);
;;;452    }
000034  b005              ADD      sp,sp,#0x14
000036  bdf0              POP      {r4-r7,pc}
                  |L2.56|
000038  2064              MOVS     r0,#0x64              ;389
00003a  f7fffffe          BL       SPI_Timer_On
00003e  482e              LDR      r0,|L2.248|
000040  6b82              LDR      r2,[r0,#0x38]         ;390
000042  2101              MOVS     r1,#1                 ;390
000044  430a              ORRS     r2,r2,r1              ;390
000046  6382              STR      r2,[r0,#0x38]         ;390
000048  482c              LDR      r0,|L2.252|
00004a  2200              MOVS     r2,#0                 ;391
00004c  6002              STR      r2,[r0,#0]            ;391
00004e  2264              MOVS     r2,#0x64              ;392
000050  6082              STR      r2,[r0,#8]            ;392
000052  2205              MOVS     r2,#5                 ;394
000054  6042              STR      r2,[r0,#4]            ;394
000056  6001              STR      r1,[r0,#0]            ;396
000058  4829              LDR      r0,|L2.256|
00005a  4b26              LDR      r3,|L2.244|
00005c  22ff              MOVS     r2,#0xff              ;404
                  |L2.94|
00005e  60dc              STR      r4,[r3,#0xc]          ;400
000060  7142              STRB     r2,[r0,#5]            ;404
                  |L2.98|
000062  78c1              LDRB     r1,[r0,#3]            ;405
000064  0689              LSLS     r1,r1,#26             ;405
000066  d5fc              BPL      |L2.98|
                  |L2.104|
000068  78c1              LDRB     r1,[r0,#3]            ;407
00006a  0609              LSLS     r1,r1,#24             ;407
00006c  d5fc              BPL      |L2.104|
00006e  7941              LDRB     r1,[r0,#5]            ;409
000070  29ff              CMP      r1,#0xff              ;411
000072  d103              BNE      |L2.124|
000074  4f21              LDR      r7,|L2.252|
000076  683f              LDR      r7,[r7,#0]            ;411
000078  063f              LSLS     r7,r7,#24             ;411
00007a  d5f0              BPL      |L2.94|
                  |L2.124|
00007c  4b1d              LDR      r3,|L2.244|
00007e  605c              STR      r4,[r3,#4]            ;413
000080  4f1e              LDR      r7,|L2.252|
000082  2300              MOVS     r3,#0                 ;416
000084  603b              STR      r3,[r7,#0]            ;416
000086  29fe              CMP      r1,#0xfe              ;418
000088  d002              BEQ      |L2.144|
                  |L2.138|
00008a  2501              MOVS     r5,#1                 ;446
00008c  026d              LSLS     r5,r5,#9              ;446
00008e  e021              B        |L2.212|
                  |L2.144|
000090  9a0a              LDR      r2,[sp,#0x28]         ;434
000092  2100              MOVS     r1,#0                 ;420
000094  4f17              LDR      r7,|L2.244|
000096  18b3              ADDS     r3,r6,r2              ;434
                  |L2.152|
000098  60fc              STR      r4,[r7,#0xc]          ;423
00009a  22ff              MOVS     r2,#0xff              ;427
00009c  7142              STRB     r2,[r0,#5]            ;427
                  |L2.158|
00009e  78c2              LDRB     r2,[r0,#3]            ;428
0000a0  0692              LSLS     r2,r2,#26             ;428
0000a2  d5fc              BPL      |L2.158|
                  |L2.164|
0000a4  78c2              LDRB     r2,[r0,#3]            ;430
0000a6  0612              LSLS     r2,r2,#24             ;430
0000a8  d5fc              BPL      |L2.164|
0000aa  7942              LDRB     r2,[r0,#5]            ;432
0000ac  42b1              CMP      r1,r6                 ;434
0000ae  d303              BCC      |L2.184|
0000b0  428b              CMP      r3,r1                 ;434
0000b2  d901              BLS      |L2.184|
0000b4  702a              STRB     r2,[r5,#0]            ;435
0000b6  1c6d              ADDS     r5,r5,#1              ;435
                  |L2.184|
0000b8  1c49              ADDS     r1,r1,#1              ;435
0000ba  4a12              LDR      r2,|L2.260|
0000bc  b289              UXTH     r1,r1                 ;438
0000be  4291              CMP      r1,r2                 ;438
0000c0  d3ea              BCC      |L2.152|
0000c2  607c              STR      r4,[r7,#4]            ;440
0000c4  2000              MOVS     r0,#0                 ;442
0000c6  1e95              SUBS     r5,r2,#2              ;446
0000c8  9000              STR      r0,[sp,#0]            ;442
0000ca  e003              B        |L2.212|
                  |L2.204|
0000cc  1e6d              SUBS     r5,r5,#1              ;442
0000ce  042d              LSLS     r5,r5,#16             ;446
0000d0  0c2d              LSRS     r5,r5,#16             ;446
0000d2  d004              BEQ      |L2.222|
                  |L2.212|
0000d4  20ff              MOVS     r0,#0xff              ;446
0000d6  f7fffffe          BL       SPI_RW
0000da  28ff              CMP      r0,#0xff              ;446
0000dc  d1f6              BNE      |L2.204|
                  |L2.222|
0000de  9801              LDR      r0,[sp,#4]            ;447
0000e0  9901              LDR      r1,[sp,#4]            ;447
0000e2  8900              LDRH     r0,[r0,#8]            ;447
0000e4  1c40              ADDS     r0,r0,#1              ;447
0000e6  8108              STRH     r0,[r1,#8]            ;447
0000e8  4802              LDR      r0,|L2.244|
0000ea  6084              STR      r4,[r0,#8]            ;449
0000ec  9800              LDR      r0,[sp,#0]            ;451
0000ee  b005              ADD      sp,sp,#0x14
0000f0  bdf0              POP      {r4-r7,pc}
;;;453    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L2.244|
                          DCD      0xf80ff040
                  |L2.248|
                          DCD      0x40048000
                  |L2.252|
                          DCD      0x40040000
                  |L2.256|
                          DCD      0x40077000
                  |L2.260|
                          DCD      0x00000202

                          AREA ||i.SD_Status||, CODE, READONLY, ALIGN=1

                  SD_Status PROC
;;;520    
;;;521    SDRESULTS SD_Status(SD_DEV * dev) {
000000  b510              PUSH     {r4,lr}
;;;522    	return (__SD_Send_Cmd(CMD0, 0) ? SD_OK : SD_NORESPONSE);
000002  2100              MOVS     r1,#0
000004  2040              MOVS     r0,#0x40
000006  f7fffffe          BL       __SD_Send_Cmd
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L3.18|
00000e  2000              MOVS     r0,#0
;;;523    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  2006              MOVS     r0,#6                 ;522
000014  bd10              POP      {r4,pc}
;;;524    
                          ENDP


                          AREA ||i.SD_Write||, CODE, READONLY, ALIGN=2

                  SD_Write PROC
;;;455    
;;;456    SDRESULTS SD_Write(SD_DEV * dev, void *dat, DWORD sector) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;457    	WORD idx;
;;;458    	BYTE line;
;;;459    	#if DEBUG_ENABLE
;;;460    	DEBUG_START(DBG_3);
000006  4928              LDR      r1,|L4.168|
000008  2008              MOVS     r0,#8
00000a  6048              STR      r0,[r1,#4]
;;;461    	#endif
;;;462    
;;;463    	// Query invalid?
;;;464    	if (sector > dev->last_sector) {
00000c  6870              LDR      r0,[r6,#4]
00000e  4290              CMP      r0,r2
000010  d203              BCS      |L4.26|
;;;465    		#if DEBUG_ENABLE
;;;466    		DEBUG_STOP(DBG_3);
000012  2008              MOVS     r0,#8
000014  6088              STR      r0,[r1,#8]
;;;467    		#endif
;;;468    		return (SD_PARERR);
000016  2003              MOVS     r0,#3
;;;469    	}
;;;470    	// Convert sector number to bytes address (sector * SD_BLK_SIZE)
;;;471    	//    if(__SD_Send_Cmd(CMD24, sector * SD_BLK_SIZE)==0) { // Only for SDSC
;;;472    	if (__SD_Send_Cmd(CMD24, sector) == 0) {	// Only for SDHC or SDXC   
;;;473    		// Send token (single block write)
;;;474    		SPI_RW(0xFE);
;;;475    		// Send block data
;;;476    		for (idx = 0; idx != SD_BLK_SIZE; idx++)
;;;477    			SPI_RW(*((BYTE *) dat + idx));
;;;478    		/* Dummy CRC */
;;;479    		SPI_RW(0xFF);
;;;480    		SPI_RW(0xFF);
;;;481    		// If not accepted, returns the reject error
;;;482    		if ((SPI_RW(0xFF) & 0x1F) != 0x05) {
;;;483    			#if DEBUG_ENABLE
;;;484    			DEBUG_STOP(DBG_3);
;;;485    			#endif
;;;486    			return (SD_REJECT);
;;;487    		}
;;;488    		// Waits until finish of data programming with a timeout
;;;489    		SPI_Timer_On(SD_IO_WRITE_TIMEOUT_WAIT);
;;;490    		do {
;;;491    			#if DEBUG_ENABLE
;;;492    			DEBUG_TOGGLE(DBG_3);
;;;493    			#endif
;;;494    			line = SPI_RW(0xFF);
;;;495    		} while ((line == 0) && (SPI_Timer_Status() == TRUE));
;;;496    		#if DEBUG_ENABLE
;;;497    		DEBUG_START(DBG_3);
;;;498    		#endif
;;;499    		SPI_Timer_Off();
;;;500    		dev->debug.write++;
;;;501    
;;;502    		if (line == 0) {
;;;503    			#if DEBUG_ENABLE
;;;504    			DEBUG_STOP(DBG_3);
;;;505    			#endif
;;;506    			return (SD_BUSY);
;;;507    		} else {
;;;508    			#if DEBUG_ENABLE
;;;509    			DEBUG_STOP(DBG_3);
;;;510    			#endif
;;;511    			return (SD_OK);
;;;512    		}
;;;513    	} else {
;;;514    		#if DEBUG_ENABLE
;;;515    		DEBUG_STOP(DBG_3);
;;;516    		#endif
;;;517    		return (SD_ERROR);
;;;518    	}
;;;519    }
000018  bdf8              POP      {r3-r7,pc}
                  |L4.26|
00001a  4611              MOV      r1,r2                 ;472
00001c  2058              MOVS     r0,#0x58              ;472
00001e  f7fffffe          BL       __SD_Send_Cmd
000022  2800              CMP      r0,#0                 ;472
000024  d004              BEQ      |L4.48|
000026  4920              LDR      r1,|L4.168|
000028  2008              MOVS     r0,#8                 ;515
00002a  6088              STR      r0,[r1,#8]            ;515
00002c  2002              MOVS     r0,#2                 ;517
00002e  bdf8              POP      {r3-r7,pc}
                  |L4.48|
000030  20fe              MOVS     r0,#0xfe              ;474
000032  f7fffffe          BL       SPI_RW
000036  2400              MOVS     r4,#0                 ;476
000038  2701              MOVS     r7,#1                 ;476
00003a  027f              LSLS     r7,r7,#9              ;476
                  |L4.60|
00003c  5d28              LDRB     r0,[r5,r4]            ;477
00003e  f7fffffe          BL       SPI_RW
000042  1c64              ADDS     r4,r4,#1              ;477
000044  b2a4              UXTH     r4,r4                 ;476
000046  42bc              CMP      r4,r7                 ;476
000048  d1f8              BNE      |L4.60|
00004a  20ff              MOVS     r0,#0xff              ;479
00004c  f7fffffe          BL       SPI_RW
000050  20ff              MOVS     r0,#0xff              ;480
000052  f7fffffe          BL       SPI_RW
000056  20ff              MOVS     r0,#0xff              ;482
000058  f7fffffe          BL       SPI_RW
00005c  06c0              LSLS     r0,r0,#27             ;482
00005e  0ec0              LSRS     r0,r0,#27             ;482
000060  2805              CMP      r0,#5                 ;482
000062  d004              BEQ      |L4.110|
000064  4910              LDR      r1,|L4.168|
000066  2008              MOVS     r0,#8                 ;484
000068  6088              STR      r0,[r1,#8]            ;484
00006a  2005              MOVS     r0,#5                 ;486
00006c  bdf8              POP      {r3-r7,pc}
                  |L4.110|
00006e  20fa              MOVS     r0,#0xfa              ;489
000070  f7fffffe          BL       SPI_Timer_On
000074  4d0c              LDR      r5,|L4.168|
000076  2408              MOVS     r4,#8                 ;460
                  |L4.120|
000078  60ec              STR      r4,[r5,#0xc]          ;492
00007a  20ff              MOVS     r0,#0xff              ;494
00007c  f7fffffe          BL       SPI_RW
000080  0007              MOVS     r7,r0                 ;494
000082  d103              BNE      |L4.140|
000084  f7fffffe          BL       SPI_Timer_Status
000088  2801              CMP      r0,#1                 ;495
00008a  d0f5              BEQ      |L4.120|
                  |L4.140|
00008c  606c              STR      r4,[r5,#4]            ;497
00008e  f7fffffe          BL       SPI_Timer_Off
000092  8970              LDRH     r0,[r6,#0xa]          ;500
000094  1c40              ADDS     r0,r0,#1              ;500
000096  8170              STRH     r0,[r6,#0xa]          ;500
000098  2f00              CMP      r7,#0                 ;502
00009a  60ac              STR      r4,[r5,#8]            ;509
00009c  d001              BEQ      |L4.162|
00009e  2000              MOVS     r0,#0                 ;511
0000a0  bdf8              POP      {r3-r7,pc}
                  |L4.162|
0000a2  2004              MOVS     r0,#4                 ;506
0000a4  bdf8              POP      {r3-r7,pc}
;;;520    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L4.168|
                          DCD      0xf80ff040

                          AREA ||i.__SD_Power_Of_Two||, CODE, READONLY, ALIGN=1

                  __SD_Power_Of_Two PROC
;;;78     
;;;79     DWORD __SD_Power_Of_Two(BYTE e) {
000000  4601              MOV      r1,r0
;;;80     	DWORD partial = 1;
000002  2001              MOVS     r0,#1
;;;81     	BYTE idx;
;;;82     	for (idx = 0; idx != e; idx++)
000004  2900              CMP      r1,#0
000006  d007              BEQ      |L5.24|
;;;83     		partial *= 2;
;;;84     	return (partial);
;;;85     }
000008  07ca              LSLS     r2,r1,#31
00000a  d000              BEQ      |L5.14|
00000c  2002              MOVS     r0,#2                 ;83
                  |L5.14|
00000e  0849              LSRS     r1,r1,#1              ;82
000010  d002              BEQ      |L5.24|
                  |L5.18|
000012  0080              LSLS     r0,r0,#2              ;83
000014  1e49              SUBS     r1,r1,#1              ;83
000016  d1fc              BNE      |L5.18|
                  |L5.24|
000018  4770              BX       lr
;;;86     
                          ENDP


                          AREA ||i.__SD_Sectors||, CODE, READONLY, ALIGN=2

                  __SD_Sectors PROC
;;;167    
;;;168    DWORD __SD_Sectors(SD_DEV * dev) {
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;169    	BYTE csd[16];
;;;170    	BYTE idx;
;;;171    	DWORD ss = 0;
;;;172    	WORD C_SIZE = 0;
000002  2500              MOVS     r5,#0
000004  b084              SUB      sp,sp,#0x10           ;168
;;;173    	BYTE C_SIZE_MULT = 0;
000006  462c              MOV      r4,r5
;;;174    	BYTE READ_BL_LEN = 0;
000008  462f              MOV      r7,r5
;;;175    	if (__SD_Send_Cmd(CMD9, 0) == 0) {
00000a  4629              MOV      r1,r5
00000c  2049              MOVS     r0,#0x49
00000e  f7fffffe          BL       __SD_Send_Cmd
000012  2800              CMP      r0,#0
000014  d002              BEQ      |L6.28|
;;;176    		// Wait for response
;;;177    		while (SPI_RW(0xFF) == 0xFF);
;;;178    		for (idx = 0; idx != 16; idx++){
;;;179    			//csd[idx] = SPI_RW(0xFF);
;;;180    			while (!(SPI1_S & SPI_S_SPTEF_MASK)) {
;;;181    			}
;;;182    			SPI1_D = 0xFF;
;;;183    			while (!(SPI1_S & SPI_S_SPRF_MASK)) {
;;;184    			}
;;;185    			csd[idx] = SPI1_D;
;;;186    		}
;;;187    		// Dummy CRC
;;;188    		SPI_RW(0xFF);
;;;189    		SPI_RW(0xFF);
;;;190    		for (WORD idx = 512; idx && (SPI_RW(0xFF) != 0xFF); idx--);
;;;191    		if (dev->cardtype & SDCT_SD1) {
;;;192    			ss = csd[0];
;;;193    			// READ_BL_LEN[83:80]: max. read data block length
;;;194    			READ_BL_LEN = (csd[5] & 0x0F);
;;;195    			// C_SIZE [73:62]
;;;196    			C_SIZE = (csd[6] & 0x03);
;;;197    			C_SIZE <<= 8;
;;;198    			C_SIZE |= (csd[7]);
;;;199    			C_SIZE <<= 2;
;;;200    			C_SIZE |= ((csd[8] >> 6) & 0x03);
;;;201    			// C_SIZE_MULT [49:47]
;;;202    			C_SIZE_MULT = (csd[9] & 0x03);
;;;203    			C_SIZE_MULT <<= 1;
;;;204    			C_SIZE_MULT |= ((csd[10] >> 7) & 0x01);
;;;205    		} else if (dev->cardtype & SDCT_SD2) {
;;;206    			// READ_BL_LEN = 9;
;;;207    			// C_SIZE [69:48]
;;;208    			C_SIZE = (csd[7] & 0x3F);
;;;209    			C_SIZE <<= 8;
;;;210    			C_SIZE |= (csd[8] & 0xFF);
;;;211    			C_SIZE <<= 8;
;;;212    			C_SIZE |= (csd[9] & 0xFF);
;;;213    			C_SIZE_MULT = 8;					// AD changed
;;;214    		}
;;;215    		ss = (C_SIZE + 1);
;;;216    		ss *= __SD_Power_Of_Two(C_SIZE_MULT + 2);
;;;217    		ss *= __SD_Power_Of_Two(READ_BL_LEN);
;;;218    		// ss /= SD_BLK_SIZE; ?? Bug in original code?
;;;219    
;;;220    		return (ss);
;;;221    	} else
;;;222    		return (0);									// Error
000016  2000              MOVS     r0,#0
;;;223    }
000018  b005              ADD      sp,sp,#0x14
00001a  bdf0              POP      {r4-r7,pc}
                  |L6.28|
00001c  20ff              MOVS     r0,#0xff              ;177
00001e  f7fffffe          BL       SPI_RW
000022  28ff              CMP      r0,#0xff              ;177
000024  d0fa              BEQ      |L6.28|
000026  2100              MOVS     r1,#0                 ;178
000028  4833              LDR      r0,|L6.248|
00002a  23ff              MOVS     r3,#0xff              ;177
00002c  466e              MOV      r6,sp                 ;169
                  |L6.46|
00002e  78c2              LDRB     r2,[r0,#3]            ;180
000030  0692              LSLS     r2,r2,#26             ;180
000032  d5fc              BPL      |L6.46|
000034  7143              STRB     r3,[r0,#5]            ;182
                  |L6.54|
000036  78c2              LDRB     r2,[r0,#3]            ;183
000038  0612              LSLS     r2,r2,#24             ;183
00003a  d5fc              BPL      |L6.54|
00003c  7942              LDRB     r2,[r0,#5]            ;185
00003e  5472              STRB     r2,[r6,r1]            ;185
000040  1c49              ADDS     r1,r1,#1              ;185
000042  b2c9              UXTB     r1,r1                 ;178
000044  2910              CMP      r1,#0x10              ;178
000046  d1f2              BNE      |L6.46|
000048  20ff              MOVS     r0,#0xff              ;188
00004a  f7fffffe          BL       SPI_RW
00004e  20ff              MOVS     r0,#0xff              ;189
000050  f7fffffe          BL       SPI_RW
000054  2601              MOVS     r6,#1                 ;190
000056  0276              LSLS     r6,r6,#9              ;190
000058  e003              B        |L6.98|
                  |L6.90|
00005a  1e76              SUBS     r6,r6,#1              ;190
00005c  0436              LSLS     r6,r6,#16             ;190
00005e  0c36              LSRS     r6,r6,#16             ;190
000060  d004              BEQ      |L6.108|
                  |L6.98|
000062  20ff              MOVS     r0,#0xff              ;190
000064  f7fffffe          BL       SPI_RW
000068  28ff              CMP      r0,#0xff              ;190
00006a  d1f6              BNE      |L6.90|
                  |L6.108|
00006c  9804              LDR      r0,[sp,#0x10]         ;191
00006e  7840              LDRB     r0,[r0,#1]            ;191
000070  0781              LSLS     r1,r0,#30             ;191
000072  d515              BPL      |L6.160|
000074  4669              MOV      r1,sp                 ;194
000076  7948              LDRB     r0,[r1,#5]            ;194
000078  0707              LSLS     r7,r0,#28             ;194
00007a  7988              LDRB     r0,[r1,#6]            ;196
00007c  79c9              LDRB     r1,[r1,#7]            ;198
00007e  0780              LSLS     r0,r0,#30             ;196
000080  0d80              LSRS     r0,r0,#22             ;197
000082  4301              ORRS     r1,r1,r0              ;198
000084  0088              LSLS     r0,r1,#2              ;198
000086  4669              MOV      r1,sp                 ;200
000088  7a09              LDRB     r1,[r1,#8]            ;200
00008a  0f3f              LSRS     r7,r7,#28             ;194
00008c  098d              LSRS     r5,r1,#6              ;200
00008e  4305              ORRS     r5,r5,r0              ;200
000090  4669              MOV      r1,sp                 ;202
000092  7a48              LDRB     r0,[r1,#9]            ;202
000094  7a89              LDRB     r1,[r1,#0xa]          ;204
000096  0780              LSLS     r0,r0,#30             ;202
000098  0f40              LSRS     r0,r0,#29             ;203
00009a  09cc              LSRS     r4,r1,#7              ;204
00009c  4304              ORRS     r4,r4,r0              ;204
00009e  e00d              B        |L6.188|
                  |L6.160|
0000a0  0740              LSLS     r0,r0,#29             ;205
0000a2  d50b              BPL      |L6.188|
0000a4  4668              MOV      r0,sp                 ;208
0000a6  79c0              LDRB     r0,[r0,#7]            ;208
0000a8  0201              LSLS     r1,r0,#8              ;209
0000aa  4668              MOV      r0,sp                 ;210
0000ac  7a00              LDRB     r0,[r0,#8]            ;210
0000ae  4308              ORRS     r0,r0,r1              ;210
0000b0  0600              LSLS     r0,r0,#24             ;211
0000b2  0c01              LSRS     r1,r0,#16             ;211
0000b4  4668              MOV      r0,sp                 ;212
0000b6  7a45              LDRB     r5,[r0,#9]            ;212
0000b8  430d              ORRS     r5,r5,r1              ;212
0000ba  2408              MOVS     r4,#8                 ;213
                  |L6.188|
0000bc  2101              MOVS     r1,#1                 ;213
0000be  1ca4              ADDS     r4,r4,#2              ;213
0000c0  1c6d              ADDS     r5,r5,#1              ;213
0000c2  2c00              CMP      r4,#0                 ;213
0000c4  d007              BEQ      |L6.214|
0000c6  07e0              LSLS     r0,r4,#31             ;213
0000c8  d000              BEQ      |L6.204|
0000ca  2102              MOVS     r1,#2                 ;213
                  |L6.204|
0000cc  0860              LSRS     r0,r4,#1              ;213
0000ce  d002              BEQ      |L6.214|
                  |L6.208|
0000d0  0089              LSLS     r1,r1,#2              ;213
0000d2  1e40              SUBS     r0,r0,#1              ;213
0000d4  d1fc              BNE      |L6.208|
                  |L6.214|
0000d6  4369              MULS     r1,r5,r1              ;216
0000d8  2001              MOVS     r0,#1                 ;216
0000da  463a              MOV      r2,r7                 ;217
0000dc  2f00              CMP      r7,#0                 ;217
0000de  d007              BEQ      |L6.240|
0000e0  07d3              LSLS     r3,r2,#31             ;217
0000e2  d000              BEQ      |L6.230|
0000e4  2002              MOVS     r0,#2                 ;217
                  |L6.230|
0000e6  087a              LSRS     r2,r7,#1              ;217
0000e8  d002              BEQ      |L6.240|
                  |L6.234|
0000ea  0080              LSLS     r0,r0,#2              ;217
0000ec  1e52              SUBS     r2,r2,#1              ;217
0000ee  d1fc              BNE      |L6.234|
                  |L6.240|
0000f0  4348              MULS     r0,r1,r0              ;217
0000f2  b005              ADD      sp,sp,#0x14
0000f4  bdf0              POP      {r4-r7,pc}
;;;224    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L6.248|
                          DCD      0x40077000

                          AREA ||i.__SD_Send_Cmd||, CODE, READONLY, ALIGN=2

                  __SD_Send_Cmd PROC
;;;99     
;;;100    BYTE __SD_Send_Cmd(BYTE cmd, DWORD arg) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;101    	BYTE crc, res;
;;;102    	#if DEBUG_ENABLE
;;;103    	DEBUG_START(DBG_4);
000002  24ff              MOVS     r4,#0xff
000004  4d29              LDR      r5,|L7.172|
000006  3401              ADDS     r4,#1
000008  460f              MOV      r7,r1                 ;100
00000a  4606              MOV      r6,r0                 ;100
00000c  606c              STR      r4,[r5,#4]
;;;104    	#endif
;;;105    
;;;106    	// ACMD«n» is the command sequense of CMD55-CMD«n»
;;;107    	if (cmd & 0x80) {
00000e  0600              LSLS     r0,r0,#24
000010  d509              BPL      |L7.38|
;;;108    		cmd &= 0x7F;
000012  0676              LSLS     r6,r6,#25
000014  0e76              LSRS     r6,r6,#25
;;;109    		res = __SD_Send_Cmd(CMD55, 0);
000016  2100              MOVS     r1,#0
000018  2077              MOVS     r0,#0x77
00001a  f7fffffe          BL       __SD_Send_Cmd
;;;110    		if (res > 1) {
00001e  2801              CMP      r0,#1
000020  d901              BLS      |L7.38|
;;;111    			#if DEBUG_ENABLE
;;;112    			DEBUG_STOP(DBG_4);
000022  60ac              STR      r4,[r5,#8]
;;;113    			#endif
;;;114    			return (res);
;;;115    
;;;116    		}
;;;117    	}
;;;118    	// Select the card
;;;119    	__SD_Deassert();
;;;120    	SPI_RW(0xFF);
;;;121    	__SD_Assert();
;;;122    	SPI_RW(0xFF);
;;;123    
;;;124    	// Send complete command set
;;;125    	SPI_RW(cmd);									// Start and command index
;;;126    	SPI_RW((BYTE) (arg >> 24));		// Arg[31-24]
;;;127    	SPI_RW((BYTE) (arg >> 16));		// Arg[23-16]
;;;128    	SPI_RW((BYTE) (arg >> 8));		// Arg[15-08]
;;;129    	SPI_RW((BYTE) (arg >> 0));		// Arg[07-00]
;;;130    
;;;131    	// CRC?
;;;132    	crc = 0x01;										// Dummy CRC and stop
;;;133    	if (cmd == CMD0)
;;;134    		crc = 0x95;									// Valid CRC for CMD0(0)
;;;135    	if (cmd == CMD8)
;;;136    		crc = 0x87;									// Valid CRC for CMD8(0x1AA)
;;;137    	SPI_RW(crc);
;;;138    
;;;139    	// Receive command response
;;;140    	// Wait for a valid response in timeout of 5 milliseconds
;;;141    	//SPI_Timer_On(5);
;;;142    	SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;	// Make sure clock is enabled
;;;143    	LPTMR0_CSR = 0;								// Reset LPTMR settings
;;;144    	LPTMR0_CMR = 5;							// Set compare value (in ms)
;;;145    	// Use 1kHz LPO with no prescaler
;;;146    	LPTMR0_PSR = LPTMR_PSR_PCS(1) | LPTMR_PSR_PBYP_MASK;
;;;147    	// Start the timer and wait for it to reach the compare value
;;;148    	LPTMR0_CSR = LPTMR_CSR_TEN_MASK;
;;;149    	
;;;150    	do {
;;;151    		#if DEBUG_ENABLE
;;;152    		DEBUG_TOGGLE(DBG_4);
;;;153    		#endif
;;;154    		res = SPI_RW(0xFF);
;;;155    	} while ((res & 0x80) && (SPI_Timer_Status() == TRUE));
;;;156    	#if DEBUG_ENABLE
;;;157    	DEBUG_START(DBG_4);
;;;158    	#endif
;;;159    	LPTMR0_CSR = 0;
;;;160    
;;;161    	// Return with the response value
;;;162    	#if DEBUG_ENABLE
;;;163    	DEBUG_STOP(DBG_4)
;;;164    	#endif
;;;165    			return (res);
;;;166    }
000024  bdf8              POP      {r3-r7,pc}
                  |L7.38|
000026  f7fffffe          BL       SPI_CS_High
00002a  20ff              MOVS     r0,#0xff              ;120
00002c  f7fffffe          BL       SPI_RW
000030  f7fffffe          BL       SPI_CS_Low
000034  20ff              MOVS     r0,#0xff              ;122
000036  f7fffffe          BL       SPI_RW
00003a  4630              MOV      r0,r6                 ;125
00003c  f7fffffe          BL       SPI_RW
000040  0e38              LSRS     r0,r7,#24             ;126
000042  f7fffffe          BL       SPI_RW
000046  0238              LSLS     r0,r7,#8              ;127
000048  0e00              LSRS     r0,r0,#24             ;127
00004a  f7fffffe          BL       SPI_RW
00004e  0438              LSLS     r0,r7,#16             ;128
000050  0e00              LSRS     r0,r0,#24             ;128
000052  f7fffffe          BL       SPI_RW
000056  b2f8              UXTB     r0,r7                 ;129
000058  f7fffffe          BL       SPI_RW
00005c  2001              MOVS     r0,#1                 ;132
00005e  2e40              CMP      r6,#0x40              ;133
000060  d002              BEQ      |L7.104|
000062  2e48              CMP      r6,#0x48              ;135
000064  d002              BEQ      |L7.108|
000066  e002              B        |L7.110|
                  |L7.104|
000068  2095              MOVS     r0,#0x95              ;134
00006a  e000              B        |L7.110|
                  |L7.108|
00006c  2087              MOVS     r0,#0x87              ;136
                  |L7.110|
00006e  f7fffffe          BL       SPI_RW
000072  490f              LDR      r1,|L7.176|
000074  6b8a              LDR      r2,[r1,#0x38]         ;142
000076  2001              MOVS     r0,#1                 ;142
000078  4302              ORRS     r2,r2,r0              ;142
00007a  638a              STR      r2,[r1,#0x38]         ;142
00007c  4e0d              LDR      r6,|L7.180|
00007e  2100              MOVS     r1,#0                 ;143
000080  6031              STR      r1,[r6,#0]            ;143
000082  2105              MOVS     r1,#5                 ;144
000084  60b1              STR      r1,[r6,#8]            ;144
000086  6071              STR      r1,[r6,#4]            ;146
000088  6030              STR      r0,[r6,#0]            ;148
                  |L7.138|
00008a  60ec              STR      r4,[r5,#0xc]          ;152
00008c  20ff              MOVS     r0,#0xff              ;154
00008e  f7fffffe          BL       SPI_RW
000092  4607              MOV      r7,r0                 ;154
000094  0600              LSLS     r0,r0,#24             ;155
000096  d503              BPL      |L7.160|
000098  f7fffffe          BL       SPI_Timer_Status
00009c  2801              CMP      r0,#1                 ;155
00009e  d0f4              BEQ      |L7.138|
                  |L7.160|
0000a0  606c              STR      r4,[r5,#4]            ;157
0000a2  2000              MOVS     r0,#0                 ;159
0000a4  6030              STR      r0,[r6,#0]            ;159
0000a6  60ac              STR      r4,[r5,#8]            ;163
0000a8  4638              MOV      r0,r7                 ;165
0000aa  bdf8              POP      {r3-r7,pc}
;;;167    
                          ENDP

                  |L7.172|
                          DCD      0xf80ff040
                  |L7.176|
                          DCD      0x40048000
                  |L7.180|
                          DCD      0x40040000

                          AREA ||i.__SD_Speed_Transfer||, CODE, READONLY, ALIGN=1

                  __SD_Speed_Transfer PROC
;;;94     
;;;95     void __SD_Speed_Transfer(BYTE throttle) {
000000  2801              CMP      r0,#1
;;;96     	if (throttle == HIGH)
000002  d103              BNE      |L8.12|
000004  b510              PUSH     {r4,lr}               ;95
;;;97     		SPI_Freq_High();
000006  f7fffffe          BL       SPI_Freq_High
;;;98     }
00000a  bd10              POP      {r4,pc}
                  |L8.12|
00000c  4770              BX       lr
;;;99     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  timeout
                          DCD      0x00000000

                          AREA ||area_number.12||, DATA, ALIGN=0

                          EXPORTAS ||area_number.12||, ||.data||
                  SD_Errors
000000  4f4b0000          DCB      0x4f,0x4b,0x00,0x00
                          DCDU     0x00000000
000008  4e4f494e          DCB      0x4e,0x4f,0x49,0x4e
00000c  49540000          DCB      0x49,0x54,0x00,0x00
000010  4552524f          DCB      0x45,0x52,0x52,0x4f
000014  52000000          DCB      0x52,0x00,0x00,0x00
000018  50415245          DCB      0x50,0x41,0x52,0x45
00001c  52520000          DCB      0x52,0x52,0x00,0x00
000020  42555359          DCB      0x42,0x55,0x53,0x59
000024  00000000          DCB      0x00,0x00,0x00,0x00
000028  52454a45          DCB      0x52,0x45,0x4a,0x45
00002c  43540000          DCB      0x43,0x54,0x00,0x00
000030  4e4f5245          DCB      0x4e,0x4f,0x52,0x45
000034  53500000          DCB      0x53,0x50,0x00,0x00

;*** Start embedded assembler ***

#line 1 "Source\\ulibSD\\sd_io.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_sd_io_c_timeout____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_sd_io_c_timeout____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_sd_io_c_timeout____REVSH|
#line 462
|__asm___7_sd_io_c_timeout____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
