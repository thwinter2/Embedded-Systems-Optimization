; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\sd_io.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\sd_io.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork -O3 --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\sd_io.crf Source\ulibSD\sd_io.c]
                          THUMB

                          AREA ||i.SD_Init||, CODE, READONLY, ALIGN=1

                  SD_Init PROC
;;;206    
;;;207    SDRESULTS SD_Init(SD_DEV * dev) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;208    	BYTE n, cmd, ct, ocr[4];
;;;209    	BYTE idx;
;;;210    	BYTE init_trys;
;;;211    
;;;212    	//DEBUG_START(DBG_5);
;;;213    	ct = 0;
000002  2400              MOVS     r4,#0
000004  4605              MOV      r5,r0                 ;207
;;;214    	for (init_trys = 0; ((init_trys != SD_INIT_TRYS) && (!ct));
000006  4627              MOV      r7,r4
                  |L1.8|
;;;215    			 init_trys++) {
;;;216    		// Initialize SPI for use with the memory card
;;;217    		SPI_Init();
000008  f7fffffe          BL       SPI_Init
;;;218    
;;;219    		SPI_CS_High();
00000c  f7fffffe          BL       SPI_CS_High
;;;220    		SPI_Freq_High();
000010  f7fffffe          BL       SPI_Freq_High
;;;221    
;;;222    		// 80 dummy clocks
;;;223    		for (idx = 0; idx != 10; idx++)
000014  2600              MOVS     r6,#0
                  |L1.22|
;;;224    			SPI_RW(0xFF);
000016  20ff              MOVS     r0,#0xff
000018  f7fffffe          BL       SPI_RW
00001c  1c76              ADDS     r6,r6,#1
00001e  b2f6              UXTB     r6,r6                 ;223
000020  2e0a              CMP      r6,#0xa               ;223
000022  d1f8              BNE      |L1.22|
;;;225    
;;;226    		SPI_Timer_On(500);
000024  26ff              MOVS     r6,#0xff
000026  36f5              ADDS     r6,r6,#0xf5
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       SPI_Timer_On
                  |L1.46|
;;;227    		while (SPI_Timer_Status() == TRUE) {
00002e  f7fffffe          BL       SPI_Timer_Status
000032  2801              CMP      r0,#1
000034  d0fb              BEQ      |L1.46|
;;;228    			//DEBUG_TOGGLE(DBG_5)
;;;229    		}
;;;230    		//DEBUG_START(DBG_5);
;;;231    		SPI_Timer_Off();
000036  f7fffffe          BL       SPI_Timer_Off
;;;232    
;;;233    		dev->mount = FALSE;
00003a  2000              MOVS     r0,#0
00003c  7028              STRB     r0,[r5,#0]
;;;234    		SPI_Timer_On(500);
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       SPI_Timer_On
                  |L1.68|
;;;235    		while ((__SD_Send_Cmd(CMD0, 0) != 1)
000044  2100              MOVS     r1,#0
000046  2040              MOVS     r0,#0x40
000048  f7fffffe          BL       __SD_Send_Cmd
00004c  2801              CMP      r0,#1
00004e  d003              BEQ      |L1.88|
;;;236    					 && (SPI_Timer_Status() == TRUE)) {
000050  f7fffffe          BL       SPI_Timer_Status
000054  2801              CMP      r0,#1
000056  d0f5              BEQ      |L1.68|
                  |L1.88|
;;;237    			//DEBUG_TOGGLE(DBG_5);
;;;238    		}
;;;239    		//DEBUG_START(DBG_5);
;;;240    		SPI_Timer_Off();
000058  f7fffffe          BL       SPI_Timer_Off
;;;241    		// Idle state
;;;242    		if (__SD_Send_Cmd(CMD0, 0) == 1) {
00005c  2100              MOVS     r1,#0
00005e  2040              MOVS     r0,#0x40
000060  f7fffffe          BL       __SD_Send_Cmd
000064  2801              CMP      r0,#1
000066  d172              BNE      |L1.334|
;;;243    			// SD version 2?
;;;244    			if (__SD_Send_Cmd(CMD8, 0x1AA) == 1) {
000068  21ff              MOVS     r1,#0xff
00006a  31ab              ADDS     r1,r1,#0xab
00006c  2048              MOVS     r0,#0x48
00006e  f7fffffe          BL       __SD_Send_Cmd
000072  2801              CMP      r0,#1
000074  d008              BEQ      |L1.136|
;;;245    				// Get trailing return value of R7 resp
;;;246    				for (n = 0; n < 4; n++)
;;;247    					ocr[n] = SPI_RW(0xFF);
;;;248    				// VDD range of 2.7-3.6V is OK?  
;;;249    				if ((ocr[2] == 0x01) && (ocr[3] == 0xAA)) {
;;;250    					// Wait for leaving idle state (ACMD41 with HCS bit)...
;;;251    					SPI_Timer_On(1000);
;;;252    					while ((SPI_Timer_Status() == TRUE)
;;;253    								 && (__SD_Send_Cmd(ACMD41, 1UL << 30))) {
;;;254    						//DEBUG_TOGGLE(DBG_5);
;;;255    					}
;;;256    					//DEBUG_START(DBG_5);
;;;257    					SPI_Timer_Off();
;;;258    					// CCS in the OCR? 
;;;259    					if ((SPI_Timer_Status() == TRUE)
;;;260    							&& (__SD_Send_Cmd(CMD58, 0) == 0)) {
;;;261    						for (n = 0; n < 4; n++)
;;;262    							ocr[n] = SPI_RW(0xFF);
;;;263    						// SD version 2?
;;;264    						ct = (ocr[0] & 0x40) ? SDCT_SD2 | SDCT_BLOCK : SDCT_SD2;
;;;265    					}
;;;266    				}
;;;267    			} else {
;;;268    				// SD version 1 or MMC?
;;;269    				if (__SD_Send_Cmd(ACMD41, 0) <= 1) {
000076  2100              MOVS     r1,#0
000078  20e9              MOVS     r0,#0xe9
00007a  f7fffffe          BL       __SD_Send_Cmd
00007e  2801              CMP      r0,#1
000080  d840              BHI      |L1.260|
;;;270    					// SD version 1
;;;271    					ct = SDCT_SD1;
000082  2402              MOVS     r4,#2
;;;272    					cmd = ACMD41;
000084  26e9              MOVS     r6,#0xe9
000086  e03f              B        |L1.264|
                  |L1.136|
000088  2600              MOVS     r6,#0                 ;246
                  |L1.138|
00008a  20ff              MOVS     r0,#0xff              ;247
00008c  f7fffffe          BL       SPI_RW
000090  4669              MOV      r1,sp                 ;247
000092  5588              STRB     r0,[r1,r6]            ;247
000094  1c76              ADDS     r6,r6,#1              ;247
000096  b2f6              UXTB     r6,r6                 ;246
000098  2e04              CMP      r6,#4                 ;246
00009a  d3f6              BCC      |L1.138|
00009c  7888              LDRB     r0,[r1,#2]            ;249
00009e  2801              CMP      r0,#1                 ;249
0000a0  d155              BNE      |L1.334|
0000a2  78c8              LDRB     r0,[r1,#3]            ;249
0000a4  28aa              CMP      r0,#0xaa              ;249
0000a6  d152              BNE      |L1.334|
0000a8  207d              MOVS     r0,#0x7d              ;251
0000aa  00c0              LSLS     r0,r0,#3              ;251
0000ac  f7fffffe          BL       SPI_Timer_On
0000b0  2601              MOVS     r6,#1                 ;253
0000b2  07b6              LSLS     r6,r6,#30             ;253
                  |L1.180|
0000b4  f7fffffe          BL       SPI_Timer_Status
0000b8  2801              CMP      r0,#1                 ;252
0000ba  d105              BNE      |L1.200|
0000bc  4631              MOV      r1,r6                 ;253
0000be  20e9              MOVS     r0,#0xe9              ;253
0000c0  f7fffffe          BL       __SD_Send_Cmd
0000c4  2800              CMP      r0,#0                 ;253
0000c6  d1f5              BNE      |L1.180|
                  |L1.200|
0000c8  f7fffffe          BL       SPI_Timer_Off
0000cc  f7fffffe          BL       SPI_Timer_Status
0000d0  2801              CMP      r0,#1                 ;259
0000d2  d13c              BNE      |L1.334|
0000d4  2100              MOVS     r1,#0                 ;260
0000d6  207a              MOVS     r0,#0x7a              ;260
0000d8  f7fffffe          BL       __SD_Send_Cmd
0000dc  2800              CMP      r0,#0                 ;260
0000de  d136              BNE      |L1.334|
0000e0  2400              MOVS     r4,#0                 ;261
0000e2  466e              MOV      r6,sp                 ;208
                  |L1.228|
0000e4  20ff              MOVS     r0,#0xff              ;262
0000e6  f7fffffe          BL       SPI_RW
0000ea  5530              STRB     r0,[r6,r4]            ;262
0000ec  1c64              ADDS     r4,r4,#1              ;262
0000ee  b2e4              UXTB     r4,r4                 ;261
0000f0  2c04              CMP      r4,#4                 ;261
0000f2  d3f7              BCC      |L1.228|
0000f4  4668              MOV      r0,sp                 ;264
0000f6  7800              LDRB     r0,[r0,#0]            ;264
0000f8  0640              LSLS     r0,r0,#25             ;264
0000fa  d501              BPL      |L1.256|
0000fc  240c              MOVS     r4,#0xc               ;264
0000fe  e026              B        |L1.334|
                  |L1.256|
000100  2404              MOVS     r4,#4                 ;264
000102  e024              B        |L1.334|
                  |L1.260|
;;;273    				} else {
;;;274    					// MMC version 3
;;;275    					ct = SDCT_MMC;
000104  2401              MOVS     r4,#1
;;;276    					cmd = CMD1;
000106  2641              MOVS     r6,#0x41
                  |L1.264|
;;;277    				}
;;;278    				// Wait for leaving idle state
;;;279    				SPI_Timer_On(250);
000108  20fa              MOVS     r0,#0xfa
00010a  f7fffffe          BL       SPI_Timer_On
                  |L1.270|
;;;280    				while ((SPI_Timer_Status() == TRUE)
00010e  f7fffffe          BL       SPI_Timer_Status
000112  2801              CMP      r0,#1
000114  d105              BNE      |L1.290|
;;;281    							 && (__SD_Send_Cmd(cmd, 0))) {
000116  2100              MOVS     r1,#0
000118  4630              MOV      r0,r6
00011a  f7fffffe          BL       __SD_Send_Cmd
00011e  2800              CMP      r0,#0
000120  d1f5              BNE      |L1.270|
                  |L1.290|
;;;282    					//DEBUG_TOGGLE(DBG_5);
;;;283    				}
;;;284    				//DEBUG_START(DBG_5);
;;;285    				SPI_Timer_Off();
000122  f7fffffe          BL       SPI_Timer_Off
;;;286    				if (SPI_Timer_Status() == FALSE)
000126  f7fffffe          BL       SPI_Timer_Status
00012a  2800              CMP      r0,#0
00012c  d100              BNE      |L1.304|
;;;287    					ct = 0;
00012e  2400              MOVS     r4,#0
                  |L1.304|
;;;288    				if (__SD_Send_Cmd(CMD59, 0))
000130  2100              MOVS     r1,#0
000132  207b              MOVS     r0,#0x7b
000134  f7fffffe          BL       __SD_Send_Cmd
000138  2800              CMP      r0,#0
00013a  d000              BEQ      |L1.318|
;;;289    					ct = 0;								// Deactivate CRC check (default)
00013c  2400              MOVS     r4,#0
                  |L1.318|
;;;290    				if (__SD_Send_Cmd(CMD16, 512))
00013e  2101              MOVS     r1,#1
000140  0249              LSLS     r1,r1,#9
000142  2050              MOVS     r0,#0x50
000144  f7fffffe          BL       __SD_Send_Cmd
000148  2800              CMP      r0,#0
00014a  d000              BEQ      |L1.334|
;;;291    					ct = 0;								// Set R/W block length to 512 bytes
00014c  2400              MOVS     r4,#0
                  |L1.334|
00014e  1c7f              ADDS     r7,r7,#1
000150  b2ff              UXTB     r7,r7                 ;215
000152  2f03              CMP      r7,#3                 ;214
000154  d003              BEQ      |L1.350|
000156  2c00              CMP      r4,#0                 ;214
000158  d100              BNE      |L1.348|
00015a  e755              B        |L1.8|
                  |L1.348|
00015c  e001              B        |L1.354|
                  |L1.350|
;;;292    			}
;;;293    		}
;;;294    	}
;;;295    	if (ct) {
00015e  2c00              CMP      r4,#0
000160  d011              BEQ      |L1.390|
                  |L1.354|
;;;296    		dev->cardtype = ct;
000162  706c              STRB     r4,[r5,#1]
;;;297    		dev->mount = TRUE;
000164  2001              MOVS     r0,#1
000166  7028              STRB     r0,[r5,#0]
;;;298    		dev->last_sector = __SD_Sectors(dev) - 1;
000168  4628              MOV      r0,r5
00016a  f7fffffe          BL       __SD_Sectors
00016e  1e40              SUBS     r0,r0,#1
;;;299    		dev->debug.read = 0;
000170  6068              STR      r0,[r5,#4]
000172  2000              MOVS     r0,#0
000174  8128              STRH     r0,[r5,#8]
;;;300    		dev->debug.write = 0;
000176  8168              STRH     r0,[r5,#0xa]
;;;301    		__SD_Speed_Transfer(HIGH);	// High speed transfer
000178  2001              MOVS     r0,#1
00017a  f7fffffe          BL       __SD_Speed_Transfer
;;;302    	}
;;;303    	SPI_Release();
00017e  f7fffffe          BL       SPI_Release
;;;304    	//DEBUG_STOP(DBG_5);
;;;305    	return (ct ? SD_OK : SD_NOINIT);
000182  2000              MOVS     r0,#0
;;;306    }
000184  bdf8              POP      {r3-r7,pc}
                  |L1.390|
000186  f7fffffe          BL       SPI_Release
00018a  2001              MOVS     r0,#1                 ;305
00018c  bdf8              POP      {r3-r7,pc}
;;;307    
                          ENDP


                          AREA ||i.SD_Read||, CODE, READONLY, ALIGN=2

                  SD_Read PROC
;;;310    #pragma diag_suppress 1441
;;;311    SDRESULTS SD_Read(SD_DEV * dev, void *dat, DWORD sector, WORD ofs,
000000  b5ff              PUSH     {r0-r7,lr}
;;;312    									WORD cnt) {
000002  4605              MOV      r5,r0
;;;313    	SDRESULTS res;
;;;314    	BYTE tkn, data;
;;;315    	WORD byte_num;
;;;316    	volatile uint8_t dummy;
;;;317    	//DEBUG_START(DBG_2);
;;;318    
;;;319    	res = SD_ERROR;
;;;320    	if ((sector > dev->last_sector) || (cnt == 0)) {
000004  6840              LDR      r0,[r0,#4]
000006  2702              MOVS     r7,#2                 ;319
000008  b081              SUB      sp,sp,#4              ;312
00000a  461e              MOV      r6,r3                 ;312
00000c  4290              CMP      r0,r2
00000e  d309              BCC      |L2.36|
000010  980a              LDR      r0,[sp,#0x28]
000012  2800              CMP      r0,#0
000014  d006              BEQ      |L2.36|
;;;321    		//DEBUG_STOP(DBG_2);
;;;322    		return (SD_PARERR);
;;;323    	}
;;;324    	// Convert sector number to byte address (sector * SD_BLK_SIZE)
;;;325    	//    if (__SD_Send_Cmd(CMD17, sector * SD_BLK_SIZE) == 0) { // Only for SDSC
;;;326    	if (__SD_Send_Cmd(CMD17, sector) == 0) {	// Only for SDHC or SDXC 
000016  4611              MOV      r1,r2
000018  2051              MOVS     r0,#0x51
00001a  f7fffffe          BL       __SD_Send_Cmd
00001e  2800              CMP      r0,#0
000020  d003              BEQ      |L2.42|
000022  e02c              B        |L2.126|
                  |L2.36|
000024  2003              MOVS     r0,#3                 ;322
                  |L2.38|
;;;327    		SPI_Timer_On(100);
;;;328    		do {
;;;329    			//DEBUG_TOGGLE(DBG_2);
;;;330    			tkn = SPI_RW(0xFF);
;;;331    		} while ((tkn == 0xFF) && SPI_Timer_Status() == TRUE);
;;;332    		//DEBUG_START(DBG_2);
;;;333    		SPI_Timer_Off();
;;;334    		// Token of single block?
;;;335    		if (tkn == 0xFE) {
;;;336    			// AGD: Loop fusion to simplify FSM formation
;;;337    			byte_num = 0;
;;;338    			do {
;;;339    				//DEBUG_TOGGLE(DBG_2); 
;;;340    				data = SPI_RW(0xff);
;;;341    				if ((byte_num >= ofs) && (byte_num < ofs + cnt)) {
;;;342    					*(BYTE *) dat = data;
;;;343    					((BYTE *) dat)++;
;;;344    				}												// else discard bytes before and after data
;;;345    			} while (++byte_num < SD_BLK_SIZE + 2);	// 512 byte block + 2 byte CRC
;;;346    			//DEBUG_START(DBG_2);
;;;347    			res = SD_OK;
;;;348    		}
;;;349    	}
;;;350    	SPI_Release();
;;;351    	dev->debug.read++;
;;;352    	//DEBUG_STOP(DBG_2);
;;;353    	return (res);
;;;354    }
000026  b005              ADD      sp,sp,#0x14
000028  bdf0              POP      {r4-r7,pc}
                  |L2.42|
00002a  2064              MOVS     r0,#0x64              ;327
00002c  f7fffffe          BL       SPI_Timer_On
                  |L2.48|
000030  20ff              MOVS     r0,#0xff              ;330
000032  f7fffffe          BL       SPI_RW
000036  4604              MOV      r4,r0                 ;330
000038  28ff              CMP      r0,#0xff              ;331
00003a  d004              BEQ      |L2.70|
00003c  f7fffffe          BL       SPI_Timer_Off
000040  2cfe              CMP      r4,#0xfe              ;335
000042  d007              BEQ      |L2.84|
000044  e01b              B        |L2.126|
                  |L2.70|
000046  f7fffffe          BL       SPI_Timer_Status
00004a  2801              CMP      r0,#1                 ;331
00004c  d0f0              BEQ      |L2.48|
00004e  f7fffffe          BL       SPI_Timer_Off
000052  e014              B        |L2.126|
                  |L2.84|
000054  980a              LDR      r0,[sp,#0x28]         ;341
000056  2400              MOVS     r4,#0                 ;337
000058  1837              ADDS     r7,r6,r0              ;341
                  |L2.90|
00005a  20ff              MOVS     r0,#0xff              ;340
00005c  f7fffffe          BL       SPI_RW
000060  42b4              CMP      r4,r6                 ;341
000062  d306              BCC      |L2.114|
000064  42a7              CMP      r7,r4                 ;341
000066  d904              BLS      |L2.114|
000068  9902              LDR      r1,[sp,#8]            ;342
00006a  7008              STRB     r0,[r1,#0]            ;342
00006c  9802              LDR      r0,[sp,#8]            ;343
00006e  1c40              ADDS     r0,r0,#1              ;343
000070  9002              STR      r0,[sp,#8]            ;343
                  |L2.114|
000072  1c64              ADDS     r4,r4,#1              ;343
000074  4805              LDR      r0,|L2.140|
000076  b2a4              UXTH     r4,r4                 ;345
000078  4284              CMP      r4,r0                 ;345
00007a  d3ee              BCC      |L2.90|
00007c  2700              MOVS     r7,#0                 ;347
                  |L2.126|
00007e  f7fffffe          BL       SPI_Release
000082  8928              LDRH     r0,[r5,#8]            ;351
000084  1c40              ADDS     r0,r0,#1              ;351
000086  8128              STRH     r0,[r5,#8]            ;351
000088  4638              MOV      r0,r7                 ;353
00008a  e7cc              B        |L2.38|
;;;355    
                          ENDP

                  |L2.140|
                          DCD      0x00000202

                          AREA ||i.SD_Status||, CODE, READONLY, ALIGN=1

                  SD_Status PROC
;;;407    
;;;408    SDRESULTS SD_Status(SD_DEV * dev) {
000000  b510              PUSH     {r4,lr}
;;;409    	return (__SD_Send_Cmd(CMD0, 0) ? SD_OK : SD_NORESPONSE);
000002  2100              MOVS     r1,#0
000004  2040              MOVS     r0,#0x40
000006  f7fffffe          BL       __SD_Send_Cmd
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L3.18|
00000e  2000              MOVS     r0,#0
;;;410    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  2006              MOVS     r0,#6                 ;409
000014  bd10              POP      {r4,pc}
;;;411    
                          ENDP


                          AREA ||i.SD_Write||, CODE, READONLY, ALIGN=1

                  SD_Write PROC
;;;357    
;;;358    SDRESULTS SD_Write(SD_DEV * dev, void *dat, DWORD sector) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
;;;359    	WORD idx;
;;;360    	BYTE line;
;;;361    
;;;362    	//DEBUG_START(DBG_3);
;;;363    
;;;364    	// Query invalid?
;;;365    	if (sector > dev->last_sector) {
000004  6840              LDR      r0,[r0,#4]
000006  460e              MOV      r6,r1                 ;358
000008  4290              CMP      r0,r2
00000a  d201              BCS      |L4.16|
;;;366    		//DEBUG_STOP(DBG_3);
;;;367    		return (SD_PARERR);
00000c  2003              MOVS     r0,#3
;;;368    	}
;;;369    	// Convert sector number to bytes address (sector * SD_BLK_SIZE)
;;;370    	//    if(__SD_Send_Cmd(CMD24, sector * SD_BLK_SIZE)==0) { // Only for SDSC
;;;371    	if (__SD_Send_Cmd(CMD24, sector) == 0) {	// Only for SDHC or SDXC   
;;;372    		// Send token (single block write)
;;;373    		SPI_RW(0xFE);
;;;374    		// Send block data
;;;375    		for (idx = 0; idx != SD_BLK_SIZE; idx++)
;;;376    			SPI_RW(*((BYTE *) dat + idx));
;;;377    		/* Dummy CRC */
;;;378    		SPI_RW(0xFF);
;;;379    		SPI_RW(0xFF);
;;;380    		// If not accepted, returns the reject error
;;;381    		if ((SPI_RW(0xFF) & 0x1F) != 0x05) {
;;;382    			//DEBUG_STOP(DBG_3);
;;;383    			return (SD_REJECT);
;;;384    		}
;;;385    		// Waits until finish of data programming with a timeout
;;;386    		SPI_Timer_On(SD_IO_WRITE_TIMEOUT_WAIT);
;;;387    		do {
;;;388    			//DEBUG_TOGGLE(DBG_3);
;;;389    			line = SPI_RW(0xFF);
;;;390    		} while ((line == 0) && (SPI_Timer_Status() == TRUE));
;;;391    		//DEBUG_START(DBG_3);
;;;392    		SPI_Timer_Off();
;;;393    		dev->debug.write++;
;;;394    
;;;395    		if (line == 0) {
;;;396    			//DEBUG_STOP(DBG_3);
;;;397    			return (SD_BUSY);
;;;398    		} else {
;;;399    			//DEBUG_STOP(DBG_3);
;;;400    			return (SD_OK);
;;;401    		}
;;;402    	} else {
;;;403    		//DEBUG_STOP(DBG_3);
;;;404    		return (SD_ERROR);
;;;405    	}
;;;406    }
00000e  bdf8              POP      {r3-r7,pc}
                  |L4.16|
000010  4611              MOV      r1,r2                 ;371
000012  2058              MOVS     r0,#0x58              ;371
000014  f7fffffe          BL       __SD_Send_Cmd
000018  2800              CMP      r0,#0                 ;371
00001a  d001              BEQ      |L4.32|
00001c  2002              MOVS     r0,#2                 ;404
00001e  bdf8              POP      {r3-r7,pc}
                  |L4.32|
000020  20fe              MOVS     r0,#0xfe              ;373
000022  f7fffffe          BL       SPI_RW
000026  2400              MOVS     r4,#0                 ;375
000028  2701              MOVS     r7,#1                 ;375
00002a  027f              LSLS     r7,r7,#9              ;375
                  |L4.44|
00002c  5d30              LDRB     r0,[r6,r4]            ;376
00002e  f7fffffe          BL       SPI_RW
000032  1c64              ADDS     r4,r4,#1              ;376
000034  b2a4              UXTH     r4,r4                 ;375
000036  42bc              CMP      r4,r7                 ;375
000038  d1f8              BNE      |L4.44|
00003a  20ff              MOVS     r0,#0xff              ;378
00003c  f7fffffe          BL       SPI_RW
000040  20ff              MOVS     r0,#0xff              ;379
000042  f7fffffe          BL       SPI_RW
000046  20ff              MOVS     r0,#0xff              ;381
000048  f7fffffe          BL       SPI_RW
00004c  06c0              LSLS     r0,r0,#27             ;381
00004e  0ec0              LSRS     r0,r0,#27             ;381
000050  2805              CMP      r0,#5                 ;381
000052  d001              BEQ      |L4.88|
000054  2005              MOVS     r0,#5                 ;383
000056  bdf8              POP      {r3-r7,pc}
                  |L4.88|
000058  20fa              MOVS     r0,#0xfa              ;386
00005a  f7fffffe          BL       SPI_Timer_On
                  |L4.94|
00005e  20ff              MOVS     r0,#0xff              ;389
000060  f7fffffe          BL       SPI_RW
000064  0004              MOVS     r4,r0                 ;389
000066  d103              BNE      |L4.112|
000068  f7fffffe          BL       SPI_Timer_Status
00006c  2801              CMP      r0,#1                 ;390
00006e  d0f6              BEQ      |L4.94|
                  |L4.112|
000070  f7fffffe          BL       SPI_Timer_Off
000074  8968              LDRH     r0,[r5,#0xa]          ;393
000076  1c40              ADDS     r0,r0,#1              ;393
000078  8168              STRH     r0,[r5,#0xa]          ;393
00007a  2c00              CMP      r4,#0                 ;395
00007c  d001              BEQ      |L4.130|
00007e  2000              MOVS     r0,#0                 ;400
000080  bdf8              POP      {r3-r7,pc}
                  |L4.130|
000082  2004              MOVS     r0,#4                 ;397
000084  bdf8              POP      {r3-r7,pc}
;;;407    
                          ENDP


                          AREA ||i.__SD_Power_Of_Two||, CODE, READONLY, ALIGN=1

                  __SD_Power_Of_Two PROC
;;;78     
;;;79     DWORD __SD_Power_Of_Two(BYTE e) {
000000  4602              MOV      r2,r0
;;;80     	DWORD partial = 1;
000002  2001              MOVS     r0,#1
;;;81     	BYTE idx;
;;;82     	for (idx = 0; idx != e; idx++)
000004  2100              MOVS     r1,#0
000006  e002              B        |L5.14|
                  |L5.8|
;;;83     		partial *= 2;
000008  0040              LSLS     r0,r0,#1
00000a  1c49              ADDS     r1,r1,#1
00000c  b2c9              UXTB     r1,r1                 ;82
                  |L5.14|
00000e  4291              CMP      r1,r2                 ;82
000010  d1fa              BNE      |L5.8|
;;;84     	return (partial);
;;;85     }
000012  4770              BX       lr
;;;86     
                          ENDP


                          AREA ||i.__SD_Sectors||, CODE, READONLY, ALIGN=1

                  __SD_Sectors PROC
;;;152    
;;;153    DWORD __SD_Sectors(SD_DEV * dev) {
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;154    	BYTE csd[16];
;;;155    	BYTE idx;
;;;156    	DWORD ss = 0;
;;;157    	WORD C_SIZE = 0;
000002  2400              MOVS     r4,#0
000004  b084              SUB      sp,sp,#0x10           ;153
;;;158    	BYTE C_SIZE_MULT = 0;
000006  4625              MOV      r5,r4
;;;159    	BYTE READ_BL_LEN = 0;
000008  4627              MOV      r7,r4
;;;160    	if (__SD_Send_Cmd(CMD9, 0) == 0) {
00000a  4621              MOV      r1,r4
00000c  2049              MOVS     r0,#0x49
00000e  f7fffffe          BL       __SD_Send_Cmd
000012  2800              CMP      r0,#0
000014  d002              BEQ      |L6.28|
;;;161    		// Wait for response
;;;162    		while (SPI_RW(0xFF) == 0xFF);
;;;163    		for (idx = 0; idx != 16; idx++)
;;;164    			csd[idx] = SPI_RW(0xFF);
;;;165    		// Dummy CRC
;;;166    		SPI_RW(0xFF);
;;;167    		SPI_RW(0xFF);
;;;168    		SPI_Release();
;;;169    		if (dev->cardtype & SDCT_SD1) {
;;;170    			ss = csd[0];
;;;171    			// READ_BL_LEN[83:80]: max. read data block length
;;;172    			READ_BL_LEN = (csd[5] & 0x0F);
;;;173    			// C_SIZE [73:62]
;;;174    			C_SIZE = (csd[6] & 0x03);
;;;175    			C_SIZE <<= 8;
;;;176    			C_SIZE |= (csd[7]);
;;;177    			C_SIZE <<= 2;
;;;178    			C_SIZE |= ((csd[8] >> 6) & 0x03);
;;;179    			// C_SIZE_MULT [49:47]
;;;180    			C_SIZE_MULT = (csd[9] & 0x03);
;;;181    			C_SIZE_MULT <<= 1;
;;;182    			C_SIZE_MULT |= ((csd[10] >> 7) & 0x01);
;;;183    		} else if (dev->cardtype & SDCT_SD2) {
;;;184    			// READ_BL_LEN = 9;
;;;185    			// C_SIZE [69:48]
;;;186    			C_SIZE = (csd[7] & 0x3F);
;;;187    			C_SIZE <<= 8;
;;;188    			C_SIZE |= (csd[8] & 0xFF);
;;;189    			C_SIZE <<= 8;
;;;190    			C_SIZE |= (csd[9] & 0xFF);
;;;191    			C_SIZE_MULT = 8;					// AD changed
;;;192    		}
;;;193    		ss = (C_SIZE + 1);
;;;194    		ss *= __SD_Power_Of_Two(C_SIZE_MULT + 2);
;;;195    		ss *= __SD_Power_Of_Two(READ_BL_LEN);
;;;196    		// ss /= SD_BLK_SIZE; ?? Bug in original code?
;;;197    
;;;198    		return (ss);
;;;199    	} else
;;;200    		return (0);									// Error
000016  2000              MOVS     r0,#0
                  |L6.24|
;;;201    }
000018  b005              ADD      sp,sp,#0x14
00001a  bdf0              POP      {r4-r7,pc}
                  |L6.28|
00001c  20ff              MOVS     r0,#0xff              ;162
00001e  f7fffffe          BL       SPI_RW
000022  28ff              CMP      r0,#0xff              ;162
000024  d0fa              BEQ      |L6.28|
000026  2600              MOVS     r6,#0                 ;163
                  |L6.40|
000028  20ff              MOVS     r0,#0xff              ;164
00002a  f7fffffe          BL       SPI_RW
00002e  4669              MOV      r1,sp                 ;164
000030  5588              STRB     r0,[r1,r6]            ;164
000032  1c76              ADDS     r6,r6,#1              ;164
000034  b2f6              UXTB     r6,r6                 ;163
000036  2e10              CMP      r6,#0x10              ;163
000038  d1f6              BNE      |L6.40|
00003a  20ff              MOVS     r0,#0xff              ;166
00003c  f7fffffe          BL       SPI_RW
000040  20ff              MOVS     r0,#0xff              ;167
000042  f7fffffe          BL       SPI_RW
000046  f7fffffe          BL       SPI_Release
00004a  9804              LDR      r0,[sp,#0x10]         ;169
00004c  7840              LDRB     r0,[r0,#1]            ;169
00004e  0781              LSLS     r1,r0,#30             ;169
000050  d518              BPL      |L6.132|
000052  4668              MOV      r0,sp                 ;172
000054  7940              LDRB     r0,[r0,#5]            ;172
000056  0707              LSLS     r7,r0,#28             ;172
000058  4668              MOV      r0,sp                 ;174
00005a  7980              LDRB     r0,[r0,#6]            ;174
00005c  0f3f              LSRS     r7,r7,#28             ;172
00005e  0780              LSLS     r0,r0,#30             ;174
000060  0d81              LSRS     r1,r0,#22             ;175
000062  4668              MOV      r0,sp                 ;176
000064  79c0              LDRB     r0,[r0,#7]            ;176
000066  4308              ORRS     r0,r0,r1              ;176
000068  0081              LSLS     r1,r0,#2              ;176
00006a  4668              MOV      r0,sp                 ;178
00006c  7a00              LDRB     r0,[r0,#8]            ;178
00006e  0984              LSRS     r4,r0,#6              ;178
000070  4668              MOV      r0,sp                 ;180
000072  7a40              LDRB     r0,[r0,#9]            ;180
000074  430c              ORRS     r4,r4,r1              ;178
000076  0780              LSLS     r0,r0,#30             ;180
000078  0f41              LSRS     r1,r0,#29             ;181
00007a  4668              MOV      r0,sp                 ;182
00007c  7a80              LDRB     r0,[r0,#0xa]          ;182
00007e  09c5              LSRS     r5,r0,#7              ;182
000080  430d              ORRS     r5,r5,r1              ;182
000082  e00d              B        |L6.160|
                  |L6.132|
000084  0740              LSLS     r0,r0,#29             ;183
000086  d50b              BPL      |L6.160|
000088  4668              MOV      r0,sp                 ;186
00008a  79c0              LDRB     r0,[r0,#7]            ;186
00008c  0201              LSLS     r1,r0,#8              ;187
00008e  4668              MOV      r0,sp                 ;188
000090  7a00              LDRB     r0,[r0,#8]            ;188
000092  4308              ORRS     r0,r0,r1              ;188
000094  0600              LSLS     r0,r0,#24             ;189
000096  0c01              LSRS     r1,r0,#16             ;189
000098  4668              MOV      r0,sp                 ;190
00009a  7a44              LDRB     r4,[r0,#9]            ;190
00009c  430c              ORRS     r4,r4,r1              ;190
00009e  2508              MOVS     r5,#8                 ;191
                  |L6.160|
0000a0  1ca8              ADDS     r0,r5,#2              ;194
0000a2  1c64              ADDS     r4,r4,#1              ;194
0000a4  f7fffffe          BL       __SD_Power_Of_Two
0000a8  4360              MULS     r0,r4,r0              ;194
0000aa  4603              MOV      r3,r0                 ;194
0000ac  4638              MOV      r0,r7                 ;195
0000ae  f7fffffe          BL       __SD_Power_Of_Two
0000b2  4601              MOV      r1,r0                 ;195
0000b4  4359              MULS     r1,r3,r1              ;195
0000b6  4608              MOV      r0,r1                 ;195
0000b8  e7ae              B        |L6.24|
;;;202    
                          ENDP


                          AREA ||i.__SD_Send_Cmd||, CODE, READONLY, ALIGN=1

                  __SD_Send_Cmd PROC
;;;101    
;;;102    BYTE __SD_Send_Cmd(BYTE cmd, DWORD arg) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;103    	BYTE crc, res;
;;;104    
;;;105    	//DEBUG_START(DBG_4);
;;;106    
;;;107    	// ACMD«n» is the command sequense of CMD55-CMD«n»
;;;108    	if (cmd & 0x80) {
000006  0600              LSLS     r0,r0,#24
000008  d507              BPL      |L7.26|
;;;109    		cmd &= 0x7F;
00000a  0664              LSLS     r4,r4,#25
00000c  0e64              LSRS     r4,r4,#25
;;;110    		res = __SD_Send_Cmd(CMD55, 0);
00000e  2100              MOVS     r1,#0
000010  2077              MOVS     r0,#0x77
000012  f7fffffe          BL       __SD_Send_Cmd
;;;111    		if (res > 1) {
000016  2801              CMP      r0,#1
000018  d835              BHI      |L7.134|
                  |L7.26|
00001a  f7fffffe          BL       SPI_CS_High
;;;112    			//DEBUG_STOP(DBG_4);
;;;113    			return (res);
;;;114    
;;;115    		}
;;;116    	}
;;;117    	// Select the card
;;;118    	__SD_Deassert();
;;;119    	SPI_RW(0xFF);
00001e  20ff              MOVS     r0,#0xff
000020  f7fffffe          BL       SPI_RW
000024  f7fffffe          BL       SPI_CS_Low
;;;120    	__SD_Assert();
;;;121    	SPI_RW(0xFF);
000028  20ff              MOVS     r0,#0xff
00002a  f7fffffe          BL       SPI_RW
;;;122    
;;;123    	// Send complete command set
;;;124    	SPI_RW(cmd);									// Start and command index
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SPI_RW
;;;125    	SPI_RW((BYTE) (arg >> 24));		// Arg[31-24]
000034  0e28              LSRS     r0,r5,#24
000036  f7fffffe          BL       SPI_RW
;;;126    	SPI_RW((BYTE) (arg >> 16));		// Arg[23-16]
00003a  0228              LSLS     r0,r5,#8
00003c  0e00              LSRS     r0,r0,#24
00003e  f7fffffe          BL       SPI_RW
;;;127    	SPI_RW((BYTE) (arg >> 8));		// Arg[15-08]
000042  0428              LSLS     r0,r5,#16
000044  0e00              LSRS     r0,r0,#24
000046  f7fffffe          BL       SPI_RW
;;;128    	SPI_RW((BYTE) (arg >> 0));		// Arg[07-00]
00004a  b2e8              UXTB     r0,r5
00004c  f7fffffe          BL       SPI_RW
;;;129    
;;;130    	// CRC?
;;;131    	crc = 0x01;										// Dummy CRC and stop
000050  2001              MOVS     r0,#1
;;;132    	if (cmd == CMD0)
000052  2c40              CMP      r4,#0x40
000054  d002              BEQ      |L7.92|
;;;133    		crc = 0x95;									// Valid CRC for CMD0(0)
;;;134    	if (cmd == CMD8)
000056  2c48              CMP      r4,#0x48
000058  d002              BEQ      |L7.96|
00005a  e002              B        |L7.98|
                  |L7.92|
00005c  2095              MOVS     r0,#0x95              ;133
00005e  e000              B        |L7.98|
                  |L7.96|
;;;135    		crc = 0x87;									// Valid CRC for CMD8(0x1AA)
000060  2087              MOVS     r0,#0x87
                  |L7.98|
;;;136    	SPI_RW(crc);
000062  f7fffffe          BL       SPI_RW
;;;137    
;;;138    	// Receive command response
;;;139    	// Wait for a valid response in timeout of 5 milliseconds
;;;140    	SPI_Timer_On(5);
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       SPI_Timer_On
                  |L7.108|
;;;141    	do {
;;;142    		//DEBUG_TOGGLE(DBG_4);
;;;143    		res = SPI_RW(0xFF);
00006c  20ff              MOVS     r0,#0xff
00006e  f7fffffe          BL       SPI_RW
000072  4604              MOV      r4,r0
;;;144    	} while ((res & 0x80) && (SPI_Timer_Status() == TRUE));
000074  0600              LSLS     r0,r0,#24
000076  d503              BPL      |L7.128|
000078  f7fffffe          BL       SPI_Timer_Status
00007c  2801              CMP      r0,#1
00007e  d0f5              BEQ      |L7.108|
                  |L7.128|
;;;145    	//DEBUG_START(DBG_4);
;;;146    	SPI_Timer_Off();
000080  f7fffffe          BL       SPI_Timer_Off
;;;147    
;;;148    	// Return with the response value
;;;149    	//DEBUG_STOP(DBG_4)
;;;150    			return (res);
000084  4620              MOV      r0,r4
                  |L7.134|
;;;151    }
000086  bd70              POP      {r4-r6,pc}
;;;152    
                          ENDP


                          AREA ||i.__SD_Speed_Transfer||, CODE, READONLY, ALIGN=1

                  __SD_Speed_Transfer PROC
;;;94     
;;;95     void __SD_Speed_Transfer(BYTE throttle) {
000000  b510              PUSH     {r4,lr}
;;;96     	if (throttle == HIGH)
000002  2801              CMP      r0,#1
000004  d002              BEQ      |L8.12|
;;;97     		SPI_Freq_High();
;;;98     	else
;;;99     		SPI_Freq_Low();
000006  f7fffffe          BL       SPI_Freq_Low
;;;100    }
00000a  bd10              POP      {r4,pc}
                  |L8.12|
00000c  f7fffffe          BL       SPI_Freq_High
000010  bd10              POP      {r4,pc}
;;;101    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  timeout
                          DCD      0x00000000

                          AREA ||area_number.12||, DATA, ALIGN=0

                          EXPORTAS ||area_number.12||, ||.data||
                  SD_Errors
000000  4f4b0000          DCB      0x4f,0x4b,0x00,0x00
                          DCDU     0x00000000
000008  4e4f494e          DCB      0x4e,0x4f,0x49,0x4e
00000c  49540000          DCB      0x49,0x54,0x00,0x00
000010  4552524f          DCB      0x45,0x52,0x52,0x4f
000014  52000000          DCB      0x52,0x00,0x00,0x00
000018  50415245          DCB      0x50,0x41,0x52,0x45
00001c  52520000          DCB      0x52,0x52,0x00,0x00
000020  42555359          DCB      0x42,0x55,0x53,0x59
000024  00000000          DCB      0x00,0x00,0x00,0x00
000028  52454a45          DCB      0x52,0x45,0x4a,0x45
00002c  43540000          DCB      0x43,0x54,0x00,0x00
000030  4e4f5245          DCB      0x4e,0x4f,0x52,0x45
000034  53500000          DCB      0x53,0x50,0x00,0x00

;*** Start embedded assembler ***

#line 1 "Source\\ulibSD\\sd_io.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_sd_io_c_timeout____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_sd_io_c_timeout____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_sd_io_c_timeout____REVSH|
#line 462
|__asm___7_sd_io_c_timeout____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
