; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\sd_io.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\sd_io.d --cpu=Cortex-M0+ --fpmode=fast --apcs=interwork//ropi -O3 -Otime --diag_suppress=9931 -I.\Include -I.\Source\Profiler -I.\Source\LCD -I.\Source\FS -I.\Source\ulibSD -I.\RTE\Device\MKL25Z128xxx4 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.15.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DMKL25Z128xxx4 --omf_browse=.\objects\sd_io.crf --remarks Source\ulibSD\sd_io.c]
                          THUMB

                          AREA ||i.SD_Init||, CODE, READONLY, ALIGN=1

                  SD_Init PROC
;;;213    
;;;214    SDRESULTS SD_Init(SD_DEV * dev) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4606              MOV      r6,r0
000004  b083              SUB      sp,sp,#0xc
;;;215    	BYTE n, cmd, ct, ocr[4];
;;;216    	BYTE idx;
;;;217    	BYTE init_trys;
;;;218    	#if DEBUG_ENABLE
;;;219    	DEBUG_START(DBG_5);
;;;220    	#endif
;;;221    	ct = 0;
000006  2000              MOVS     r0,#0
;;;222    	for (init_trys = 0; ((init_trys != SD_INIT_TRYS) && (!ct));
000008  4607              MOV      r7,r0
00000a  ad01              ADD      r5,sp,#4              ;215
00000c  9000              STR      r0,[sp,#0]            ;215
                  |L1.14|
;;;223    			 init_trys++) {
;;;224    		// Initialize SPI for use with the memory card
;;;225    		SPI_Init();
00000e  f7fffffe          BL       SPI_Init
;;;226    		
;;;227    
;;;228    		SPI_CS_High();
000012  f7fffffe          BL       SPI_CS_High
;;;229    		SPI_Freq_High();
000016  f7fffffe          BL       SPI_Freq_High
;;;230    
;;;231    		// 80 dummy clocks
;;;232    		for (idx = 0; idx != 10; idx++)
00001a  2400              MOVS     r4,#0
                  |L1.28|
;;;233    			SPI_RW(0xFF);
00001c  20ff              MOVS     r0,#0xff
00001e  f7fffffe          BL       SPI_RW
000022  1c64              ADDS     r4,r4,#1
000024  b2e4              UXTB     r4,r4                 ;232
000026  2c0a              CMP      r4,#0xa               ;232
000028  d1f8              BNE      |L1.28|
;;;234    
;;;235    		SPI_Timer_On(500);
00002a  24ff              MOVS     r4,#0xff
00002c  34f5              ADDS     r4,r4,#0xf5
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SPI_Timer_On
                  |L1.52|
;;;236    		while (SPI_Timer_Status() == TRUE) {
000034  f7fffffe          BL       SPI_Timer_Status
000038  2801              CMP      r0,#1
00003a  d0fb              BEQ      |L1.52|
;;;237    			#if DEBUG_ENABLE
;;;238    			DEBUG_TOGGLE(DBG_5)
;;;239    			#endif
;;;240    		}
;;;241    		#if DEBUG_ENABLE
;;;242    		DEBUG_START(DBG_5);
;;;243    		#endif
;;;244    		SPI_Timer_Off();
00003c  f7fffffe          BL       SPI_Timer_Off
;;;245    
;;;246    		dev->mount = FALSE;
000040  2000              MOVS     r0,#0
000042  7030              STRB     r0,[r6,#0]
;;;247    		SPI_Timer_On(500);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       SPI_Timer_On
                  |L1.74|
;;;248    		while ((__SD_Send_Cmd(CMD0, 0) != 1)
00004a  2100              MOVS     r1,#0
00004c  2040              MOVS     r0,#0x40
00004e  f7fffffe          BL       __SD_Send_Cmd
000052  2801              CMP      r0,#1
000054  d003              BEQ      |L1.94|
;;;249    					 && (SPI_Timer_Status() == TRUE)) {
000056  f7fffffe          BL       SPI_Timer_Status
00005a  2801              CMP      r0,#1
00005c  d0f5              BEQ      |L1.74|
                  |L1.94|
;;;250    						#if DEBUG_ENABLE
;;;251    						DEBUG_TOGGLE(DBG_5);
;;;252    						#endif
;;;253    		}
;;;254    		#if DEBUG_ENABLE
;;;255    		DEBUG_START(DBG_5);
;;;256    		#endif
;;;257    		SPI_Timer_Off();
00005e  f7fffffe          BL       SPI_Timer_Off
;;;258    		// Idle state
;;;259    		if (__SD_Send_Cmd(CMD0, 0) == 1) {
000062  2100              MOVS     r1,#0
000064  2040              MOVS     r0,#0x40
000066  f7fffffe          BL       __SD_Send_Cmd
00006a  2801              CMP      r0,#1
00006c  d177              BNE      |L1.350|
;;;260    			// SD version 2?
;;;261    			if (__SD_Send_Cmd(CMD8, 0x1AA) == 1) {
00006e  21ff              MOVS     r1,#0xff
000070  31ab              ADDS     r1,r1,#0xab
000072  2048              MOVS     r0,#0x48
000074  f7fffffe          BL       __SD_Send_Cmd
000078  2801              CMP      r0,#1
00007a  d009              BEQ      |L1.144|
;;;262    				// Get trailing return value of R7 resp
;;;263    				for (n = 0; n < 4; n++)
;;;264    					ocr[n] = SPI_RW(0xFF);
;;;265    				// VDD range of 2.7-3.6V is OK?  
;;;266    				if ((ocr[2] == 0x01) && (ocr[3] == 0xAA)) {
;;;267    					// Wait for leaving idle state (ACMD41 with HCS bit)...
;;;268    					SPI_Timer_On(1000);
;;;269    					while ((SPI_Timer_Status() == TRUE)
;;;270    								 && (__SD_Send_Cmd(ACMD41, 1UL << 30))) {
;;;271    						#if DEBUG_ENABLE
;;;272    						DEBUG_TOGGLE(DBG_5);
;;;273    						#endif
;;;274    					}
;;;275    					#if DEBUG_ENABLE
;;;276    					DEBUG_START(DBG_5);
;;;277    					#endif
;;;278    					SPI_Timer_Off();
;;;279    					// CCS in the OCR? 
;;;280    					if ((SPI_Timer_Status() == TRUE)
;;;281    							&& (__SD_Send_Cmd(CMD58, 0) == 0)) {
;;;282    						for (n = 0; n < 4; n++)
;;;283    							ocr[n] = SPI_RW(0xFF);
;;;284    						// SD version 2?
;;;285    						ct = (ocr[0] & 0x40) ? SDCT_SD2 | SDCT_BLOCK : SDCT_SD2;
;;;286    					}
;;;287    				}
;;;288    			} else {
;;;289    				// SD version 1 or MMC?
;;;290    				if (__SD_Send_Cmd(ACMD41, 0) <= 1) {
00007c  2100              MOVS     r1,#0
00007e  20e9              MOVS     r0,#0xe9
000080  f7fffffe          BL       __SD_Send_Cmd
000084  2801              CMP      r0,#1
000086  d842              BHI      |L1.270|
;;;291    					// SD version 1
;;;292    					ct = SDCT_SD1;
000088  2002              MOVS     r0,#2
;;;293    					cmd = ACMD41;
00008a  24e9              MOVS     r4,#0xe9
00008c  9000              STR      r0,[sp,#0]
00008e  e041              B        |L1.276|
                  |L1.144|
000090  2400              MOVS     r4,#0                 ;263
                  |L1.146|
000092  20ff              MOVS     r0,#0xff              ;264
000094  f7fffffe          BL       SPI_RW
000098  5528              STRB     r0,[r5,r4]            ;264
00009a  1c64              ADDS     r4,r4,#1              ;264
00009c  b2e4              UXTB     r4,r4                 ;263
00009e  2c04              CMP      r4,#4                 ;263
0000a0  d3f7              BCC      |L1.146|
0000a2  4668              MOV      r0,sp                 ;266
0000a4  7980              LDRB     r0,[r0,#6]            ;266
0000a6  2801              CMP      r0,#1                 ;266
0000a8  d159              BNE      |L1.350|
0000aa  4668              MOV      r0,sp                 ;266
0000ac  79c0              LDRB     r0,[r0,#7]            ;266
0000ae  28aa              CMP      r0,#0xaa              ;266
0000b0  d155              BNE      |L1.350|
0000b2  207d              MOVS     r0,#0x7d              ;268
0000b4  00c0              LSLS     r0,r0,#3              ;268
0000b6  f7fffffe          BL       SPI_Timer_On
0000ba  2401              MOVS     r4,#1                 ;270
0000bc  07a4              LSLS     r4,r4,#30             ;270
                  |L1.190|
0000be  f7fffffe          BL       SPI_Timer_Status
0000c2  2801              CMP      r0,#1                 ;269
0000c4  d105              BNE      |L1.210|
0000c6  4621              MOV      r1,r4                 ;270
0000c8  20e9              MOVS     r0,#0xe9              ;270
0000ca  f7fffffe          BL       __SD_Send_Cmd
0000ce  2800              CMP      r0,#0                 ;270
0000d0  d1f5              BNE      |L1.190|
                  |L1.210|
0000d2  f7fffffe          BL       SPI_Timer_Off
0000d6  f7fffffe          BL       SPI_Timer_Status
0000da  2801              CMP      r0,#1                 ;280
0000dc  d13f              BNE      |L1.350|
0000de  2100              MOVS     r1,#0                 ;281
0000e0  207a              MOVS     r0,#0x7a              ;281
0000e2  f7fffffe          BL       __SD_Send_Cmd
0000e6  2800              CMP      r0,#0                 ;281
0000e8  d139              BNE      |L1.350|
0000ea  2400              MOVS     r4,#0                 ;282
                  |L1.236|
0000ec  20ff              MOVS     r0,#0xff              ;283
0000ee  f7fffffe          BL       SPI_RW
0000f2  5528              STRB     r0,[r5,r4]            ;283
0000f4  1c64              ADDS     r4,r4,#1              ;283
0000f6  b2e4              UXTB     r4,r4                 ;282
0000f8  2c04              CMP      r4,#4                 ;282
0000fa  d3f7              BCC      |L1.236|
0000fc  4668              MOV      r0,sp                 ;285
0000fe  7900              LDRB     r0,[r0,#4]            ;285
000100  0640              LSLS     r0,r0,#25             ;285
000102  d501              BPL      |L1.264|
000104  200c              MOVS     r0,#0xc               ;285
000106  e000              B        |L1.266|
                  |L1.264|
000108  2004              MOVS     r0,#4                 ;285
                  |L1.266|
00010a  9000              STR      r0,[sp,#0]            ;285
00010c  e027              B        |L1.350|
                  |L1.270|
;;;294    				} else {
;;;295    					// MMC version 3
;;;296    					ct = SDCT_MMC;
00010e  2001              MOVS     r0,#1
;;;297    					cmd = CMD1;
000110  2441              MOVS     r4,#0x41
000112  9000              STR      r0,[sp,#0]
                  |L1.276|
;;;298    				}
;;;299    				// Wait for leaving idle state
;;;300    				SPI_Timer_On(250);
000114  20fa              MOVS     r0,#0xfa
000116  f7fffffe          BL       SPI_Timer_On
                  |L1.282|
;;;301    				while ((SPI_Timer_Status() == TRUE)
00011a  f7fffffe          BL       SPI_Timer_Status
00011e  2801              CMP      r0,#1
000120  d105              BNE      |L1.302|
;;;302    							 && (__SD_Send_Cmd(cmd, 0))) {
000122  2100              MOVS     r1,#0
000124  4620              MOV      r0,r4
000126  f7fffffe          BL       __SD_Send_Cmd
00012a  2800              CMP      r0,#0
00012c  d1f5              BNE      |L1.282|
                  |L1.302|
;;;303    					#if DEBUG_ENABLE
;;;304    					DEBUG_TOGGLE(DBG_5);
;;;305    					#endif								 
;;;306    				}
;;;307    				#if DEBUG_ENABLE
;;;308    				DEBUG_START(DBG_5);
;;;309    				#endif
;;;310    				SPI_Timer_Off();
00012e  f7fffffe          BL       SPI_Timer_Off
;;;311    				if (SPI_Timer_Status() == FALSE)
000132  f7fffffe          BL       SPI_Timer_Status
000136  2800              CMP      r0,#0
000138  d100              BNE      |L1.316|
;;;312    					ct = 0;
00013a  9000              STR      r0,[sp,#0]
                  |L1.316|
;;;313    				if (__SD_Send_Cmd(CMD59, 0))
00013c  2100              MOVS     r1,#0
00013e  207b              MOVS     r0,#0x7b
000140  f7fffffe          BL       __SD_Send_Cmd
000144  2800              CMP      r0,#0
000146  d001              BEQ      |L1.332|
;;;314    					ct = 0;								// Deactivate CRC check (default)
000148  2000              MOVS     r0,#0
00014a  9000              STR      r0,[sp,#0]
                  |L1.332|
;;;315    				if (__SD_Send_Cmd(CMD16, 512))
00014c  2101              MOVS     r1,#1
00014e  0249              LSLS     r1,r1,#9
000150  2050              MOVS     r0,#0x50
000152  f7fffffe          BL       __SD_Send_Cmd
000156  2800              CMP      r0,#0
000158  d001              BEQ      |L1.350|
;;;316    					ct = 0;								// Set R/W block length to 512 bytes
00015a  2000              MOVS     r0,#0
00015c  9000              STR      r0,[sp,#0]
                  |L1.350|
00015e  1c7f              ADDS     r7,r7,#1
000160  b2ff              UXTB     r7,r7                 ;223
000162  9800              LDR      r0,[sp,#0]            ;223
000164  2f03              CMP      r7,#3                 ;222
000166  d003              BEQ      |L1.368|
000168  2800              CMP      r0,#0                 ;222
00016a  d100              BNE      |L1.366|
00016c  e74f              B        |L1.14|
                  |L1.366|
00016e  e001              B        |L1.372|
                  |L1.368|
;;;317    			}
;;;318    		}
;;;319    	}
;;;320    	if (ct) {
000170  2800              CMP      r0,#0
000172  d011              BEQ      |L1.408|
                  |L1.372|
;;;321    		dev->cardtype = ct;
000174  7070              STRB     r0,[r6,#1]
;;;322    		dev->mount = TRUE;
000176  2001              MOVS     r0,#1
000178  7030              STRB     r0,[r6,#0]
;;;323    		dev->last_sector = __SD_Sectors(dev) - 1;
00017a  4630              MOV      r0,r6
00017c  f7fffffe          BL       __SD_Sectors
000180  1e40              SUBS     r0,r0,#1
;;;324    		dev->debug.read = 0;
000182  6070              STR      r0,[r6,#4]
000184  2000              MOVS     r0,#0
000186  8130              STRH     r0,[r6,#8]
;;;325    		dev->debug.write = 0;
000188  8170              STRH     r0,[r6,#0xa]
00018a  f7fffffe          BL       SPI_Freq_High
;;;326    		__SD_Speed_Transfer(HIGH);	// High speed transfer
;;;327    	}
;;;328    	SPI_Release();
00018e  f7fffffe          BL       SPI_Release
;;;329    	#if DEBUG_ENABLE
;;;330    	DEBUG_STOP(DBG_5);
;;;331    	#endif
;;;332    	return (ct ? SD_OK : SD_NOINIT);
000192  2000              MOVS     r0,#0
;;;333    }
000194  b003              ADD      sp,sp,#0xc
000196  bdf0              POP      {r4-r7,pc}
                  |L1.408|
000198  f7fffffe          BL       SPI_Release
00019c  2001              MOVS     r0,#1                 ;332
00019e  b003              ADD      sp,sp,#0xc
0001a0  bdf0              POP      {r4-r7,pc}
;;;334    
                          ENDP


                          AREA ||i.SD_Read||, CODE, READONLY, ALIGN=2

                  SD_Read PROC
;;;337    #pragma diag_suppress 1441
;;;338    SDRESULTS SD_Read(SD_DEV * dev, void *dat, DWORD sector, WORD ofs,
000000  b5ff              PUSH     {r0-r7,lr}
;;;339    									WORD cnt) {
000002  b081              SUB      sp,sp,#4
;;;340    	SDRESULTS res;
;;;341    	BYTE tkn, data;
;;;342    	WORD byte_num;
;;;343    	volatile uint8_t dummy;
;;;344    	#if DEBUG_ENABLE
;;;345    	DEBUG_START(DBG_2);
;;;346    	#endif
;;;347    
;;;348    	res = SD_ERROR;
000004  2002              MOVS     r0,#2
000006  9f0a              LDR      r7,[sp,#0x28]
;;;349    	if ((sector > dev->last_sector) || (cnt == 0)) {
000008  9000              STR      r0,[sp,#0]
00000a  9801              LDR      r0,[sp,#4]
00000c  461e              MOV      r6,r3                 ;339
00000e  6840              LDR      r0,[r0,#4]
000010  460d              MOV      r5,r1                 ;339
000012  4290              CMP      r0,r2
000014  d308              BCC      |L2.40|
000016  2f00              CMP      r7,#0
000018  d006              BEQ      |L2.40|
;;;350    		#if DEBUG_ENABLE
;;;351    		DEBUG_STOP(DBG_2);
;;;352    		#endif
;;;353    		return (SD_PARERR);
;;;354    	}
;;;355    	// Convert sector number to byte address (sector * SD_BLK_SIZE)
;;;356    	//    if (__SD_Send_Cmd(CMD17, sector * SD_BLK_SIZE) == 0) { // Only for SDSC
;;;357    	if (__SD_Send_Cmd(CMD17, sector) == 0) {	// Only for SDHC or SDXC 
00001a  4611              MOV      r1,r2
00001c  2051              MOVS     r0,#0x51
00001e  f7fffffe          BL       __SD_Send_Cmd
000022  2800              CMP      r0,#0
000024  d003              BEQ      |L2.46|
000026  e029              B        |L2.124|
                  |L2.40|
000028  2003              MOVS     r0,#3                 ;353
;;;358    		SPI_Timer_On(100);
;;;359    		do {
;;;360    			#if DEBUG_ENABLE
;;;361    			DEBUG_TOGGLE(DBG_2);
;;;362    			#endif
;;;363    			tkn = SPI_RW(0xFF);
;;;364    		} while ((tkn == 0xFF) && SPI_Timer_Status() == TRUE);
;;;365    		#if DEBUG_ENABLE
;;;366    		DEBUG_START(DBG_2);
;;;367    		#endif
;;;368    		SPI_Timer_Off();
;;;369    		// Token of single block?
;;;370    		if (tkn == 0xFE) {
;;;371    			// AGD: Loop fusion to simplify FSM formation
;;;372    			byte_num = 0;
;;;373    			do {
;;;374    				#if DEBUG_ENABLE
;;;375    				DEBUG_TOGGLE(DBG_2); 
;;;376    				#endif
;;;377    				data = SPI_RW(0xff);
;;;378    				if ((byte_num >= ofs) && (byte_num < ofs + cnt)) {
;;;379    					*(BYTE *) dat = data;
;;;380    					((BYTE *) dat)++;
;;;381    				}												// else discard bytes before and after data
;;;382    			} while (++byte_num < SD_BLK_SIZE + 2);	// 512 byte block + 2 byte CRC
;;;383    			#if DEBUG_ENABLE
;;;384    			DEBUG_START(DBG_2);
;;;385    			#endif
;;;386    			res = SD_OK;
;;;387    		}
;;;388    	}
;;;389    	SPI_Release();
;;;390    	dev->debug.read++;
;;;391    	#if DEBUG_ENABLE
;;;392    	DEBUG_STOP(DBG_2);
;;;393    	#endif
;;;394    	return (res);
;;;395    }
00002a  b005              ADD      sp,sp,#0x14
00002c  bdf0              POP      {r4-r7,pc}
                  |L2.46|
00002e  2064              MOVS     r0,#0x64              ;358
000030  f7fffffe          BL       SPI_Timer_On
                  |L2.52|
000034  20ff              MOVS     r0,#0xff              ;363
000036  f7fffffe          BL       SPI_RW
00003a  4604              MOV      r4,r0                 ;363
00003c  28ff              CMP      r0,#0xff              ;364
00003e  d004              BEQ      |L2.74|
000040  f7fffffe          BL       SPI_Timer_Off
000044  2cfe              CMP      r4,#0xfe              ;370
000046  d007              BEQ      |L2.88|
000048  e018              B        |L2.124|
                  |L2.74|
00004a  f7fffffe          BL       SPI_Timer_Status
00004e  2801              CMP      r0,#1                 ;364
000050  d0f0              BEQ      |L2.52|
000052  f7fffffe          BL       SPI_Timer_Off
000056  e011              B        |L2.124|
                  |L2.88|
000058  2400              MOVS     r4,#0                 ;372
00005a  19f7              ADDS     r7,r6,r7              ;378
                  |L2.92|
00005c  20ff              MOVS     r0,#0xff              ;377
00005e  f7fffffe          BL       SPI_RW
000062  42b4              CMP      r4,r6                 ;378
000064  d303              BCC      |L2.110|
000066  42a7              CMP      r7,r4                 ;378
000068  d901              BLS      |L2.110|
00006a  7028              STRB     r0,[r5,#0]            ;379
00006c  1c6d              ADDS     r5,r5,#1              ;379
                  |L2.110|
00006e  1c64              ADDS     r4,r4,#1              ;379
000070  4807              LDR      r0,|L2.144|
000072  b2a4              UXTH     r4,r4                 ;382
000074  4284              CMP      r4,r0                 ;382
000076  d3f1              BCC      |L2.92|
000078  2000              MOVS     r0,#0                 ;386
00007a  9000              STR      r0,[sp,#0]            ;386
                  |L2.124|
00007c  f7fffffe          BL       SPI_Release
000080  9801              LDR      r0,[sp,#4]            ;390
000082  9901              LDR      r1,[sp,#4]            ;390
000084  8900              LDRH     r0,[r0,#8]            ;390
000086  1c40              ADDS     r0,r0,#1              ;390
000088  8108              STRH     r0,[r1,#8]            ;390
00008a  9800              LDR      r0,[sp,#0]            ;394
00008c  b005              ADD      sp,sp,#0x14
00008e  bdf0              POP      {r4-r7,pc}
;;;396    
                          ENDP

                  |L2.144|
                          DCD      0x00000202

                          AREA ||i.SD_Status||, CODE, READONLY, ALIGN=1

                  SD_Status PROC
;;;463    
;;;464    SDRESULTS SD_Status(SD_DEV * dev) {
000000  b510              PUSH     {r4,lr}
;;;465    	return (__SD_Send_Cmd(CMD0, 0) ? SD_OK : SD_NORESPONSE);
000002  2100              MOVS     r1,#0
000004  2040              MOVS     r0,#0x40
000006  f7fffffe          BL       __SD_Send_Cmd
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L3.18|
00000e  2000              MOVS     r0,#0
;;;466    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  2006              MOVS     r0,#6                 ;465
000014  bd10              POP      {r4,pc}
;;;467    
                          ENDP


                          AREA ||i.SD_Write||, CODE, READONLY, ALIGN=1

                  SD_Write PROC
;;;398    
;;;399    SDRESULTS SD_Write(SD_DEV * dev, void *dat, DWORD sector) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
;;;400    	WORD idx;
;;;401    	BYTE line;
;;;402    	#if DEBUG_ENABLE
;;;403    	DEBUG_START(DBG_3);
;;;404    	#endif
;;;405    
;;;406    	// Query invalid?
;;;407    	if (sector > dev->last_sector) {
000004  6840              LDR      r0,[r0,#4]
000006  460e              MOV      r6,r1                 ;399
000008  4290              CMP      r0,r2
00000a  d201              BCS      |L4.16|
;;;408    		#if DEBUG_ENABLE
;;;409    		DEBUG_STOP(DBG_3);
;;;410    		#endif
;;;411    		return (SD_PARERR);
00000c  2003              MOVS     r0,#3
;;;412    	}
;;;413    	// Convert sector number to bytes address (sector * SD_BLK_SIZE)
;;;414    	//    if(__SD_Send_Cmd(CMD24, sector * SD_BLK_SIZE)==0) { // Only for SDSC
;;;415    	if (__SD_Send_Cmd(CMD24, sector) == 0) {	// Only for SDHC or SDXC   
;;;416    		// Send token (single block write)
;;;417    		SPI_RW(0xFE);
;;;418    		// Send block data
;;;419    		for (idx = 0; idx != SD_BLK_SIZE; idx++)
;;;420    			SPI_RW(*((BYTE *) dat + idx));
;;;421    		/* Dummy CRC */
;;;422    		SPI_RW(0xFF);
;;;423    		SPI_RW(0xFF);
;;;424    		// If not accepted, returns the reject error
;;;425    		if ((SPI_RW(0xFF) & 0x1F) != 0x05) {
;;;426    			#if DEBUG_ENABLE
;;;427    			DEBUG_STOP(DBG_3);
;;;428    			#endif
;;;429    			return (SD_REJECT);
;;;430    		}
;;;431    		// Waits until finish of data programming with a timeout
;;;432    		SPI_Timer_On(SD_IO_WRITE_TIMEOUT_WAIT);
;;;433    		do {
;;;434    			#if DEBUG_ENABLE
;;;435    			DEBUG_TOGGLE(DBG_3);
;;;436    			#endif
;;;437    			line = SPI_RW(0xFF);
;;;438    		} while ((line == 0) && (SPI_Timer_Status() == TRUE));
;;;439    		#if DEBUG_ENABLE
;;;440    		DEBUG_START(DBG_3);
;;;441    		#endif
;;;442    		SPI_Timer_Off();
;;;443    		dev->debug.write++;
;;;444    
;;;445    		if (line == 0) {
;;;446    			#if DEBUG_ENABLE
;;;447    			DEBUG_STOP(DBG_3);
;;;448    			#endif
;;;449    			return (SD_BUSY);
;;;450    		} else {
;;;451    			#if DEBUG_ENABLE
;;;452    			DEBUG_STOP(DBG_3);
;;;453    			#endif
;;;454    			return (SD_OK);
;;;455    		}
;;;456    	} else {
;;;457    		#if DEBUG_ENABLE
;;;458    		DEBUG_STOP(DBG_3);
;;;459    		#endif
;;;460    		return (SD_ERROR);
;;;461    	}
;;;462    }
00000e  bdf8              POP      {r3-r7,pc}
                  |L4.16|
000010  4611              MOV      r1,r2                 ;415
000012  2058              MOVS     r0,#0x58              ;415
000014  f7fffffe          BL       __SD_Send_Cmd
000018  2800              CMP      r0,#0                 ;415
00001a  d001              BEQ      |L4.32|
00001c  2002              MOVS     r0,#2                 ;460
00001e  bdf8              POP      {r3-r7,pc}
                  |L4.32|
000020  20fe              MOVS     r0,#0xfe              ;417
000022  f7fffffe          BL       SPI_RW
000026  2400              MOVS     r4,#0                 ;419
000028  2701              MOVS     r7,#1                 ;419
00002a  027f              LSLS     r7,r7,#9              ;419
                  |L4.44|
00002c  5d30              LDRB     r0,[r6,r4]            ;420
00002e  f7fffffe          BL       SPI_RW
000032  1c64              ADDS     r4,r4,#1              ;420
000034  b2a4              UXTH     r4,r4                 ;419
000036  42bc              CMP      r4,r7                 ;419
000038  d1f8              BNE      |L4.44|
00003a  20ff              MOVS     r0,#0xff              ;422
00003c  f7fffffe          BL       SPI_RW
000040  20ff              MOVS     r0,#0xff              ;423
000042  f7fffffe          BL       SPI_RW
000046  20ff              MOVS     r0,#0xff              ;425
000048  f7fffffe          BL       SPI_RW
00004c  06c0              LSLS     r0,r0,#27             ;425
00004e  0ec0              LSRS     r0,r0,#27             ;425
000050  2805              CMP      r0,#5                 ;425
000052  d001              BEQ      |L4.88|
000054  2005              MOVS     r0,#5                 ;429
000056  bdf8              POP      {r3-r7,pc}
                  |L4.88|
000058  20fa              MOVS     r0,#0xfa              ;432
00005a  f7fffffe          BL       SPI_Timer_On
                  |L4.94|
00005e  20ff              MOVS     r0,#0xff              ;437
000060  f7fffffe          BL       SPI_RW
000064  0004              MOVS     r4,r0                 ;437
000066  d103              BNE      |L4.112|
000068  f7fffffe          BL       SPI_Timer_Status
00006c  2801              CMP      r0,#1                 ;438
00006e  d0f6              BEQ      |L4.94|
                  |L4.112|
000070  f7fffffe          BL       SPI_Timer_Off
000074  8968              LDRH     r0,[r5,#0xa]          ;443
000076  1c40              ADDS     r0,r0,#1              ;443
000078  8168              STRH     r0,[r5,#0xa]          ;443
00007a  2c00              CMP      r4,#0                 ;445
00007c  d001              BEQ      |L4.130|
00007e  2000              MOVS     r0,#0                 ;454
000080  bdf8              POP      {r3-r7,pc}
                  |L4.130|
000082  2004              MOVS     r0,#4                 ;449
000084  bdf8              POP      {r3-r7,pc}
;;;463    
                          ENDP


                          AREA ||i.__SD_Power_Of_Two||, CODE, READONLY, ALIGN=1

                  __SD_Power_Of_Two PROC
;;;78     
;;;79     DWORD __SD_Power_Of_Two(BYTE e) {
000000  4601              MOV      r1,r0
;;;80     	DWORD partial = 1;
000002  2001              MOVS     r0,#1
;;;81     	BYTE idx;
;;;82     	for (idx = 0; idx != e; idx++)
000004  2900              CMP      r1,#0
000006  d007              BEQ      |L5.24|
;;;83     		partial *= 2;
;;;84     	return (partial);
;;;85     }
000008  07ca              LSLS     r2,r1,#31
00000a  d000              BEQ      |L5.14|
00000c  2002              MOVS     r0,#2                 ;83
                  |L5.14|
00000e  0849              LSRS     r1,r1,#1              ;82
000010  d002              BEQ      |L5.24|
                  |L5.18|
000012  0080              LSLS     r0,r0,#2              ;83
000014  1e49              SUBS     r1,r1,#1              ;83
000016  d1fc              BNE      |L5.18|
                  |L5.24|
000018  4770              BX       lr
;;;86     
                          ENDP


                          AREA ||i.__SD_Sectors||, CODE, READONLY, ALIGN=1

                  __SD_Sectors PROC
;;;159    
;;;160    DWORD __SD_Sectors(SD_DEV * dev) {
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;161    	BYTE csd[16];
;;;162    	BYTE idx;
;;;163    	DWORD ss = 0;
;;;164    	WORD C_SIZE = 0;
000002  2500              MOVS     r5,#0
000004  b088              SUB      sp,sp,#0x20           ;160
;;;165    	BYTE C_SIZE_MULT = 0;
000006  462e              MOV      r6,r5
;;;166    	BYTE READ_BL_LEN = 0;
;;;167    	if (__SD_Send_Cmd(CMD9, 0) == 0) {
000008  4629              MOV      r1,r5
00000a  2049              MOVS     r0,#0x49
00000c  9506              STR      r5,[sp,#0x18]
00000e  f7fffffe          BL       __SD_Send_Cmd
000012  2800              CMP      r0,#0
000014  d002              BEQ      |L6.28|
;;;168    		// Wait for response
;;;169    		while (SPI_RW(0xFF) == 0xFF);
;;;170    		for (idx = 0; idx != 16; idx++)
;;;171    			csd[idx] = SPI_RW(0xFF);
;;;172    		// Dummy CRC
;;;173    		SPI_RW(0xFF);
;;;174    		SPI_RW(0xFF);
;;;175    		SPI_Release();
;;;176    		if (dev->cardtype & SDCT_SD1) {
;;;177    			ss = csd[0];
;;;178    			// READ_BL_LEN[83:80]: max. read data block length
;;;179    			READ_BL_LEN = (csd[5] & 0x0F);
;;;180    			// C_SIZE [73:62]
;;;181    			C_SIZE = (csd[6] & 0x03);
;;;182    			C_SIZE <<= 8;
;;;183    			C_SIZE |= (csd[7]);
;;;184    			C_SIZE <<= 2;
;;;185    			C_SIZE |= ((csd[8] >> 6) & 0x03);
;;;186    			// C_SIZE_MULT [49:47]
;;;187    			C_SIZE_MULT = (csd[9] & 0x03);
;;;188    			C_SIZE_MULT <<= 1;
;;;189    			C_SIZE_MULT |= ((csd[10] >> 7) & 0x01);
;;;190    		} else if (dev->cardtype & SDCT_SD2) {
;;;191    			// READ_BL_LEN = 9;
;;;192    			// C_SIZE [69:48]
;;;193    			C_SIZE = (csd[7] & 0x3F);
;;;194    			C_SIZE <<= 8;
;;;195    			C_SIZE |= (csd[8] & 0xFF);
;;;196    			C_SIZE <<= 8;
;;;197    			C_SIZE |= (csd[9] & 0xFF);
;;;198    			C_SIZE_MULT = 8;					// AD changed
;;;199    		}
;;;200    		ss = (C_SIZE + 1);
;;;201    		ss *= __SD_Power_Of_Two(C_SIZE_MULT + 2);
;;;202    		ss *= __SD_Power_Of_Two(READ_BL_LEN);
;;;203    		// ss /= SD_BLK_SIZE; ?? Bug in original code?
;;;204    
;;;205    		return (ss);
;;;206    	} else
;;;207    		return (0);									// Error
000016  2000              MOVS     r0,#0
;;;208    }
000018  b009              ADD      sp,sp,#0x24
00001a  bdf0              POP      {r4-r7,pc}
                  |L6.28|
00001c  20ff              MOVS     r0,#0xff              ;169
00001e  f7fffffe          BL       SPI_RW
000022  28ff              CMP      r0,#0xff              ;169
000024  d0fa              BEQ      |L6.28|
000026  2400              MOVS     r4,#0                 ;170
000028  466f              MOV      r7,sp                 ;161
                  |L6.42|
00002a  20ff              MOVS     r0,#0xff              ;171
00002c  f7fffffe          BL       SPI_RW
000030  5538              STRB     r0,[r7,r4]            ;171
000032  1c64              ADDS     r4,r4,#1              ;171
000034  b2e4              UXTB     r4,r4                 ;170
000036  2c10              CMP      r4,#0x10              ;170
000038  d1f7              BNE      |L6.42|
00003a  20ff              MOVS     r0,#0xff              ;173
00003c  f7fffffe          BL       SPI_RW
000040  20ff              MOVS     r0,#0xff              ;174
000042  f7fffffe          BL       SPI_RW
000046  f7fffffe          BL       SPI_Release
00004a  9808              LDR      r0,[sp,#0x20]         ;176
00004c  7840              LDRB     r0,[r0,#1]            ;176
00004e  0781              LSLS     r1,r0,#30             ;176
000050  d516              BPL      |L6.128|
000052  4669              MOV      r1,sp                 ;179
000054  7948              LDRB     r0,[r1,#5]            ;179
000056  0700              LSLS     r0,r0,#28             ;179
000058  0f00              LSRS     r0,r0,#28             ;179
00005a  9006              STR      r0,[sp,#0x18]         ;181
00005c  7988              LDRB     r0,[r1,#6]            ;181
00005e  79c9              LDRB     r1,[r1,#7]            ;183
000060  0780              LSLS     r0,r0,#30             ;181
000062  0d80              LSRS     r0,r0,#22             ;182
000064  4301              ORRS     r1,r1,r0              ;183
000066  0088              LSLS     r0,r1,#2              ;183
000068  4669              MOV      r1,sp                 ;185
00006a  7a09              LDRB     r1,[r1,#8]            ;185
00006c  098d              LSRS     r5,r1,#6              ;185
00006e  4305              ORRS     r5,r5,r0              ;185
000070  4669              MOV      r1,sp                 ;187
000072  7a48              LDRB     r0,[r1,#9]            ;187
000074  7a89              LDRB     r1,[r1,#0xa]          ;189
000076  0780              LSLS     r0,r0,#30             ;187
000078  0f40              LSRS     r0,r0,#29             ;188
00007a  09ce              LSRS     r6,r1,#7              ;189
00007c  4306              ORRS     r6,r6,r0              ;189
00007e  e00b              B        |L6.152|
                  |L6.128|
000080  0740              LSLS     r0,r0,#29             ;190
000082  d509              BPL      |L6.152|
000084  466a              MOV      r2,sp                 ;193
000086  79d0              LDRB     r0,[r2,#7]            ;193
000088  7a55              LDRB     r5,[r2,#9]            ;197
00008a  0201              LSLS     r1,r0,#8              ;194
00008c  7a10              LDRB     r0,[r2,#8]            ;195
00008e  4308              ORRS     r0,r0,r1              ;195
000090  0600              LSLS     r0,r0,#24             ;196
000092  0c00              LSRS     r0,r0,#16             ;196
000094  4305              ORRS     r5,r5,r0              ;197
000096  2608              MOVS     r6,#8                 ;198
                  |L6.152|
000098  2101              MOVS     r1,#1                 ;198
00009a  1c6d              ADDS     r5,r5,#1              ;198
00009c  1cb6              ADDS     r6,r6,#2              ;198
00009e  d007              BEQ      |L6.176|
0000a0  07f0              LSLS     r0,r6,#31             ;198
0000a2  d000              BEQ      |L6.166|
0000a4  2102              MOVS     r1,#2                 ;198
                  |L6.166|
0000a6  0870              LSRS     r0,r6,#1              ;198
0000a8  d002              BEQ      |L6.176|
                  |L6.170|
0000aa  0089              LSLS     r1,r1,#2              ;198
0000ac  1e40              SUBS     r0,r0,#1              ;198
0000ae  d1fc              BNE      |L6.170|
                  |L6.176|
0000b0  9a06              LDR      r2,[sp,#0x18]         ;198
0000b2  4369              MULS     r1,r5,r1              ;201
0000b4  2001              MOVS     r0,#1                 ;201
0000b6  2a00              CMP      r2,#0                 ;201
0000b8  d007              BEQ      |L6.202|
0000ba  07d3              LSLS     r3,r2,#31             ;201
0000bc  d000              BEQ      |L6.192|
0000be  2002              MOVS     r0,#2                 ;201
                  |L6.192|
0000c0  0852              LSRS     r2,r2,#1              ;201
0000c2  d002              BEQ      |L6.202|
                  |L6.196|
0000c4  0080              LSLS     r0,r0,#2              ;201
0000c6  1e52              SUBS     r2,r2,#1              ;201
0000c8  d1fc              BNE      |L6.196|
                  |L6.202|
0000ca  4348              MULS     r0,r1,r0              ;202
0000cc  b009              ADD      sp,sp,#0x24
0000ce  bdf0              POP      {r4-r7,pc}
;;;209    
                          ENDP


                          AREA ||i.__SD_Send_Cmd||, CODE, READONLY, ALIGN=1

                  __SD_Send_Cmd PROC
;;;99     
;;;100    BYTE __SD_Send_Cmd(BYTE cmd, DWORD arg) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;101    	BYTE crc, res;
;;;102    	#if DEBUG_ENABLE
;;;103    	DEBUG_START(DBG_4);
;;;104    	#endif
;;;105    
;;;106    	// ACMD«n» is the command sequense of CMD55-CMD«n»
;;;107    	if (cmd & 0x80) {
000006  0600              LSLS     r0,r0,#24
000008  d507              BPL      |L7.26|
;;;108    		cmd &= 0x7F;
00000a  0664              LSLS     r4,r4,#25
00000c  0e64              LSRS     r4,r4,#25
;;;109    		res = __SD_Send_Cmd(CMD55, 0);
00000e  2100              MOVS     r1,#0
000010  2077              MOVS     r0,#0x77
000012  f7fffffe          BL       __SD_Send_Cmd
;;;110    		if (res > 1) {
000016  2801              CMP      r0,#1
000018  d835              BHI      |L7.134|
                  |L7.26|
;;;111    			#if DEBUG_ENABLE
;;;112    			DEBUG_STOP(DBG_4);
;;;113    			#endif
;;;114    			return (res);
;;;115    
;;;116    		}
;;;117    	}
;;;118    	// Select the card
;;;119    	__SD_Deassert();
00001a  f7fffffe          BL       SPI_CS_High
;;;120    	SPI_RW(0xFF);
00001e  20ff              MOVS     r0,#0xff
000020  f7fffffe          BL       SPI_RW
;;;121    	__SD_Assert();
000024  f7fffffe          BL       SPI_CS_Low
;;;122    	SPI_RW(0xFF);
000028  20ff              MOVS     r0,#0xff
00002a  f7fffffe          BL       SPI_RW
;;;123    
;;;124    	// Send complete command set
;;;125    	SPI_RW(cmd);									// Start and command index
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SPI_RW
;;;126    	SPI_RW((BYTE) (arg >> 24));		// Arg[31-24]
000034  0e28              LSRS     r0,r5,#24
000036  f7fffffe          BL       SPI_RW
;;;127    	SPI_RW((BYTE) (arg >> 16));		// Arg[23-16]
00003a  0228              LSLS     r0,r5,#8
00003c  0e00              LSRS     r0,r0,#24
00003e  f7fffffe          BL       SPI_RW
;;;128    	SPI_RW((BYTE) (arg >> 8));		// Arg[15-08]
000042  0428              LSLS     r0,r5,#16
000044  0e00              LSRS     r0,r0,#24
000046  f7fffffe          BL       SPI_RW
;;;129    	SPI_RW((BYTE) (arg >> 0));		// Arg[07-00]
00004a  b2e8              UXTB     r0,r5
00004c  f7fffffe          BL       SPI_RW
;;;130    
;;;131    	// CRC?
;;;132    	crc = 0x01;										// Dummy CRC and stop
000050  2001              MOVS     r0,#1
;;;133    	if (cmd == CMD0)
000052  2c40              CMP      r4,#0x40
000054  d002              BEQ      |L7.92|
;;;134    		crc = 0x95;									// Valid CRC for CMD0(0)
;;;135    	if (cmd == CMD8)
000056  2c48              CMP      r4,#0x48
000058  d002              BEQ      |L7.96|
00005a  e002              B        |L7.98|
                  |L7.92|
00005c  2095              MOVS     r0,#0x95              ;134
00005e  e000              B        |L7.98|
                  |L7.96|
;;;136    		crc = 0x87;									// Valid CRC for CMD8(0x1AA)
000060  2087              MOVS     r0,#0x87
                  |L7.98|
;;;137    	SPI_RW(crc);
000062  f7fffffe          BL       SPI_RW
;;;138    
;;;139    	// Receive command response
;;;140    	// Wait for a valid response in timeout of 5 milliseconds
;;;141    	SPI_Timer_On(5);
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       SPI_Timer_On
                  |L7.108|
;;;142    	do {
;;;143    		#if DEBUG_ENABLE
;;;144    		DEBUG_TOGGLE(DBG_4);
;;;145    		#endif
;;;146    		res = SPI_RW(0xFF);
00006c  20ff              MOVS     r0,#0xff
00006e  f7fffffe          BL       SPI_RW
000072  4604              MOV      r4,r0
;;;147    	} while ((res & 0x80) && (SPI_Timer_Status() == TRUE));
000074  0600              LSLS     r0,r0,#24
000076  d503              BPL      |L7.128|
000078  f7fffffe          BL       SPI_Timer_Status
00007c  2801              CMP      r0,#1
00007e  d0f5              BEQ      |L7.108|
                  |L7.128|
;;;148    	#if DEBUG_ENABLE
;;;149    	DEBUG_START(DBG_4);
;;;150    	#endif
;;;151    	SPI_Timer_Off();
000080  f7fffffe          BL       SPI_Timer_Off
;;;152    
;;;153    	// Return with the response value
;;;154    	#if DEBUG_ENABLE
;;;155    	DEBUG_STOP(DBG_4)
;;;156    	#endif
;;;157    			return (res);
000084  4620              MOV      r0,r4
                  |L7.134|
;;;158    }
000086  bd70              POP      {r4-r6,pc}
;;;159    
                          ENDP


                          AREA ||i.__SD_Speed_Transfer||, CODE, READONLY, ALIGN=1

                  __SD_Speed_Transfer PROC
;;;94     
;;;95     void __SD_Speed_Transfer(BYTE throttle) {
000000  2801              CMP      r0,#1
;;;96     	if (throttle == HIGH)
000002  d103              BNE      |L8.12|
000004  b510              PUSH     {r4,lr}               ;95
;;;97     		SPI_Freq_High();
000006  f7fffffe          BL       SPI_Freq_High
;;;98     }
00000a  bd10              POP      {r4,pc}
                  |L8.12|
00000c  4770              BX       lr
;;;99     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  timeout
                          DCD      0x00000000

                          AREA ||area_number.12||, DATA, ALIGN=0

                          EXPORTAS ||area_number.12||, ||.data||
                  SD_Errors
000000  4f4b0000          DCB      0x4f,0x4b,0x00,0x00
                          DCDU     0x00000000
000008  4e4f494e          DCB      0x4e,0x4f,0x49,0x4e
00000c  49540000          DCB      0x49,0x54,0x00,0x00
000010  4552524f          DCB      0x45,0x52,0x52,0x4f
000014  52000000          DCB      0x52,0x00,0x00,0x00
000018  50415245          DCB      0x50,0x41,0x52,0x45
00001c  52520000          DCB      0x52,0x52,0x00,0x00
000020  42555359          DCB      0x42,0x55,0x53,0x59
000024  00000000          DCB      0x00,0x00,0x00,0x00
000028  52454a45          DCB      0x52,0x45,0x4a,0x45
00002c  43540000          DCB      0x43,0x54,0x00,0x00
000030  4e4f5245          DCB      0x4e,0x4f,0x52,0x45
000034  53500000          DCB      0x53,0x50,0x00,0x00

;*** Start embedded assembler ***

#line 1 "Source\\ulibSD\\sd_io.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_sd_io_c_timeout____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_sd_io_c_timeout____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_sd_io_c_timeout____REVSH|
#line 462
|__asm___7_sd_io_c_timeout____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
